{% extends 'layout.html' %}

{% block title %}Yılan Oyunu - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>Yılan Oyunu <span class="badge">Klasik Arcade</span></h1>
      <p class="game-description">Yılanı yönlendirerek en yüksek skoru elde etmeye çalışın.</p>
    </div>

    <div class="snake-container">
      <div class="game-status">
        <div class="status-item">
          <div class="status-label">Skor</div>
          <div class="status-value" id="score">0</div>
        </div>
        <div class="status-item">
          <div class="status-label">En İyi</div>
          <div class="status-value" id="high-score">0</div>
        </div>
        <div class="status-item">
          <div class="status-label">Seviye</div>
          <div class="status-value" id="level">1</div>
        </div>
        <div class="status-item">
          <div class="status-label">Uzunluk</div>
          <div class="status-value" id="length">3</div>
        </div>
      </div>
      
      <div class="snake-game-area">
        <canvas id="game-canvas" width="400" height="400"></canvas>
        
        <div class="game-overlay" id="start-overlay">
          <div class="overlay-content">
            <h2>Yılan Oyununa Hoş Geldiniz!</h2>
            
            <div class="game-options">
              <div class="option-section">
                <h3>Hız</h3>
                <div class="button-group">
                  <button class="option-btn" data-speed="slow">Yavaş</button>
                  <button class="option-btn active" data-speed="medium">Orta</button>
                  <button class="option-btn" data-speed="fast">Hızlı</button>
                </div>
              </div>
              
              <div class="option-section">
                <h3>Duvarlar</h3>
                <div class="button-group">
                  <button class="option-btn active" data-walls="on">Açık</button>
                  <button class="option-btn" data-walls="off">Kapalı</button>
                </div>
              </div>
              
              <div class="option-section">
                <h3>Zorluk</h3>
                <div class="button-group">
                  <button class="option-btn active" data-difficulty="normal">Normal</button>
                  <button class="option-btn" data-difficulty="hard">Zor</button>
                  <button class="option-btn" data-difficulty="expert">Uzman</button>
                </div>
              </div>
              
              <div class="option-section">
                <h3>Tema</h3>
                <div class="button-group">
                  <button class="theme-btn active" data-theme="classic">Klasik</button>
                  <button class="theme-btn" data-theme="neon">Neon</button>
                  <button class="theme-btn" data-theme="pixel">Piksel</button>
                  <button class="theme-btn" data-theme="dark">Karanlık</button>
                </div>
              </div>
              
              <div class="option-section">
                <h3>Oyun Modu</h3>
                <div class="button-group">
                  <button class="mode-btn active" data-mode="classic">Klasik</button>
                  <button class="mode-btn" data-mode="time-attack">Süre Yarışı</button>
                  <button class="mode-btn" data-mode="obstacles">Engelli</button>
                </div>
              </div>
            </div>
            
            <button id="start-game-btn" class="btn btn-primary btn-lg">
              <i class="fas fa-play me-2"></i>Oyuna Başla
            </button>
          </div>
        </div>
        
        <div class="game-overlay" id="pause-overlay" style="display: none;">
          <div class="overlay-content">
            <h2>Oyun Duraklatıldı</h2>
            <button id="resume-btn" class="btn btn-primary">
              <i class="fas fa-play me-2"></i>Devam Et
            </button>
            <button id="restart-from-pause-btn" class="btn btn-warning">
              <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
            </button>
            <a href="{{ url_for('all_games') }}" class="btn btn-outline-light">
              <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
            </a>
          </div>
        </div>
        
        <div class="game-controls">
          <div class="control-group">
            <button id="pause-game" class="btn btn-outline-light" disabled>
              <i class="fas fa-pause me-2"></i>Duraklat
            </button>
            <button id="restart-btn" class="btn btn-outline-warning" disabled>
              <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
            </button>
          </div>
          
          <div class="snake-mobile-controls">
            <div class="mobile-controls-row">
              <button id="up-btn" class="control-btn">
                <i class="fas fa-arrow-up"></i>
              </button>
            </div>
            <div class="mobile-controls-row">
              <button id="left-btn" class="control-btn">
                <i class="fas fa-arrow-left"></i>
              </button>
              <button id="down-btn" class="control-btn">
                <i class="fas fa-arrow-down"></i>
              </button>
              <button id="right-btn" class="control-btn">
                <i class="fas fa-arrow-right"></i>
              </button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="snake-sidebar">
        <div class="game-stats">
          <h3>İstatistikler</h3>
          <div class="stats-list">
            <div class="stat-row">
              <span class="stat-name">Oyun Süresi:</span>
              <span class="stat-value" id="game-time">00:00</span>
            </div>
            <div class="stat-row">
              <span class="stat-name">Yenilen Yemek:</span>
              <span class="stat-value" id="food-eaten">0</span>
            </div>
            <div class="stat-row">
              <span class="stat-name">Ortalama Hız:</span>
              <span class="stat-value" id="avg-speed">0 birim/s</span>
            </div>
          </div>
        </div>
        
        <div class="snake-instructions">
          <h3>Kontroller</h3>
          <ul>
            <li><span class="key">↑</span> Yukarı</li>
            <li><span class="key">↓</span> Aşağı</li>
            <li><span class="key">←</span> Sol</li>
            <li><span class="key">→</span> Sağ</li>
            <li><span class="key">P</span> Duraklat</li>
            <li><span class="key">R</span> Yeniden Başlat</li>
          </ul>
        </div>
        
        <a href="{{ url_for('all_games') }}" class="btn btn-outline-secondary btn-block">
          <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
        </a>
      </div>
    </div>

    <div id="game-over-modal" class="snake-modal">
      <div class="modal-content">
        <h2>Oyun Bitti!</h2>
        
        <div class="result-stats">
          <div class="result-stat">
            <div class="result-value" id="final-score">0</div>
            <div class="result-label">Toplam Puan</div>
          </div>
          <div class="result-stat">
            <div class="result-value" id="final-length">0</div>
            <div class="result-label">Yılan Uzunluğu</div>
          </div>
          <div class="result-stat">
            <div class="result-value" id="final-level">1</div>
            <div class="result-label">Seviye</div>
          </div>
        </div>
        
        <div class="result-details">
          <div class="detail-item">
            <span class="detail-label">Toplam Süre:</span>
            <span class="detail-value" id="final-time">00:00</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Yenen Yemek:</span>
            <span class="detail-value" id="final-food">0</span>
          </div>
          <div class="detail-item">
            <span class="detail-label">Oyun Modu:</span>
            <span class="detail-value" id="final-mode">Klasik</span>
          </div>
        </div>
        
        <div class="modal-actions">
          <button id="play-again" class="btn btn-primary">
            <i class="fas fa-redo-alt me-2"></i>Tekrar Oyna
          </button>
          <a href="{{ url_for('all_games') }}" class="btn btn-outline-light">
            <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
          </a>
        </div>
      </div>
    </div>
    
    <div id="level-up-modal" class="snake-modal">
      <div class="modal-content level-up-content">
        <h2><i class="fas fa-arrow-circle-up me-2"></i>Seviye Atladınız!</h2>
        <div class="level-info">
          <div class="level-number" id="new-level">2</div>
          <p>Seviyeye ulaştınız!</p>
        </div>
        <div class="level-rewards">
          <div class="reward">
            <i class="fas fa-bolt"></i>
            <span>Hızınız arttı</span>
          </div>
          <div class="reward">
            <i class="fas fa-apple-alt"></i>
            <span>Daha fazla puan kazanacaksınız</span>
          </div>
        </div>
        <button id="continue-btn" class="btn btn-success">
          <i class="fas fa-check me-2"></i>Devam Et
        </button>
      </div>
    </div>
    
    <div id="notification" class="game-notification">
      <div class="notification-content">
        <p id="notification-message"></p>
        <button id="close-notification" class="btn-close"><i class="fas fa-times"></i></button>
      </div>
    </div>
  </div>
</div>

<style>
  .snake-container {
    display: flex;
    flex-wrap: wrap;
    gap: 20px;
    max-width: 100%;
    margin: 0 auto;
    padding: 0 10px;
  }
  
  .game-status {
    display: flex;
    justify-content: space-between;
    background: rgba(25, 25, 45, 0.7);
    border-radius: 10px;
    margin-bottom: 20px;
    overflow: hidden;
    width: 100%;
  }

  .status-item {
    flex: 1;
    text-align: center;
    padding: 15px 10px;
    border-right: 1px solid rgba(255, 255, 255, 0.1);
  }

  .status-item:last-child {
    border-right: none;
  }

  .status-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 5px;
  }

  .status-value {
    font-size: 1.8rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  .snake-game-area {
    flex: 1;
    min-width: 300px;
    display: flex;
    flex-direction: column;
    align-items: center;
    position: relative;
  }

  #game-canvas {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 10px;
    margin-bottom: 15px;
    max-width: 100%;
    height: auto;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
  }
  
  .game-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(25, 25, 45, 0.9);
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
  }
  
  .overlay-content {
    max-width: 90%;
    width: 100%;
    padding: 20px;
    text-align: center;
  }
  
  .overlay-content h2 {
    color: var(--accent-color);
    margin-bottom: 20px;
    font-size: 1.8rem;
  }
  
  .game-options {
    margin-bottom: 25px;
  }
  
  .option-section {
    background: rgba(30, 30, 60, 0.5);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 10px;
  }
  
  .option-section h3 {
    color: white;
    font-size: 1.1rem;
    margin-bottom: 10px;
  }
  
  .button-group {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .option-btn, .theme-btn, .mode-btn {
    flex: 1;
    padding: 8px 15px;
    background: rgba(40, 40, 80, 0.5);
    border: 1px solid rgba(255, 255, 255, 0.1);
    border-radius: 5px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-size: 0.9rem;
  }
  
  .option-btn:hover, .theme-btn:hover, .mode-btn:hover {
    background: rgba(60, 60, 100, 0.5);
  }
  
  .option-btn.active, .theme-btn.active, .mode-btn.active {
    background: var(--accent-color);
    border-color: var(--accent-color);
  }

  .game-controls {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
    width: 100%;
  }

  .control-group {
    display: flex;
    gap: 10px;
  }

  .snake-mobile-controls {
    display: none;
    flex-direction: column;
    align-items: center;
    gap: 10px;
  }

  .mobile-controls-row {
    display: flex;
    gap: 10px;
  }

  .control-btn {
    width: 60px;
    height: 60px;
    border-radius: 50%;
    background: rgba(106, 90, 224, 0.3);
    border: 1px solid rgba(106, 90, 224, 0.5);
    color: white;
    font-size: 1.5rem;
    display: flex;
    justify-content: center;
    align-items: center;
    cursor: pointer;
    transition: all 0.3s ease;
  }

  .control-btn:active {
    background: rgba(106, 90, 224, 0.6);
    transform: scale(0.95);
  }

  .snake-sidebar {
    width: 300px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  
  .game-stats, .snake-instructions {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 10px;
    padding: 15px;
  }
  
  .game-stats h3, .snake-instructions h3 {
    color: var(--accent-color);
    font-size: 1.2rem;
    margin-bottom: 15px;
    text-align: center;
  }
  
  .stats-list {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .stat-row {
    display: flex;
    justify-content: space-between;
    padding-bottom: 8px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .stat-row:last-child {
    border-bottom: none;
    padding-bottom: 0;
  }
  
  .stat-name {
    color: rgba(255, 255, 255, 0.7);
  }
  
  .stat-value {
    color: white;
    font-weight: 600;
  }

  .snake-instructions ul {
    list-style-type: none;
    padding: 0;
    margin: 0;
  }

  .snake-instructions li {
    display: flex;
    align-items: center;
    margin-bottom: 8px;
    color: rgba(255, 255, 255, 0.8);
  }

  .key {
    display: inline-block;
    width: 30px;
    height: 30px;
    background: rgba(40, 40, 80, 0.5);
    border-radius: 5px;
    margin-right: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 0.9rem;
    color: white;
  }

  .btn-block {
    width: 100%;
    margin-top: auto;
  }

  /* Game Over Modal */
  .snake-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
  }

  .modal-content {
    background: rgba(25, 25, 45, 0.95);
    border-radius: 15px;
    padding: 30px;
    text-align: center;
    max-width: 90%;
    width: 400px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.1);
    animation: modalFadeIn 0.5s;
  }

  .modal-content h2 {
    color: var(--accent-color);
    margin-bottom: 20px;
    font-size: 1.8rem;
  }
  
  .result-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 20px;
  }
  
  .result-stat {
    text-align: center;
    padding: 10px;
  }
  
  .result-value {
    font-size: 2.2rem;
    font-weight: 700;
    color: var(--accent-color);
    margin-bottom: 5px;
  }
  
  .result-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
  }
  
  .result-details {
    background: rgba(30, 30, 60, 0.5);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
    text-align: left;
  }
  
  .detail-item {
    display: flex;
    justify-content: space-between;
    padding: 8px 0;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .detail-item:last-child {
    border-bottom: none;
  }
  
  .detail-label {
    color: rgba(255, 255, 255, 0.7);
  }
  
  .detail-value {
    color: white;
    font-weight: 600;
  }

  .modal-actions {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  /* Level Up Modal */
  .level-up-content {
    background: linear-gradient(135deg, rgba(25, 25, 45, 0.95), rgba(40, 40, 80, 0.95));
  }
  
  .level-info {
    margin-bottom: 20px;
  }
  
  .level-number {
    font-size: 5rem;
    font-weight: 800;
    color: var(--accent-color);
    text-shadow: 0 0 10px rgba(106, 90, 224, 0.5);
    margin-bottom: 5px;
    line-height: 1;
  }
  
  .level-rewards {
    background: rgba(30, 30, 60, 0.5);
    border-radius: 10px;
    padding: 15px;
    margin-bottom: 20px;
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .reward {
    display: flex;
    align-items: center;
    gap: 10px;
    color: #4CAF50;
  }
  
  .reward i {
    font-size: 1.2rem;
  }
  
  /* Notification */
  .game-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(25, 25, 45, 0.9);
    border-radius: 8px;
    padding: 15px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    max-width: 300px;
    transform: translateY(100px);
    opacity: 0;
    transition: all 0.3s ease;
    pointer-events: none;
  }
  
  .game-notification.show {
    transform: translateY(0);
    opacity: 1;
    pointer-events: all;
  }
  
  .notification-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .notification-content p {
    margin: 0;
    color: white;
    font-size: 0.9rem;
  }
  
  .btn-close {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    font-size: 1rem;
    padding: 0;
    margin-left: 10px;
  }

  @keyframes modalFadeIn {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .snake-container {
      flex-direction: column;
    }
    
    .snake-sidebar {
      width: 100%;
      order: 1;
    }
    
    .snake-game-area {
      order: 0;
    }
    
    .snake-mobile-controls {
      display: flex;
    }
    
    .snake-instructions {
      display: none;
    }
  }
  
  @media (max-width: 480px) {
    .status-value {
      font-size: 1.5rem;
    }
    
    .control-btn {
      width: 50px;
      height: 50px;
      font-size: 1.2rem;
    }
    
    .modal-content {
      padding: 20px;
    }
    
    .result-value {
      font-size: 1.8rem;
    }
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const canvas = document.getElementById('game-canvas');
  const ctx = canvas.getContext('2d');
  
  const scoreEl = document.getElementById('score');
  const highScoreEl = document.getElementById('high-score');
  const levelEl = document.getElementById('level');
  const lengthEl = document.getElementById('length');
  
  const gameTimeEl = document.getElementById('game-time');
  const foodEatenEl = document.getElementById('food-eaten');
  const avgSpeedEl = document.getElementById('avg-speed');
  
  const startOverlay = document.getElementById('start-overlay');
  const pauseOverlay = document.getElementById('pause-overlay');
  
  const pauseBtn = document.getElementById('pause-game');
  const restartBtn = document.getElementById('restart-btn');
  const startGameBtn = document.getElementById('start-game-btn');
  const resumeBtn = document.getElementById('resume-btn');
  const restartFromPauseBtn = document.getElementById('restart-from-pause-btn');
  const playAgainBtn = document.getElementById('play-again');
  const continueBtn = document.getElementById('continue-btn');
  
  const speedBtns = document.querySelectorAll('[data-speed]');
  const wallsBtns = document.querySelectorAll('[data-walls]');
  const difficultyBtns = document.querySelectorAll('[data-difficulty]');
  const themeBtns = document.querySelectorAll('[data-theme]');
  const modeBtns = document.querySelectorAll('[data-mode]');
  
  const mobileControls = document.querySelectorAll('.control-btn');
  const upBtn = document.getElementById('up-btn');
  const downBtn = document.getElementById('down-btn');
  const leftBtn = document.getElementById('left-btn');
  const rightBtn = document.getElementById('right-btn');
  
  const gameOverModal = document.getElementById('game-over-modal');
  const levelUpModal = document.getElementById('level-up-modal');
  const finalScoreEl = document.getElementById('final-score');
  const finalLengthEl = document.getElementById('final-length');
  const finalLevelEl = document.getElementById('final-level');
  const finalTimeEl = document.getElementById('final-time');
  const finalFoodEl = document.getElementById('final-food');
  const finalModeEl = document.getElementById('final-mode');
  const newLevelEl = document.getElementById('new-level');
  
  const notification = document.getElementById('notification');
  const notificationMessage = document.getElementById('notification-message');
  const closeNotification = document.getElementById('close-notification');

  // Game Settings
  let speed = 150; // Milliseconds between updates
  let difficulty = 'normal';
  let wallsEnabled = true;
  let theme = 'classic';
  let gameMode = 'classic';
  
  // Game state
  let snake = [];
  let food = {};
  let obstacles = []; // For hard difficulty
  let powerups = []; // For expert difficulty and time-attack mode
  let direction = 'right';
  let nextDirection = 'right';
  let score = 0;
  let highScore = 0;
  let level = 1;
  let gameRunning = false;
  let gamePaused = false;
  let gameLoop = null;
  let startTime = 0;
  let currentTime = 0;
  let foodEaten = 0;
  let distanceTraveled = 0;
  let lastUpdateTime = 0;
  let gameTimeInSeconds = 0;
  let timeAttackTimeRemaining = 60; // For time-attack mode
  let timeAttackTimer = null;
  
  // Grid configuration
  const gridSize = 20; // Size of each grid cell
  const gridWidth = canvas.width / gridSize;
  const gridHeight = canvas.height / gridSize;
  
  // Sounds
  const eatSound = new Audio('/static/sounds/correct.mp3');
  const gameOverSound = new Audio('/static/sounds/game-over.mp3');
  const levelUpSound = new Audio('/static/sounds/level-up.mp3');
  const powerupSound = new Audio('/static/sounds/match.mp3');
  
  // Game Colors by Theme
  const themeColors = {
    classic: {
      background: '#1a1a2e',
      grid: '#252545',
      snake: { 
        head: '#6a5ae0',
        body: '#a890ff'
      },
      food: '#F44336',
      obstacle: '#808080',
      powerup: '#4CAF50'
    },
    neon: {
      background: '#000000',
      grid: '#0a0a0a',
      snake: {
        head: '#00ffff',
        body: '#00cccc'
      },
      food: '#ff00ff',
      obstacle: '#222222',
      powerup: '#00ff00'
    },
    pixel: {
      background: '#38385a',
      grid: '#2d2d4d',
      snake: {
        head: '#9eff91',
        body: '#5cce54'
      },
      food: '#ff5f5f',
      obstacle: '#474747',
      powerup: '#ffff8f'
    },
    dark: {
      background: '#121212',
      grid: '#1e1e1e',
      snake: {
        head: '#bb86fc',
        body: '#3700b3'
      },
      food: '#cf6679',
      obstacle: '#333333',
      powerup: '#03dac6'
    }
  };
  
  // Initialize
  drawEmptyBoard();
  
  // Check for stored high score
  if (localStorage.getItem('snakeHighScore')) {
    highScore = parseInt(localStorage.getItem('snakeHighScore'));
    highScoreEl.textContent = highScore;
  }
  
  // Event listeners for settings
  speedBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const speedSetting = this.getAttribute('data-speed');
      
      if (speedSetting === 'slow') speed = 200;
      else if (speedSetting === 'medium') speed = 150;
      else if (speedSetting === 'fast') speed = 100;
      
      // Update UI
      speedBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
    });
  });
  
  wallsBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const wallsSetting = this.getAttribute('data-walls');
      wallsEnabled = wallsSetting === 'on';
      
      // Update UI
      wallsBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
    });
  });
  
  difficultyBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      difficulty = this.getAttribute('data-difficulty');
      
      // Update UI
      difficultyBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
    });
  });
  
  themeBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      theme = this.getAttribute('data-theme');
      
      // Update UI
      themeBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
      
      // Redraw the empty board with new theme
      drawEmptyBoard();
    });
  });
  
  modeBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      gameMode = this.getAttribute('data-mode');
      
      // Update UI
      modeBtns.forEach(b => b.classList.remove('active'));
      this.classList.add('active');
    });
  });
  
  // Control buttons
  startGameBtn.addEventListener('click', startGame);
  pauseBtn.addEventListener('click', togglePause);
  resumeBtn.addEventListener('click', togglePause);
  restartBtn.addEventListener('click', restartGame);
  restartFromPauseBtn.addEventListener('click', function() {
    pauseOverlay.style.display = 'none';
    restartGame();
  });
  playAgainBtn.addEventListener('click', function() {
    gameOverModal.style.display = 'none';
    startGame();
  });
  continueBtn.addEventListener('click', function() {
    levelUpModal.style.display = 'none';
    gameRunning = true;
    gamePaused = false;
    lastUpdateTime = Date.now();
    gameLoop = setInterval(updateGame, speed);
  });
  
  // Close notification
  closeNotification.addEventListener('click', function() {
    notification.classList.remove('show');
  });
  
  // Keyboard controls
  document.addEventListener('keydown', function(e) {
    if (!gameRunning && e.key === 'Enter') {
      startGame();
      return;
    }
    
    if (gameRunning && e.key === 'p' || e.key === 'P') {
      togglePause();
      return;
    }
    
    if (gameRunning && (e.key === 'r' || e.key === 'R')) {
      restartGame();
      return;
    }
    
    if (!gameRunning || gamePaused) return;
    
    if (e.key === 'ArrowUp' && direction !== 'down') {
      nextDirection = 'up';
    } else if (e.key === 'ArrowDown' && direction !== 'up') {
      nextDirection = 'down';
    } else if (e.key === 'ArrowLeft' && direction !== 'right') {
      nextDirection = 'left';
    } else if (e.key === 'ArrowRight' && direction !== 'left') {
      nextDirection = 'right';
    }
  });
  
  // Mobile controls
  upBtn.addEventListener('click', function() {
    if (direction !== 'down') nextDirection = 'up';
  });
  
  downBtn.addEventListener('click', function() {
    if (direction !== 'up') nextDirection = 'down';
  });
  
  leftBtn.addEventListener('click', function() {
    if (direction !== 'right') nextDirection = 'left';
  });
  
  rightBtn.addEventListener('click', function() {
    if (direction !== 'left') nextDirection = 'right';
  });
  
  // Touch swipe controls
  let touchStartX = 0;
  let touchStartY = 0;
  
  canvas.addEventListener('touchstart', function(e) {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchmove', function(e) {
    if (!touchStartX || !touchStartY) return;
    
    const touchEndX = e.touches[0].clientX;
    const touchEndY = e.touches[0].clientY;
    
    const diffX = touchStartX - touchEndX;
    const diffY = touchStartY - touchEndY;
    
    // Determine the most significant direction of swipe
    if (Math.abs(diffX) > Math.abs(diffY)) {
      // Horizontal swipe
      if (diffX > 0 && direction !== 'right') {
        nextDirection = 'left';
      } else if (diffX < 0 && direction !== 'left') {
        nextDirection = 'right';
      }
    } else {
      // Vertical swipe
      if (diffY > 0 && direction !== 'down') {
        nextDirection = 'up';
      } else if (diffY < 0 && direction !== 'up') {
        nextDirection = 'down';
      }
    }
    
    touchStartX = touchEndX;
    touchStartY = touchEndY;
    e.preventDefault();
  }, { passive: false });
  
  // Functions
  function startGame() {
    // Hide start overlay
    startOverlay.style.display = 'none';
    
    // Reset game state
    snake = [
      {x: 10, y: 10},
      {x: 9, y: 10},
      {x: 8, y: 10}
    ];
    
    direction = 'right';
    nextDirection = 'right';
    score = 0;
    level = 1;
    foodEaten = 0;
    distanceTraveled = 0;
    gameTimeInSeconds = 0;
    obstacles = [];
    powerups = [];
    
    // Update UI
    scoreEl.textContent = score;
    levelEl.textContent = level;
    lengthEl.textContent = snake.length;
    gameTimeEl.textContent = '00:00';
    foodEatenEl.textContent = foodEaten;
    avgSpeedEl.textContent = '0 birim/s';
    
    // Generate initial food
    generateFood();
    
    // Generate obstacle if on hard or expert difficulty
    if (difficulty === 'hard' || difficulty === 'expert') {
      generateObstacles();
    }
    
    // Generate powerup if in expert difficulty or time-attack mode
    if (difficulty === 'expert' || gameMode === 'time-attack') {
      setTimeout(generatePowerup, 10000); // First powerup after 10 seconds
    }
    
    // Start time attack timer if in that mode
    if (gameMode === 'time-attack') {
      timeAttackTimeRemaining = 60;
      if (timeAttackTimer) clearInterval(timeAttackTimer);
      timeAttackTimer = setInterval(updateTimeAttack, 1000);
    }
    
    // Set up game timing
    startTime = Date.now();
    lastUpdateTime = startTime;
    
    // Start game loop
    if (gameLoop) clearInterval(gameLoop);
    gameRunning = true;
    gamePaused = false;
    gameLoop = setInterval(updateGame, speed);
    
    // Update button states
    pauseBtn.disabled = false;
    restartBtn.disabled = false;
    
    // Show notification
    showNotification('Oyun başladı! İyi eğlenceler!');
  }
  
  function togglePause() {
    if (!gameRunning) return;
    
    if (gamePaused) {
      // Resume game
      pauseOverlay.style.display = 'none';
      gameLoop = setInterval(updateGame, speed);
      gamePaused = false;
      lastUpdateTime = Date.now(); // Reset last update time to avoid big jump
      pauseBtn.innerHTML = '<i class="fas fa-pause me-2"></i>Duraklat';
    } else {
      // Pause game
      pauseOverlay.style.display = 'flex';
      clearInterval(gameLoop);
      gamePaused = true;
      pauseBtn.innerHTML = '<i class="fas fa-play me-2"></i>Devam Et';
    }
  }
  
  function restartGame() {
    if (gameLoop) clearInterval(gameLoop);
    if (timeAttackTimer) clearInterval(timeAttackTimer);
    startGame();
  }
  
  function updateGame() {
    // Calculate elapsed time since last update
    const now = Date.now();
    const deltaTime = (now - lastUpdateTime) / 1000; // in seconds
    lastUpdateTime = now;
    
    // Update game time
    gameTimeInSeconds += deltaTime;
    const minutes = Math.floor(gameTimeInSeconds / 60);
    const seconds = Math.floor(gameTimeInSeconds % 60);
    gameTimeEl.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
    
    // Calculate average speed
    if (distanceTraveled > 0 && gameTimeInSeconds > 0) {
      const avgSpeed = (distanceTraveled / gameTimeInSeconds).toFixed(1);
      avgSpeedEl.textContent = `${avgSpeed} birim/s`;
    }
    
    // Update direction based on next direction
    direction = nextDirection;
    
    // Move snake
    const head = {x: snake[0].x, y: snake[0].y};
    
    switch (direction) {
      case 'up':
        head.y -= 1;
        break;
      case 'down':
        head.y += 1;
        break;
      case 'left':
        head.x -= 1;
        break;
      case 'right':
        head.x += 1;
        break;
    }
    
    // Update distance traveled
    distanceTraveled += 1;
    
    // Check wall collision
    if (wallsEnabled) {
      if (head.x < 0 || head.x >= gridWidth || head.y < 0 || head.y >= gridHeight) {
        gameOver();
        return;
      }
    } else {
      // Wrap around edges
      if (head.x < 0) head.x = gridWidth - 1;
      if (head.x >= gridWidth) head.x = 0;
      if (head.y < 0) head.y = gridHeight - 1;
      if (head.y >= gridHeight) head.y = 0;
    }
    
    // Check self collision
    for (let i = 0; i < snake.length; i++) {
      if (snake[i].x === head.x && snake[i].y === head.y) {
        gameOver();
        return;
      }
    }
    
    // Check obstacle collision
    for (let i = 0; i < obstacles.length; i++) {
      if (obstacles[i].x === head.x && obstacles[i].y === head.y) {
        gameOver();
        return;
      }
    }
    
    // Check food collision
    if (head.x === food.x && head.y === food.y) {
      // Eat food
      eatFood();
    } else {
      // Remove tail if no food was eaten
      snake.pop();
    }
    
    // Check powerup collision
    for (let i = 0; i < powerups.length; i++) {
      if (head.x === powerups[i].x && head.y === powerups[i].y) {
        // Collect powerup
        collectPowerup(powerups[i].type);
        powerups.splice(i, 1);
        break;
      }
    }
    
    // Add new head
    snake.unshift(head);
    
    // Update length display
    lengthEl.textContent = snake.length;
    
    // Draw everything
    drawGame();
  }
  
  function eatFood() {
    // Increment score based on difficulty and length
    const basePoints = 10;
    const difficultyMultiplier = difficulty === 'easy' ? 1 : (difficulty === 'medium' ? 1.5 : 2);
    const levelBonus = level * 2;
    const lengthMultiplier = 1 + (snake.length / 50); // Bonus for longer snakes
    
    const points = Math.round(basePoints * difficultyMultiplier * lengthMultiplier) + levelBonus;
    score += points;
    
    // Update stats
    foodEaten++;
    foodEatenEl.textContent = foodEaten;
    scoreEl.textContent = score;
    
    // Play sound
    eatSound.play();
    
    // Generate new food
    generateFood();
    
    // Add new obstacles in hard and expert modes
    if ((difficulty === 'hard' || difficulty === 'expert') && foodEaten % 3 === 0) {
      generateObstacles();
    }
    
    // Check for level up
    if (snake.length >= level * 7) {
      levelUp();
    }
  }
  
  function generateFood() {
    // Generate food at a random position not occupied by the snake or obstacles
    let validPosition = false;
    let newFood = {};
    
    while (!validPosition) {
      newFood = {
        x: Math.floor(Math.random() * gridWidth),
        y: Math.floor(Math.random() * gridHeight)
      };
      
      validPosition = true;
      
      // Check if food is on snake
      for (const segment of snake) {
        if (newFood.x === segment.x && newFood.y === segment.y) {
          validPosition = false;
          break;
        }
      }
      
      // Check if food is on obstacle
      if (validPosition) {
        for (const obstacle of obstacles) {
          if (newFood.x === obstacle.x && newFood.y === obstacle.y) {
            validPosition = false;
            break;
          }
        }
      }
      
      // Check if food is on powerup
      if (validPosition) {
        for (const powerup of powerups) {
          if (newFood.x === powerup.x && newFood.y === powerup.y) {
            validPosition = false;
            break;
          }
        }
      }
    }
    
    food = newFood;
  }
  
  function generateObstacles() {
    // Generate obstacles based on difficulty
    const obstacleCount = difficulty === 'hard' ? 1 : 2; // More obstacles in expert mode
    
    for (let i = 0; i < obstacleCount; i++) {
      let validPosition = false;
      let newObstacle = {};
      
      while (!validPosition) {
        newObstacle = {
          x: Math.floor(Math.random() * gridWidth),
          y: Math.floor(Math.random() * gridHeight)
        };
        
        validPosition = true;
        
        // Check if obstacle is on snake
        for (const segment of snake) {
          if (newObstacle.x === segment.x && newObstacle.y === segment.y) {
            validPosition = false;
            break;
          }
        }
        
        // Check if obstacle is on food
        if (validPosition && newObstacle.x === food.x && newObstacle.y === food.y) {
          validPosition = false;
        }
        
        // Check if obstacle is on other obstacles
        if (validPosition) {
          for (const obstacle of obstacles) {
            if (newObstacle.x === obstacle.x && newObstacle.y === obstacle.y) {
              validPosition = false;
              break;
            }
          }
        }
        
        // Check if obstacle is on powerup
        if (validPosition) {
          for (const powerup of powerups) {
            if (newObstacle.x === powerup.x && newObstacle.y === powerup.y) {
              validPosition = false;
              break;
            }
          }
        }
        
        // Check if obstacle is too close to snake head (preventing sudden obstacles)
        if (validPosition) {
          const headX = snake[0].x;
          const headY = snake[0].y;
          const distance = Math.abs(headX - newObstacle.x) + Math.abs(headY - newObstacle.y);
          if (distance < 5) {
            validPosition = false;
          }
        }
      }
      
      obstacles.push(newObstacle);
    }
  }
  
  function generatePowerup() {
    if (!gameRunning || gamePaused) return;
    
    // Remove old powerups
    powerups = [];
    
    // Generate a new powerup
    let validPosition = false;
    let newPowerup = {};
    
    while (!validPosition) {
      newPowerup = {
        x: Math.floor(Math.random() * gridWidth),
        y: Math.floor(Math.random() * gridHeight),
        type: Math.random() < 0.5 ? 'speed' : 'time'
      };
      
      validPosition = true;
      
      // Check if powerup is on snake
      for (const segment of snake) {
        if (newPowerup.x === segment.x && newPowerup.y === segment.y) {
          validPosition = false;
          break;
        }
      }
      
      // Check if powerup is on food
      if (validPosition && newPowerup.x === food.x && newPowerup.y === food.y) {
        validPosition = false;
      }
      
      // Check if powerup is on obstacle
      if (validPosition) {
        for (const obstacle of obstacles) {
          if (newPowerup.x === obstacle.x && newPowerup.y === obstacle.y) {
            validPosition = false;
            break;
          }
        }
      }
    }
    
    powerups.push(newPowerup);
    
    // Schedule next powerup
    setTimeout(generatePowerup, 15000 + Math.random() * 10000); // 15-25 seconds
  }
  
  function collectPowerup(type) {
    powerupSound.play();
    
    if (type === 'speed') {
      // Temporary speed boost
      const oldSpeed = speed;
      speed = Math.max(50, speed - 30);
      
      // Update game loop
      clearInterval(gameLoop);
      gameLoop = setInterval(updateGame, speed);
      
      // Show notification
      showNotification('Hız Artışı! 10 saniye boyunca daha hızlı hareket edeceksiniz!');
      
      // Reset speed after 10 seconds
      setTimeout(() => {
        if (gameRunning && !gamePaused) {
          speed = oldSpeed;
          clearInterval(gameLoop);
          gameLoop = setInterval(updateGame, speed);
          showNotification('Hız artışı sona erdi!');
        }
      }, 10000);
    } else if (type === 'time') {
      // Add time in time-attack mode
      if (gameMode === 'time-attack') {
        timeAttackTimeRemaining += 15;
        showNotification('+15 saniye eklendi!');
      } else {
        // Score bonus in other modes
        score += 50;
        scoreEl.textContent = score;
        showNotification('+50 puan kazandınız!');
      }
    }
  }
  
  function updateTimeAttack() {
    timeAttackTimeRemaining--;
    
    // Update UI if needed
    
    // Check if time is up
    if (timeAttackTimeRemaining <= 0) {
      gameOver();
    }
  }
  
  function levelUp() {
    level++;
    
    // Pause game
    clearInterval(gameLoop);
    gamePaused = true;
    
    // Update UI
    levelEl.textContent = level;
    newLevelEl.textContent = level;
    
    // Play sound
    levelUpSound.play();
    
    // Increase speed
    speed = Math.max(50, speed - 10);
    
    // Show level up modal
    levelUpModal.style.display = 'flex';
  }
  
  function drawGame() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw background
    drawEmptyBoard();
    
    // Draw obstacles
    const obstacleColor = themeColors[theme].obstacle;
    for (const obstacle of obstacles) {
      ctx.fillStyle = obstacleColor;
      ctx.fillRect(obstacle.x * gridSize, obstacle.y * gridSize, gridSize, gridSize);
    }
    
    // Draw powerups
    for (const powerup of powerups) {
      ctx.fillStyle = themeColors[theme].powerup;
      ctx.beginPath();
      ctx.arc(
        powerup.x * gridSize + gridSize / 2,
        powerup.y * gridSize + gridSize / 2,
        gridSize / 2,
        0,
        Math.PI * 2
      );
      ctx.fill();
      
      // Draw icon inside powerup
      ctx.fillStyle = '#fff';
      ctx.font = '8px Arial';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(
        powerup.type === 'speed' ? '⚡' : '⏱️',
        powerup.x * gridSize + gridSize / 2,
        powerup.y * gridSize + gridSize / 2
      );
    }
    
    // Draw snake
    for (let i = 0; i < snake.length; i++) {
      const segment = snake[i];
      
      // Different color for head
      if (i === 0) {
        ctx.fillStyle = themeColors[theme].snake.head;
      } else {
        // Gradient for body
        const colorIntensity = 1 - (i / snake.length);
        const headColor = hexToRgb(themeColors[theme].snake.head);
        const bodyColor = hexToRgb(themeColors[theme].snake.body);
        
        // Interpolate between head and body color
        const r = Math.floor(bodyColor.r + (headColor.r - bodyColor.r) * colorIntensity);
        const g = Math.floor(bodyColor.g + (headColor.g - bodyColor.g) * colorIntensity);
        const b = Math.floor(bodyColor.b + (headColor.b - bodyColor.b) * colorIntensity);
        
        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
      }
      
      // Draw rounded rectangle for segments
      drawRoundedRect(
        segment.x * gridSize,
        segment.y * gridSize,
        gridSize,
        gridSize,
        4
      );
      
      // Draw eyes on head
      if (i === 0) {
        const eyeSize = gridSize / 5;
        const eyeOffset = gridSize / 4;
        
        ctx.fillStyle = 'white';
        
        // Position eyes based on direction
        switch(direction) {
          case 'up':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + eyeOffset, segment.y * gridSize + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset, segment.y * gridSize + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'down':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + eyeOffset, segment.y * gridSize + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset, segment.y * gridSize + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'left':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + eyeOffset, segment.y * gridSize + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + eyeOffset, segment.y * gridSize + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'right':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset, segment.y * gridSize + eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset, segment.y * gridSize + gridSize - eyeOffset, eyeSize, 0, Math.PI * 2);
            ctx.fill();
            break;
        }
        
        // Draw pupils
        ctx.fillStyle = 'black';
        const pupilSize = eyeSize / 2;
        const pupilOffset = eyeSize / 4;
        
        switch(direction) {
          case 'up':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + eyeOffset, segment.y * gridSize + eyeOffset - pupilOffset, pupilSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset, segment.y * gridSize + eyeOffset - pupilOffset, pupilSize, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'down':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + eyeOffset, segment.y * gridSize + gridSize - eyeOffset + pupilOffset, pupilSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset, segment.y * gridSize + gridSize - eyeOffset + pupilOffset, pupilSize, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'left':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + eyeOffset - pupilOffset, segment.y * gridSize + eyeOffset, pupilSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + eyeOffset - pupilOffset, segment.y * gridSize + gridSize - eyeOffset, pupilSize, 0, Math.PI * 2);
            ctx.fill();
            break;
          case 'right':
            ctx.beginPath();
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset + pupilOffset, segment.y * gridSize + eyeOffset, pupilSize, 0, Math.PI * 2);
            ctx.arc(segment.x * gridSize + gridSize - eyeOffset + pupilOffset, segment.y * gridSize + gridSize - eyeOffset, pupilSize, 0, Math.PI * 2);
            ctx.fill();
            break;
        }
      }
    }
    
    // Draw food
    ctx.fillStyle = themeColors[theme].food;
    
    // Draw food as an apple
    ctx.beginPath();
    ctx.arc(
      food.x * gridSize + gridSize / 2,
      food.y * gridSize + gridSize / 2,
      gridSize / 2 - 2,
      0,
      Math.PI * 2
    );
    ctx.fill();
    
    // Draw apple stem
    ctx.fillStyle = '#5D4037';
    ctx.fillRect(
      food.x * gridSize + gridSize / 2 - 1,
      food.y * gridSize + 2,
      2,
      4
    );
    
    // Draw apple leaf
    ctx.fillStyle = '#4CAF50';
    ctx.beginPath();
    ctx.ellipse(
      food.x * gridSize + gridSize / 2 + 3,
      food.y * gridSize + 4,
      3,
      2,
      Math.PI / 4,
      0,
      Math.PI * 2
    );
    ctx.fill();
  }
  
  function drawEmptyBoard() {
    // Fill background
    ctx.fillStyle = themeColors[theme].background;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    // Draw grid pattern
    if (theme !== 'neon') { // Skip grid for neon theme
      ctx.fillStyle = themeColors[theme].grid;
      for (let y = 0; y < gridHeight; y++) {
        for (let x = 0; x < gridWidth; x++) {
          if ((x + y) % 2 === 0) {
            ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize);
          }
        }
      }
    }
  }
  
  function drawRoundedRect(x, y, width, height, radius) {
    ctx.beginPath();
    ctx.moveTo(x + radius, y);
    ctx.lineTo(x + width - radius, y);
    ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
    ctx.lineTo(x + width, y + height - radius);
    ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
    ctx.lineTo(x + radius, y + height);
    ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
    ctx.lineTo(x, y + radius);
    ctx.quadraticCurveTo(x, y, x + radius, y);
    ctx.closePath();
    ctx.fill();
  }
  
  function gameOver() {
    // Stop game loop
    clearInterval(gameLoop);
    if (timeAttackTimer) clearInterval(timeAttackTimer);
    gameRunning = false;
    
    // Play sound
    gameOverSound.play();
    
    // Update high score
    if (score > highScore) {
      highScore = score;
      highScoreEl.textContent = highScore;
      localStorage.setItem('snakeHighScore', highScore);
    }
    
    // Update game over modal
    finalScoreEl.textContent = score;
    finalLengthEl.textContent = snake.length;
    finalLevelEl.textContent = level;
    finalTimeEl.textContent = gameTimeEl.textContent;
    finalFoodEl.textContent = foodEaten;
    
    // Set game mode text
    let modeText = 'Klasik';
    if (gameMode === 'time-attack') modeText = 'Süre Yarışı';
    else if (gameMode === 'obstacles') modeText = 'Engelli';
    finalModeEl.textContent = modeText;
    
    // Save score
    saveScore(score);
    
    // Show game over modal
    gameOverModal.style.display = 'flex';
    
    // Reset button states
    pauseBtn.disabled = true;
    restartBtn.disabled = false;
  }
  
  function showNotification(message) {
    notificationMessage.textContent = message;
    notification.classList.add('show');
    
    // Auto hide after 3 seconds
    setTimeout(() => {
      notification.classList.remove('show');
    }, 3000);
  }
  
  // Helper function to convert hex to RGB
  function hexToRgb(hex) {
    // Remove the # if present
    hex = hex.replace('#', '');
    
    // Convert 3-digit hex to 6-digits
    if (hex.length === 3) {
      hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
    }
    
    // Extract RGB components
    const r = parseInt(hex.substring(0, 2), 16);
    const g = parseInt(hex.substring(2, 4), 16);
    const b = parseInt(hex.substring(4, 6), 16);
    
    return { r, g, b };
  }
  
  // Responsive canvas resizing
  function resizeCanvas() {
    const container = document.querySelector('.snake-game-area');
    const containerWidth = container.clientWidth;
    
    // Set maximum size while maintaining aspect ratio
    let canvasSize = Math.min(400, containerWidth);
    
    canvas.style.width = canvasSize + 'px';
    canvas.style.height = canvasSize + 'px';
    
    // If game is running, redraw
    if (gameRunning) {
      drawGame();
    } else {
      drawEmptyBoard();
    }
  }
  
  // Function to save score to the server
  function saveScore(score) {
    fetch('/api/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'snake',
        score: score
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log('Score saved:', data);
      if (!data.success && data.message === 'Oturum açık değil!') {
        showNotification('Skorunuzu kaydetmek için giriş yapmalısınız!');
      }
    })
    .catch(error => {
      console.error('Error saving score:', error);
    });
  }
  
  // Initial resize
  resizeCanvas();
  
  // Resize on window resize
  window.addEventListener('resize', resizeCanvas);
});
</script>
{% endblock %}
