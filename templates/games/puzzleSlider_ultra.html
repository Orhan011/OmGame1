{% extends 'layout.html' %}

{% block title %}Puzzle Slider - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>Puzzle Slider <span class="badge">Görsel Bulmaca</span></h1>
      <p class="game-description">Görsel dikkat ve mekansal becerileri geliştiren kare bulmaca oyunu.</p>
    </div>

    <div class="puzzle-slider-container">
      <div class="puzzle-header">
        <div class="puzzle-stats">
          <div class="stat-item">
            <div class="stat-label">Hamleler</div>
            <div class="stat-value" id="moves">0</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">Süre</div>
            <div class="stat-value" id="timer">00:00</div>
          </div>
          <div class="stat-item">
            <div class="stat-label">Seviye</div>
            <div class="stat-value" id="level">1</div>
          </div>
        </div>
      </div>

      <div class="puzzle-layout">
        <div class="puzzle-board-container">
          <div id="puzzle-board" class="puzzle-board size-3"></div>
          
          <div class="puzzle-overlay" id="start-overlay">
            <div class="overlay-content">
              <h2>Puzzle Slider'a Hoş Geldiniz!</h2>
              <p>Kareleri sürükleyerek doğru sırada yerleştirmeye çalışın.</p>
              
              <div class="puzzle-options">
                <div class="option-section">
                  <h3>Zorluk Seviyesi</h3>
                  <div class="button-group">
                    <button class="difficulty-btn active" data-size="3">3×3</button>
                    <button class="difficulty-btn" data-size="4">4×4</button>
                    <button class="difficulty-btn" data-size="5">5×5</button>
                  </div>
                </div>
                
                <div class="option-section">
                  <h3>Puzzle Teması</h3>
                  <div class="button-group themes">
                    <button class="theme-btn active" data-theme="default">
                      <span class="theme-color theme-default"></span>
                      <span>Klasik</span>
                    </button>
                    <button class="theme-btn" data-theme="gradient">
                      <span class="theme-color theme-gradient"></span>
                      <span>Gradyan</span>
                    </button>
                    <button class="theme-btn" data-theme="neon">
                      <span class="theme-color theme-neon"></span>
                      <span>Neon</span>
                    </button>
                    <button class="theme-btn" data-theme="dark">
                      <span class="theme-color theme-dark"></span>
                      <span>Karanlık</span>
                    </button>
                  </div>
                </div>
                
                <div class="option-section">
                  <h3>Görsel Modu</h3>
                  <div class="button-group modes">
                    <button class="mode-btn active" data-mode="numbers">
                      <i class="fas fa-sort-numeric-up mode-icon"></i>
                      <span>Sayılar</span>
                    </button>
                    <button class="mode-btn" data-mode="image">
                      <i class="fas fa-image mode-icon"></i>
                      <span>Görsel</span>
                    </button>
                  </div>
                </div>
              </div>
              
              <button id="start-btn" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Oyuna Başla
              </button>
            </div>
          </div>
        </div>
        
        <div class="puzzle-sidebar">
          <div class="puzzle-controls">
            <button id="shuffle-btn" class="btn btn-primary">
              <i class="fas fa-random me-2"></i>Karıştır
            </button>
            <button id="restart-btn" class="btn btn-outline-warning">
              <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
            </button>
            <button id="hint-btn" class="btn btn-outline-info">
              <i class="fas fa-lightbulb me-2"></i>İpucu
            </button>
            <a href="{{ url_for('all_games') }}" class="btn btn-outline-secondary">
              <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
            </a>
          </div>
          
          <div class="game-instructions">
            <h4 class="instruction-title"><i class="fas fa-info-circle me-2"></i>Nasıl Oynanır?</h4>
            <ul class="instruction-list">
              <li><i class="fas fa-check-circle instruction-icon"></i>Kareleri doğru sırada yerleştirmeye çalışın.</li>
              <li><i class="fas fa-check-circle instruction-icon"></i>Boş kareye komşu olan bir kareye tıklayarak hareket ettirebilirsiniz.</li>
              <li><i class="fas fa-check-circle instruction-icon"></i>Tüm kareleri 1'den başlayarak sırayla dizin.</li>
              <li><i class="fas fa-check-circle instruction-icon"></i>Son kare boş kalmalıdır.</li>
              <li><i class="fas fa-check-circle instruction-icon"></i>Zorluk seviyesini değiştirerek oyunu daha zor hale getirebilirsiniz.</li>
              <li><i class="fas fa-check-circle instruction-icon"></i>İpucu butonu ile bir sonraki hamlenin önerisini alabilirsiniz.</li>
            </ul>
          </div>
          
          <div class="puzzle-stats-panel">
            <h4 class="stats-title"><i class="fas fa-chart-line me-2"></i>İstatistikler</h4>
            <div class="stats-list">
              <div class="stat-row">
                <span class="stat-name">Toplam Oyunlar:</span>
                <span class="stat-value" id="total-games">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-name">En İyi Skor:</span>
                <span class="stat-value" id="best-score">0</span>
              </div>
              <div class="stat-row">
                <span class="stat-name">En Hızlı Çözüm:</span>
                <span class="stat-value" id="best-time">00:00</span>
              </div>
            </div>
          </div>
        </div>
      </div>

      <div id="success-modal" class="puzzle-success-modal">
        <div class="success-content">
          <h2><i class="fas fa-trophy me-2"></i>Tebrikler!</h2>
          <p>Puzzle'ı başarıyla tamamladınız!</p>
          
          <div class="success-stats">
            <div class="success-stat">
              <div class="success-stat-value" id="final-moves">0</div>
              <div class="success-stat-label">Toplam Hamle</div>
            </div>
            <div class="success-stat">
              <div class="success-stat-value" id="final-time">00:00</div>
              <div class="success-stat-label">Geçen Süre</div>
            </div>
            <div class="success-stat">
              <div class="success-stat-value" id="final-level">1</div>
              <div class="success-stat-label">Seviye</div>
            </div>
          </div>
          
          <div id="level-up-message" class="level-up-message" style="display: none;">
            <i class="fas fa-arrow-up me-2"></i>Bir sonraki seviyeye geçtiniz!
          </div>
          
          <div class="success-actions">
            <button id="next-level-btn" class="btn btn-success btn-lg">
              <i class="fas fa-level-up-alt me-2"></i>Sonraki Seviye
            </button>
            <button id="play-again-btn" class="btn btn-primary btn-lg">
              <i class="fas fa-redo-alt me-2"></i>Tekrar Oyna
            </button>
            <a href="{{ url_for('all_games') }}" class="btn btn-outline-light btn-lg">
              <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
            </a>
          </div>
        </div>
      </div>
      
      <div id="notification" class="game-notification">
        <div class="notification-content">
          <p id="notification-message"></p>
          <button id="close-notification" class="btn-close"><i class="fas fa-times"></i></button>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .puzzle-slider-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 10px;
  }
  
  .puzzle-layout {
    display: flex;
    flex-wrap: wrap;
    gap: 25px;
    justify-content: center;
    align-items: flex-start;
    margin-bottom: 20px;
  }

  .puzzle-header {
    margin-bottom: 25px;
  }

  .puzzle-stats {
    display: flex;
    background: rgba(25, 25, 45, 0.8);
    border-radius: 16px;
    overflow: hidden;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }

  .stat-item {
    padding: 15px 20px;
    text-align: center;
    border-right: 1px solid rgba(255, 255, 255, 0.05);
    flex: 1;
    transition: all 0.3s ease;
  }
  
  .stat-item:hover {
    background: rgba(30, 30, 60, 0.5);
  }

  .stat-item:last-child {
    border-right: none;
  }

  .stat-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 5px;
  }

  .stat-value {
    font-size: 1.6rem;
    font-weight: 700;
    color: var(--accent-color);
    text-shadow: 0 0 10px rgba(106, 90, 224, 0.3);
  }
  
  .stat-value.pulse {
    animation: pulse-animation 0.5s;
  }
  
  @keyframes pulse-animation {
    0% { transform: scale(1); }
    50% { transform: scale(1.2); }
    100% { transform: scale(1); }
  }

  .puzzle-board-container {
    flex: 1;
    min-width: 300px;
    max-width: 500px;
    display: flex;
    justify-content: center;
    position: relative;
  }
  
  .puzzle-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(25, 25, 45, 0.95);
    border-radius: 16px;
    display: flex;
    justify-content: center;
    align-items: center;
    z-index: 10;
    backdrop-filter: blur(5px);
  }
  
  .overlay-content {
    max-width: 90%;
    width: 100%;
    padding: 30px;
    text-align: center;
    animation: fadeIn 0.5s ease;
  }
  
  .overlay-content h2 {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(90deg, #6a5ae0, #a890ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }
  
  .overlay-content p {
    color: rgba(255, 255, 255, 0.9);
    margin-bottom: 25px;
    font-size: 1.1rem;
  }
  
  .puzzle-options {
    margin-bottom: 25px;
  }
  
  .option-section {
    background: rgba(35, 35, 65, 0.6);
    border-radius: 12px;
    padding: 20px;
    margin-bottom: 15px;
    text-align: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
    border: 1px solid rgba(255, 255, 255, 0.05);
    transition: all 0.3s ease;
  }
  
  .option-section:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    border-color: rgba(106, 90, 224, 0.15);
  }
  
  .option-section h3 {
    color: white;
    font-size: 1.2rem;
    margin-bottom: 15px;
    font-weight: 600;
    position: relative;
    display: inline-block;
    padding-bottom: 8px;
  }
  
  .option-section h3:after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background: var(--accent-color);
    border-radius: 2px;
  }
  
  .button-group {
    display: flex;
    gap: 10px;
    justify-content: center;
    flex-wrap: wrap;
  }
  
  .difficulty-btn, .theme-btn, .mode-btn {
    flex: 1;
    padding: 10px 15px;
    background: rgba(40, 40, 80, 0.6);
    border: 1px solid rgba(255, 255, 255, 0.05);
    border-radius: 10px;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 500;
    min-width: 80px;
  }
  
  .difficulty-btn:hover, .theme-btn:hover, .mode-btn:hover {
    background: rgba(60, 60, 100, 0.6);
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  }
  
  .difficulty-btn.active, .theme-btn.active, .mode-btn.active {
    background: rgba(106, 90, 224, 0.5);
    border-color: rgba(106, 90, 224, 0.8);
    box-shadow: 0 5px 15px rgba(106, 90, 224, 0.3);
  }
  
  .themes {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(100px, 1fr));
    gap: 10px;
  }
  
  .theme-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 12px 10px;
  }
  
  .theme-color {
    width: 20px;
    height: 20px;
    border-radius: 50%;
    border: 2px solid rgba(255, 255, 255, 0.2);
  }
  
  .theme-default {
    background: linear-gradient(135deg, #6a5ae0, #a890ff);
  }
  
  .theme-gradient {
    background: linear-gradient(135deg, #FF416C, #FF4B2B);
  }
  
  .theme-neon {
    background: linear-gradient(135deg, #00ffcc, #33ccff);
  }
  
  .theme-dark {
    background: linear-gradient(135deg, #333333, #666666);
  }
  
  .modes {
    display: flex;
    justify-content: center;
    gap: 15px;
  }
  
  .mode-btn {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 8px;
    padding: 12px 15px;
  }
  
  .mode-icon {
    font-size: 1.5rem;
    color: var(--accent-color);
    margin-bottom: 5px;
    transition: all 0.3s ease;
  }
  
  .mode-btn:hover .mode-icon {
    transform: scale(1.2);
  }
  
  #start-btn {
    font-size: 1.1rem;
    font-weight: 600;
    border-radius: 30px;
    background: linear-gradient(90deg, #6a5ae0, #a890ff);
    border: none;
    box-shadow: 0 5px 15px rgba(106, 90, 224, 0.4);
    transition: all 0.3s ease;
    padding: 12px 30px;
  }
  
  #start-btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 20px rgba(106, 90, 224, 0.6);
  }

  .puzzle-board {
    display: grid;
    gap: 8px;
    background: rgba(25, 25, 45, 0.8);
    padding: 15px;
    border-radius: 16px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
    border: 1px solid rgba(255, 255, 255, 0.05);
    aspect-ratio: 1/1;
    width: 100%;
    max-width: 450px;
  }
  
  .puzzle-board:hover {
    box-shadow: 0 20px 45px rgba(0, 0, 0, 0.35);
    border-color: rgba(106, 90, 224, 0.2);
  }

  .size-3 {
    grid-template-columns: repeat(3, 1fr);
    grid-template-rows: repeat(3, 1fr);
  }

  .size-4 {
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(4, 1fr);
  }

  .size-5 {
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(5, 1fr);
  }

  .puzzle-tile {
    aspect-ratio: 1/1;
    background: rgba(106, 90, 224, 0.8);
    border-radius: 12px;
    display: flex;
    justify-content: center;
    align-items: center;
    font-size: 1.8rem;
    font-weight: 700;
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    box-shadow: 0 8px 15px rgba(0, 0, 0, 0.2);
    user-select: none;
    position: relative;
    overflow: hidden;
    border: 2px solid rgba(255, 255, 255, 0.1);
  }
  
  .puzzle-tile:before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 50%;
    background: rgba(255, 255, 255, 0.1);
    border-radius: 10px 10px 0 0;
  }

  .puzzle-tile:hover {
    transform: translateY(-5px);
    box-shadow: 0 12px 20px rgba(0, 0, 0, 0.25);
  }
  
  .puzzle-tile.slide {
    animation: slide-animation 0.2s ease;
  }
  
  @keyframes slide-animation {
    0% { transform: scale(0.9); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }

  .puzzle-tile.empty {
    background: transparent;
    box-shadow: none;
    cursor: default;
    border-color: transparent;
  }

  .puzzle-tile.empty:hover {
    transform: none;
  }
  
  .puzzle-tile.highlight {
    animation: highlight-pulse 1.5s infinite;
    border-color: rgba(106, 90, 224, 0.8);
    box-shadow: 0 0 20px rgba(106, 90, 224, 0.5);
    z-index: 5;
  }
  
  @keyframes highlight-pulse {
    0% {
      box-shadow: 0 0 5px rgba(106, 90, 224, 0.5);
    }
    50% {
      box-shadow: 0 0 20px rgba(106, 90, 224, 0.8);
    }
    100% {
      box-shadow: 0 0 5px rgba(106, 90, 224, 0.5);
    }
  }
  
  .puzzle-tile.correct-position {
    border: 2px solid #4CAF50;
  }
  
  /* Theme styles */
  .puzzle-tile.theme-default {
    background: linear-gradient(135deg, #6a5ae0, #7a6aff);
  }
  
  .puzzle-tile.theme-gradient {
    background: linear-gradient(135deg, #FF416C, #FF4B2B);
  }
  
  .puzzle-tile.theme-neon {
    background: #111;
    color: #0ff;
    text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
    border: 2px solid #0ff;
    box-shadow: 0 0 10px #0ff, inset 0 0 5px #0ff;
  }
  
  .puzzle-tile.theme-dark {
    background: #121212;
    color: #e0e0e0;
    border: 1px solid #333;
  }
  
  /* Image mode styles */
  .puzzle-tile.image-mode {
    background-size: 300% 300%;
    background-repeat: no-repeat;
    color: transparent;
    font-size: 0;
  }
  
  .size-3 .puzzle-tile.image-mode {
    background-size: 300% 300%;
  }
  
  .size-4 .puzzle-tile.image-mode {
    background-size: 400% 400%;
  }
  
  .size-5 .puzzle-tile.image-mode {
    background-size: 500% 500%;
  }

  .puzzle-sidebar {
    width: 300px;
    display: flex;
    flex-direction: column;
    gap: 20px;
  }
  
  .puzzle-controls {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .puzzle-controls button,
  .puzzle-controls a {
    width: 100%;
    border-radius: 10px;
    font-weight: 500;
    transition: all 0.3s ease;
    padding: 10px 15px;
    font-size: 1rem;
  }
  
  .puzzle-controls button:hover,
  .puzzle-controls a:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  }

  .game-instructions, .puzzle-stats-panel {
    background: rgba(25, 25, 45, 0.8);
    border-radius: 16px;
    padding: 20px;
    box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(255, 255, 255, 0.05);
    transition: all 0.3s ease;
  }
  
  .game-instructions:hover, .puzzle-stats-panel:hover {
    transform: translateY(-5px);
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.25);
    border-color: rgba(106, 90, 224, 0.15);
  }

  .instruction-title, .stats-title {
    color: var(--accent-color);
    font-size: 1.2rem;
    margin-bottom: 20px;
    font-weight: 600;
    position: relative;
    display: inline-block;
    padding-bottom: 8px;
  }
  
  .instruction-title:after, .stats-title:after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background: var(--accent-color);
    border-radius: 2px;
  }

  .instruction-list {
    list-style-type: none;
    padding: 0;
    margin: 0;
  }

  .instruction-list li {
    display: flex;
    align-items: flex-start;
    margin-bottom: 12px;
    color: rgba(255, 255, 255, 0.8);
    font-size: 0.95rem;
    line-height: 1.4;
  }
  
  .instruction-list li:last-child {
    margin-bottom: 0;
  }
  
  .instruction-icon {
    color: var(--accent-color);
    margin-right: 10px;
    margin-top: 3px;
    font-size: 0.9rem;
    flex-shrink: 0;
  }
  
  .stats-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .stat-row {
    display: flex;
    justify-content: space-between;
    padding-bottom: 10px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .stat-row:last-child {
    border-bottom: none;
    padding-bottom: 0;
  }
  
  .stat-name {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.95rem;
  }
  
  .stat-value {
    color: white;
    font-weight: 600;
    font-size: 0.95rem;
  }

  /* Success Modal */
  .puzzle-success-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.8);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(5px);
  }

  .success-content {
    background: rgba(25, 25, 45, 0.95);
    border-radius: 16px;
    padding: 30px;
    text-align: center;
    max-width: 90%;
    width: 400px;
    box-shadow: 0 20px 40px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(255, 255, 255, 0.05);
    animation: modalFadeIn 0.5s;
  }

  .success-content h2 {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 2rem;
    font-weight: 700;
    background: linear-gradient(90deg, #6a5ae0, #a890ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .success-content p {
    color: white;
    margin-bottom: 25px;
    font-size: 1.1rem;
  }

  .success-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 25px;
  }

  .success-stat {
    text-align: center;
  }

  .success-stat-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--accent-color);
    margin-bottom: 8px;
    text-shadow: 0 0 15px rgba(106, 90, 224, 0.3);
    background: linear-gradient(90deg, #6a5ae0, #a890ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .success-stat-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
  }
  
  .level-up-message {
    background: rgba(76, 175, 80, 0.2);
    color: #4CAF50;
    padding: 10px;
    border-radius: 8px;
    margin-bottom: 20px;
    font-weight: 600;
    font-size: 1.1rem;
    display: flex;
    align-items: center;
    justify-content: center;
  }

  .success-actions {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }
  
  .success-actions button,
  .success-actions a {
    border-radius: 30px;
    font-weight: 500;
    transition: all 0.3s ease;
    padding: 10px 20px;
  }
  
  .success-actions button:hover,
  .success-actions a:hover {
    transform: translateY(-3px);
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
  }
  
  #next-level-btn {
    background: linear-gradient(90deg, #00b894, #00cec9);
    border: none;
    box-shadow: 0 5px 15px rgba(0, 184, 148, 0.3);
  }
  
  #next-level-btn:hover {
    box-shadow: 0 8px 20px rgba(0, 184, 148, 0.5);
  }
  
  .game-notification {
    position: fixed;
    bottom: 20px;
    right: 20px;
    background: rgba(25, 25, 45, 0.9);
    border-radius: 12px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.3);
    z-index: 1000;
    max-width: 300px;
    transform: translateY(100px);
    opacity: 0;
    transition: all 0.3s ease;
    pointer-events: none;
    backdrop-filter: blur(5px);
    border: 1px solid rgba(255, 255, 255, 0.05);
  }
  
  .game-notification.show {
    transform: translateY(0);
    opacity: 1;
    pointer-events: all;
  }
  
  .notification-content {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .notification-content p {
    margin: 0;
    color: white;
    font-size: 0.95rem;
  }
  
  .btn-close {
    background: transparent;
    border: none;
    color: rgba(255, 255, 255, 0.7);
    cursor: pointer;
    font-size: 1rem;
    padding: 0;
    margin-left: 10px;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes modalFadeIn {
    from {
      opacity: 0;
      transform: translateY(-20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }
  
  /* Confetti effect */
  .confetti {
    position: absolute;
    width: 10px;
    height: 10px;
    background-color: var(--accent-color);
    border-radius: 50%;
    opacity: 0.8;
    pointer-events: none;
    z-index: 1000;
  }
  
  /* Responsive adaptations */
  @media (max-width: 992px) {
    .puzzle-layout {
      flex-direction: column;
      align-items: center;
    }
    
    .puzzle-sidebar {
      width: 100%;
      max-width: 500px;
    }
  }
  
  @media (max-width: 768px) {
    .puzzle-header {
      flex-direction: column;
      align-items: stretch;
    }

    .puzzle-stats {
      width: 100%;
    }
    
    .overlay-content {
      padding: 20px;
    }
    
    .overlay-content h2 {
      font-size: 1.8rem;
    }
    
    .option-section {
      padding: 15px;
    }
    
    .puzzle-tile {
      font-size: 1.5rem;
    }
    
    .success-content {
      padding: 20px;
    }
    
    .success-stat-value {
      font-size: 2rem;
    }
  }

  @media (max-width: 480px) {
    .puzzle-tile {
      font-size: 1.2rem;
    }

    .size-5 .puzzle-tile {
      font-size: 1rem;
    }
    
    .stat-item {
      padding: 10px;
    }
    
    .stat-value {
      font-size: 1.4rem;
    }
    
    .themes {
      grid-template-columns: repeat(2, 1fr);
    }
    
    .mode-icon {
      font-size: 1.3rem;
    }
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const puzzleBoard = document.getElementById('puzzle-board');
  const startOverlay = document.getElementById('start-overlay');
  const difficultyBtns = document.querySelectorAll('.difficulty-btn');
  const themeBtns = document.querySelectorAll('.theme-btn');
  const modeBtns = document.querySelectorAll('.mode-btn');
  const startBtn = document.getElementById('start-btn');
  const shuffleBtn = document.getElementById('shuffle-btn');
  const restartBtn = document.getElementById('restart-btn');
  const hintBtn = document.getElementById('hint-btn');
  const movesDisplay = document.getElementById('moves');
  const timerDisplay = document.getElementById('timer');
  const levelDisplay = document.getElementById('level');
  const totalGamesDisplay = document.getElementById('total-games');
  const bestScoreDisplay = document.getElementById('best-score');
  const bestTimeDisplay = document.getElementById('best-time');
  const successModal = document.getElementById('success-modal');
  const finalMovesDisplay = document.getElementById('final-moves');
  const finalTimeDisplay = document.getElementById('final-time');
  const finalLevelDisplay = document.getElementById('final-level');
  const levelUpMessage = document.getElementById('level-up-message');
  const playAgainBtn = document.getElementById('play-again-btn');
  const nextLevelBtn = document.getElementById('next-level-btn');
  const notification = document.getElementById('notification');
  const notificationMessage = document.getElementById('notification-message');
  const closeNotification = document.getElementById('close-notification');

  // Game settings
  let gameSettings = {
    size: 3,
    theme: 'default',
    mode: 'numbers',
    imageUrl: '/static/images/puzzle.jpg'
  };

  // Game state
  let tiles = [];
  let emptyTileIndex = 8; // For 3x3 grid, the last tile (index 8) is empty
  let moves = 0;
  let level = 1;
  let timerInterval = null;
  let seconds = 0;
  let gameStarted = false;
  let gameCompleted = false;
  
  // Statistics
  let totalGames = localStorage.getItem('puzzleSlider_totalGames') || 0;
  let bestScore = localStorage.getItem('puzzleSlider_bestScore') || 0;
  let bestTime = localStorage.getItem('puzzleSlider_bestTime') || 0;
  
  // Update statistics display
  totalGamesDisplay.textContent = totalGames;
  bestScoreDisplay.textContent = bestScore || 'N/A';
  bestTimeDisplay.textContent = bestTime ? formatTime(bestTime) : 'N/A';

  // Event listeners
  startBtn.addEventListener('click', startGame);
  shuffleBtn.addEventListener('click', shuffleTiles);
  restartBtn.addEventListener('click', resetGame);
  hintBtn.addEventListener('click', showHint);
  playAgainBtn.addEventListener('click', resetGame);
  nextLevelBtn.addEventListener('click', goToNextLevel);
  closeNotification.addEventListener('click', hideNotification);

  // Set up difficulty buttons
  difficultyBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const newSize = parseInt(this.getAttribute('data-size'));
      if (newSize !== gameSettings.size) {
        difficultyBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        gameSettings.size = newSize;
      }
    });
  });

  // Set up theme buttons
  themeBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const newTheme = this.getAttribute('data-theme');
      if (newTheme !== gameSettings.theme) {
        themeBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        gameSettings.theme = newTheme;
      }
    });
  });

  // Set up mode buttons
  modeBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const newMode = this.getAttribute('data-mode');
      if (newMode !== gameSettings.mode) {
        modeBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        gameSettings.mode = newMode;
      }
    });
  });

  // Start game
  function startGame() {
    // Hide start overlay
    startOverlay.style.display = 'none';
    
    // Reset game state
    resetGameState();
    
    // Update board class based on size
    puzzleBoard.className = `puzzle-board size-${gameSettings.size}`;
    
    // Create and shuffle tiles
    createTiles();
    shuffleTiles();
    
    // Start timer
    startTimer();
    
    // Mark game as started
    gameStarted = true;
  }

  // Create tiles based on current size
  function createTiles() {
    // Clear existing tiles
    puzzleBoard.innerHTML = '';
    
    // Calculate total tiles
    const totalTiles = gameSettings.size * gameSettings.size;
    
    // Update empty tile index (last tile)
    emptyTileIndex = totalTiles - 1;
    
    // Create new tiles
    for (let i = 0; i < totalTiles; i++) {
      const tile = document.createElement('div');
      
      // Check if this is the empty tile
      if (i === emptyTileIndex) {
        tile.className = 'puzzle-tile empty';
      } else {
        tile.className = 'puzzle-tile';
        
        // Add theme class
        tile.classList.add(`theme-${gameSettings.theme}`);
        
        // Add number or image based on mode
        if (gameSettings.mode === 'numbers') {
          tile.textContent = i + 1;
        } else if (gameSettings.mode === 'image') {
          tile.classList.add('image-mode');
          
          // Calculate background position
          const row = Math.floor(i / gameSettings.size);
          const col = i % gameSettings.size;
          
          // Set background position (using percentage)
          const bgPosX = (col * 100 / (gameSettings.size - 1)) + '%';
          const bgPosY = (row * 100 / (gameSettings.size - 1)) + '%';
          
          tile.style.backgroundImage = `url(${gameSettings.imageUrl})`;
          tile.style.backgroundPosition = `${bgPosX} ${bgPosY}`;
        }
      }
      
      // Store original index for checking solution
      tile.dataset.index = i;
      
      // Add click event listener
      tile.addEventListener('click', () => moveTile(i));
      
      // Add tile to board
      puzzleBoard.appendChild(tile);
      
      // Add to tiles array
      tiles.push(i);
    }
  }

  // Shuffle tiles randomly
  function shuffleTiles() {
    // If game not started yet, don't update moves
    if (gameStarted) {
      moves = 0;
      movesDisplay.textContent = '0';
      seconds = 0;
      updateTimer();
      startTimer();
      showNotification('Kareler yeniden karıştırıldı!');
    }
    
    // Reset game completion status
    gameCompleted = false;
    
    // Get all tiles
    const tileElements = puzzleBoard.querySelectorAll('.puzzle-tile');
    
    // Create a solvable puzzle (odd number of inversions)
    do {
      // Reset tiles array
      tiles = Array.from({ length: gameSettings.size * gameSettings.size }, (_, i) => i);
      
      // Shuffle tiles
      for (let i = tiles.length - 2; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [tiles[i], tiles[j]] = [tiles[j], tiles[i]];
      }
      
      // Keep empty tile at the end
      const emptyIndex = tiles.indexOf(emptyTileIndex);
      tiles[emptyIndex] = tiles[tiles.length - 1];
      tiles[tiles.length - 1] = emptyTileIndex;
    } while (!isSolvable(tiles));
    
    // Update UI
    updateTilesUI();
  }

  // Check if puzzle is solvable (needs odd number of inversions)
  function isSolvable(tiles) {
    let inversions = 0;
    
    // Count inversions
    for (let i = 0; i < tiles.length - 1; i++) {
      // Skip empty tile
      if (tiles[i] === emptyTileIndex) continue;
      
      for (let j = i + 1; j < tiles.length; j++) {
        // Skip empty tile
        if (tiles[j] === emptyTileIndex) continue;
        
        // Count inversion if pair is inverted
        if (tiles[i] > tiles[j]) {
          inversions++;
        }
      }
    }
    
    // For odd-sized grids, the puzzle is solvable if inversions is even
    if (gameSettings.size % 2 === 1) {
      return inversions % 2 === 0;
    } 
    // For even-sized grids, solvability depends on empty tile position
    else {
      const emptyRow = Math.floor(tiles.indexOf(emptyTileIndex) / gameSettings.size);
      return (inversions + emptyRow) % 2 === 1;
    }
  }

  // Update tiles UI based on current tiles array
  function updateTilesUI() {
    const tileElements = puzzleBoard.querySelectorAll('.puzzle-tile');
    
    // Update each tile position
    tiles.forEach((tileValue, position) => {
      const tile = Array.from(tileElements).find(el => parseInt(el.dataset.index) === tileValue);
      
      if (tile) {
        // Move tile to its new position
        puzzleBoard.appendChild(tile);
        
        // Check if tile is in correct position
        if (tileValue === position && tileValue !== emptyTileIndex) {
          tile.classList.add('correct-position');
        } else {
          tile.classList.remove('correct-position');
        }
      }
    });
  }

  // Move tile when clicked
  function moveTile(index) {
    // If game not started or completed, ignore clicks
    if (!gameStarted || gameCompleted) return;
    
    // Find current position of the clicked tile
    const currentIndex = tiles.indexOf(index);
    
    // Find current position of empty tile
    const emptyIndex = tiles.indexOf(emptyTileIndex);
    
    // Calculate row and column of clicked tile and empty tile
    const currentRow = Math.floor(currentIndex / gameSettings.size);
    const currentCol = currentIndex % gameSettings.size;
    const emptyRow = Math.floor(emptyIndex / gameSettings.size);
    const emptyCol = emptyIndex % gameSettings.size;
    
    // Check if move is valid (adjacent to empty tile)
    const isAdjacent = (
      (currentRow === emptyRow && Math.abs(currentCol - emptyCol) === 1) ||
      (currentCol === emptyCol && Math.abs(currentRow - emptyRow) === 1)
    );
    
    if (isAdjacent) {
      // Swap tiles
      [tiles[currentIndex], tiles[emptyIndex]] = [tiles[emptyIndex], tiles[currentIndex]];
      
      // Update moves counter
      moves++;
      movesDisplay.textContent = moves;
      
      // Add pulse animation
      movesDisplay.classList.add('pulse');
      setTimeout(() => movesDisplay.classList.remove('pulse'), 500);
      
      // Add slide animation
      const clickedTileEl = puzzleBoard.querySelectorAll('.puzzle-tile')[currentIndex];
      clickedTileEl.classList.add('slide');
      setTimeout(() => clickedTileEl.classList.remove('slide'), 200);
      
      // Update UI
      updateTilesUI();
      
      // Check if puzzle is solved
      checkPuzzleSolved();
    }
  }

  // Check if puzzle is solved
  function checkPuzzleSolved() {
    // Puzzle is solved if each tile is at its correct position
    const solved = tiles.every((tileValue, position) => {
      return tileValue === position;
    });
    
    if (solved) {
      completePuzzle();
    }
  }

  // Complete puzzle
  function completePuzzle() {
    // Stop timer
    clearInterval(timerInterval);
    
    // Mark game as completed
    gameCompleted = true;
    
    // Update total games
    totalGames++;
    localStorage.setItem('puzzleSlider_totalGames', totalGames);
    totalGamesDisplay.textContent = totalGames;
    
    // Update best score
    if (!bestScore || moves < bestScore) {
      bestScore = moves;
      localStorage.setItem('puzzleSlider_bestScore', bestScore);
      bestScoreDisplay.textContent = bestScore;
    }
    
    // Update best time
    if (!bestTime || seconds < bestTime) {
      bestTime = seconds;
      localStorage.setItem('puzzleSlider_bestTime', bestTime);
      bestTimeDisplay.textContent = formatTime(bestTime);
    }
    
    // Update final stats
    finalMovesDisplay.textContent = moves;
    finalTimeDisplay.textContent = formatTime(seconds);
    finalLevelDisplay.textContent = level;
    
    // Show level up message if appropriate
    if (level < 5) {
      levelUpMessage.style.display = 'block';
    } else {
      levelUpMessage.style.display = 'none';
    }
    
    // Create confetti effect
    createConfettiEffect();
    
    // Show success modal
    successModal.style.display = 'flex';
  }

  // Go to next level
  function goToNextLevel() {
    // Increase level
    level++;
    levelDisplay.textContent = level;
    
    // Increase difficulty if possible
    if (level % 2 === 0 && gameSettings.size < 5) {
      gameSettings.size++;
      
      // Update active difficulty button
      difficultyBtns.forEach(btn => {
        if (parseInt(btn.getAttribute('data-size')) === gameSettings.size) {
          btn.classList.add('active');
        } else {
          btn.classList.remove('active');
        }
      });
      
      // Update board class
      puzzleBoard.className = `puzzle-board size-${gameSettings.size}`;
    }
    
    // Hide success modal
    successModal.style.display = 'none';
    
    // Reset game state
    resetGameState();
    
    // Create and shuffle tiles
    createTiles();
    shuffleTiles();
    
    // Start timer
    startTimer();
    
    // Show notification
    showNotification(`Seviye ${level}'e geçtiniz!`);
  }

  // Show hint
  function showHint() {
    // If game not started or completed, ignore
    if (!gameStarted || gameCompleted) return;
    
    // Find current position of empty tile
    const emptyIndex = tiles.indexOf(emptyTileIndex);
    
    // Find correct tile for empty position
    const correctTileValue = emptyIndex;
    
    // Find current position of correct tile
    const correctTileIndex = tiles.indexOf(correctTileValue);
    
    // Calculate if correct tile can be moved
    const correctRow = Math.floor(correctTileIndex / gameSettings.size);
    const correctCol = correctTileIndex % gameSettings.size;
    const emptyRow = Math.floor(emptyIndex / gameSettings.size);
    const emptyCol = emptyIndex % gameSettings.size;
    
    // Check if correct tile is adjacent to empty tile
    const isAdjacent = (
      (correctRow === emptyRow && Math.abs(correctCol - emptyCol) === 1) ||
      (correctCol === emptyCol && Math.abs(correctRow - emptyRow) === 1)
    );
    
    if (isAdjacent) {
      // Highlight the correct tile
      const correctTileEl = Array.from(puzzleBoard.querySelectorAll('.puzzle-tile'))
        .find(el => parseInt(el.dataset.index) === correctTileValue);
      
      if (correctTileEl) {
        // Add highlight effect
        correctTileEl.classList.add('highlight');
        
        // Remove highlight after 2 seconds
        setTimeout(() => {
          correctTileEl.classList.remove('highlight');
        }, 2000);
        
        // Show notification
        showNotification('İpucu: Vurgulanan kareyi boş alana taşıyın.');
      }
    } else {
      // Find any valid move
      const validMoves = getValidMoves();
      
      if (validMoves.length > 0) {
        // Choose a random valid move
        const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
        
        // Highlight the suggested tile
        const suggestedTileEl = Array.from(puzzleBoard.querySelectorAll('.puzzle-tile'))
          .find(el => parseInt(el.dataset.index) === randomMove);
        
        if (suggestedTileEl) {
          // Add highlight effect
          suggestedTileEl.classList.add('highlight');
          
          // Remove highlight after 2 seconds
          setTimeout(() => {
            suggestedTileEl.classList.remove('highlight');
          }, 2000);
          
          // Show notification
          showNotification('İpucu: Vurgulanan kareyi boş alana taşıyın.');
        }
      }
    }
  }

  // Get valid moves (tiles adjacent to empty tile)
  function getValidMoves() {
    // Find current position of empty tile
    const emptyIndex = tiles.indexOf(emptyTileIndex);
    
    // Calculate row and column of empty tile
    const emptyRow = Math.floor(emptyIndex / gameSettings.size);
    const emptyCol = emptyIndex % gameSettings.size;
    
    // Find adjacent tile positions
    const adjacent = [
      // Up
      emptyRow > 0 ? emptyIndex - gameSettings.size : -1,
      // Down
      emptyRow < gameSettings.size - 1 ? emptyIndex + gameSettings.size : -1,
      // Left
      emptyCol > 0 ? emptyIndex - 1 : -1,
      // Right
      emptyCol < gameSettings.size - 1 ? emptyIndex + 1 : -1
    ].filter(pos => pos !== -1);
    
    // Return tile values at those positions
    return adjacent.map(pos => tiles[pos]);
  }

  // Start timer
  function startTimer() {
    // Clear any existing timer
    if (timerInterval) {
      clearInterval(timerInterval);
    }
    
    // Reset seconds
    seconds = 0;
    
    // Update timer display
    updateTimer();
    
    // Start new timer
    timerInterval = setInterval(() => {
      seconds++;
      updateTimer();
    }, 1000);
  }

  // Update timer display
  function updateTimer() {
    timerDisplay.textContent = formatTime(seconds);
  }

  // Format time as MM:SS
  function formatTime(totalSeconds) {
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
  }

  // Reset game state
  function resetGameState() {
    // Reset moves
    moves = 0;
    movesDisplay.textContent = '0';
    
    // Reset timer
    seconds = 0;
    updateTimer();
    
    // Reset tiles array
    tiles = Array.from({ length: gameSettings.size * gameSettings.size }, (_, i) => i);
    
    // Reset game completed flag
    gameCompleted = false;
    
    // Hide success modal
    successModal.style.display = 'none';
  }

  // Reset game completely
  function resetGame() {
    // Reset game state
    resetGameState();
    
    // Reset level
    level = 1;
    levelDisplay.textContent = '1';
    
    // Hide success modal
    successModal.style.display = 'none';
    
    // Create and shuffle tiles
    createTiles();
    shuffleTiles();
    
    // Start timer
    startTimer();
  }

  // Show notification
  function showNotification(message) {
    notificationMessage.textContent = message;
    notification.classList.add('show');
    
    // Auto-hide after 3 seconds
    setTimeout(() => {
      hideNotification();
    }, 3000);
  }

  // Hide notification
  function hideNotification() {
    notification.classList.remove('show');
  }

  // Create confetti effect
  function createConfettiEffect() {
    const confettiCount = 150;
    const colors = ['#6a5ae0', '#a890ff', '#ff416c', '#ff4b2b', '#00ffcc'];
    
    for (let i = 0; i < confettiCount; i++) {
      createConfetti(colors);
    }
  }

  // Create single confetti element
  function createConfetti(colors) {
    const confetti = document.createElement('div');
    confetti.className = 'confetti';
    
    // Random color
    const color = colors[Math.floor(Math.random() * colors.length)];
    confetti.style.backgroundColor = color;
    
    // Random size
    const size = Math.random() * 10 + 5;
    confetti.style.width = `${size}px`;
    confetti.style.height = `${size}px`;
    
    // Random position
    const startX = window.innerWidth / 2;
    const startY = window.innerHeight / 2;
    
    confetti.style.left = `${startX}px`;
    confetti.style.top = `${startY}px`;
    
    // Add to document
    document.body.appendChild(confetti);
    
    // Animate
    const animationDuration = Math.random() * 3 + 2;
    const angle = Math.random() * Math.PI * 2;
    const velocity = Math.random() * 100 + 50;
    const velocityX = Math.cos(angle) * velocity;
    const velocityY = Math.sin(angle) * velocity;
    const gravity = 800;
    
    let currentX = startX;
    let currentY = startY;
    let currentTime = 0;
    const frameTime = 1 / 60; // 60 FPS
    
    const animate = () => {
      currentTime += frameTime;
      
      if (currentTime >= animationDuration) {
        confetti.remove();
        return;
      }
      
      // Update position
      currentX += velocityX * frameTime;
      currentY += velocityY * frameTime + 0.5 * gravity * frameTime * frameTime;
      
      // Update confetti style
      confetti.style.left = `${currentX}px`;
      confetti.style.top = `${currentY}px`;
      confetti.style.opacity = 1 - (currentTime / animationDuration);
      confetti.style.transform = `rotate(${currentTime * 720}deg)`;
      
      // Continue animation
      requestAnimationFrame(animate);
    };
    
    requestAnimationFrame(animate);
  }
});
</script>
{% endblock %}