{% extends 'layout.html' %}

{% block title %}Tetris - ZekaPark{% endblock %}

{% block content %}
<div class="tetris-container">
  <div class="tetris-game">
    <div class="tetris-header">
      <h1>MARATHON</h1>
    </div>
    <div class="tetris-content">
      <div class="tetris-hold">
        <div class="tetris-sidebar-title">HOLD</div>
        <div class="tetris-hold-piece">
          <div class="tetris-block l-piece"></div>
        </div>
      </div>
      
      <div class="tetris-board">
        <canvas id="tetris-canvas"></canvas>
        <div id="tetris-overlay" class="tetris-overlay">
          <div id="game-start" class="tetris-message">
            <h2>TETRIS</h2>
            <p>Başlamak için dokunun</p>
          </div>
          <div id="game-paused" class="tetris-message" style="display: none;">
            <h2>DURAKLATILDI</h2>
            <p>Devam etmek için dokunun</p>
          </div>
          <div id="game-over" class="tetris-message" style="display: none;">
            <h2>OYUN BİTTİ</h2>
            <div class="final-score">
              <span id="final-score">0</span>
            </div>
            <div class="tetris-buttons">
              <button id="play-again">Tekrar Oyna</button>
              <button id="main-menu">Ana Menü</button>
            </div>
          </div>
        </div>
      </div>
      
      <div class="tetris-info">
        <div class="tetris-sidebar-title">NEXT</div>
        <div class="tetris-next-pieces">
          <div class="tetris-next-piece">
            <div class="tetris-block z-piece"></div>
          </div>
          <div class="tetris-next-piece">
            <div class="tetris-block j-piece"></div>
          </div>
          <div class="tetris-next-piece">
            <div class="tetris-block o-piece"></div>
          </div>
          <div class="tetris-next-piece">
            <div class="tetris-block i-piece"></div>
          </div>
          <div class="tetris-next-piece">
            <div class="tetris-block l-piece-alt"></div>
          </div>
        </div>
        
        <div class="tetris-controls">
          <button id="rotate-btn" class="tetris-control-btn"><i class="fas fa-redo"></i></button>
          <button id="right-btn" class="tetris-control-btn"><i class="fas fa-arrow-right"></i></button>
          <button id="left-btn" class="tetris-control-btn"><i class="fas fa-arrow-left"></i></button>
          <button id="down-btn" class="tetris-control-btn"><i class="fas fa-arrow-down"></i></button>
        </div>
      </div>
    </div>
    
    <div class="tetris-footer">
      <div class="tetris-score">
        <div class="score-label">SCORE</div>
        <div id="score" class="score-value">0</div>
      </div>
      <div class="tetris-level">
        <div class="level-label">LEVEL</div>
        <div id="level" class="level-value">1</div>
      </div>
      <div class="tetris-lines">
        <div class="lines-label">LINES</div>
        <div id="lines" class="lines-value">0</div>
      </div>
    </div>
  </div>
</div>

<style>
:root {
  --primary-bg: #1a1464;
  --game-bg: #0a0630;
  --header-bg: #3d337e;
  --text-color: #ffffff;
  --block-border: rgba(255, 255, 255, 0.2);
  
  --i-color: #00ffff;
  --j-color: #0000ff;
  --l-color: #ff7700;
  --o-color: #ffff00;
  --s-color: #00ff00;
  --t-color: #aa00ff;
  --z-color: #ff0000;
}

.tetris-container {
  max-width: 100%;
  width: 100%;
  min-height: 100vh;
  background-color: var(--primary-bg);
  padding: 0;
  margin: 0;
  display: flex;
  justify-content: center;
  align-items: center;
  overflow: hidden;
}

.tetris-game {
  width: 100%;
  max-width: 500px;
  display: flex;
  flex-direction: column;
  height: 100vh;
}

.tetris-header {
  background-color: var(--header-bg);
  text-align: center;
  padding: 10px 0;
}

.tetris-header h1 {
  color: var(--text-color);
  margin: 0;
  font-size: 1.8rem;
  letter-spacing: 2px;
}

.tetris-content {
  display: flex;
  flex: 1;
  background-color: var(--header-bg);
}

.tetris-hold, .tetris-info {
  width: 70px;
  background-color: var(--header-bg);
  display: flex;
  flex-direction: column;
  align-items: center;
  padding: 10px 0;
}

.tetris-board {
  flex: 1;
  position: relative;
  background-color: var(--game-bg);
  aspect-ratio: 1/2;
  margin: 0 1px;
}

#tetris-canvas {
  width: 100%;
  height: 100%;
  display: block;
}

.tetris-sidebar-title {
  color: var(--text-color);
  margin-bottom: 10px;
  font-weight: bold;
  letter-spacing: 1px;
}

.tetris-hold-piece {
  width: 50px;
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.tetris-next-pieces {
  display: flex;
  flex-direction: column;
  gap: 15px;
  margin-bottom: 50px;
}

.tetris-next-piece {
  width: 50px;
  height: 50px;
  display: flex;
  justify-content: center;
  align-items: center;
}

.tetris-block {
  width: 30px;
  height: 30px;
}

.i-piece {
  background-color: var(--i-color);
}

.j-piece {
  background-color: var(--j-color);
}

.l-piece {
  background-color: var(--l-color);
}

.l-piece-alt {
  background-color: var(--l-color);
}

.o-piece {
  background-color: var(--o-color);
}

.s-piece {
  background-color: var(--s-color);
}

.t-piece {
  background-color: var(--t-color);
}

.z-piece {
  background-color: var(--z-color);
}

.tetris-controls {
  display: flex;
  flex-direction: column;
  gap: 10px;
  align-items: center;
  margin-top: auto;
}

.tetris-control-btn {
  width: 40px;
  height: 40px;
  display: flex;
  justify-content: center;
  align-items: center;
  background-color: rgba(0, 0, 0, 0.3);
  color: var(--text-color);
  border: none;
  border-radius: 50%;
  font-size: 1.2rem;
}

.tetris-control-btn:active {
  background-color: rgba(0, 0, 0, 0.5);
}

.tetris-footer {
  background-color: var(--header-bg);
  padding: 10px 15px;
  display: flex;
  justify-content: space-between;
}

.tetris-score, .tetris-level, .tetris-lines {
  text-align: center;
}

.score-label, .level-label, .lines-label {
  color: var(--text-color);
  font-size: 0.8rem;
  margin-bottom: 5px;
}

.score-value, .level-value, .lines-value {
  color: var(--text-color);
  font-size: 1.2rem;
  font-weight: bold;
}

.tetris-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-color: rgba(10, 6, 48, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
}

.tetris-message {
  text-align: center;
  color: var(--text-color);
  padding: 20px;
}

.tetris-message h2 {
  font-size: 2rem;
  margin-bottom: 20px;
}

.final-score {
  font-size: 3rem;
  font-weight: bold;
  margin: 20px 0;
}

.tetris-buttons {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.tetris-buttons button {
  background-color: rgba(255, 255, 255, 0.2);
  color: var(--text-color);
  border: none;
  padding: 10px 20px;
  border-radius: 5px;
  font-size: 1rem;
}

.tetris-buttons button:hover {
  background-color: rgba(255, 255, 255, 0.3);
}

/* Responsive styles */
@media (max-width: 500px) {
  .tetris-game {
    height: 100vh;
    width: 100vw;
  }
  
  .tetris-hold, .tetris-info {
    width: 60px;
    padding: 5px 0;
  }
  
  .tetris-sidebar-title {
    font-size: 0.8rem;
  }
  
  .tetris-hold-piece,
  .tetris-next-piece {
    width: 40px;
    height: 40px;
  }
  
  .tetris-block {
    width: 25px;
    height: 25px;
  }
  
  .tetris-next-pieces {
    gap: 10px;
    margin-bottom: 30px;
  }
  
  .tetris-control-btn {
    width: 35px;
    height: 35px;
  }
  
  .tetris-header h1 {
    font-size: 1.5rem;
  }
}

@media (max-height: 700px) {
  .tetris-next-pieces {
    gap: 8px;
  }
  
  .tetris-next-piece {
    height: 35px;
  }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // Canvas setup
  const canvas = document.getElementById('tetris-canvas');
  const ctx = canvas.getContext('2d');
  
  // Game overlay elements
  const overlay = document.getElementById('tetris-overlay');
  const gameStart = document.getElementById('game-start');
  const gamePaused = document.getElementById('game-paused');
  const gameOver = document.getElementById('game-over');
  const finalScore = document.getElementById('final-score');
  
  // Control buttons
  const rotateBtn = document.getElementById('rotate-btn');
  const rightBtn = document.getElementById('right-btn');
  const leftBtn = document.getElementById('left-btn');
  const downBtn = document.getElementById('down-btn');
  const playAgainBtn = document.getElementById('play-again');
  const mainMenuBtn = document.getElementById('main-menu');
  
  // Score display
  const scoreDisplay = document.getElementById('score');
  const levelDisplay = document.getElementById('level');
  const linesDisplay = document.getElementById('lines');
  
  // Game constants
  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 30;
  const EMPTY = 0;
  
  // Game variables
  let board = [];
  let score = 0;
  let level = 1;
  let lines = 0;
  let dropCounter = 0;
  let dropInterval = 1000; // milliseconds
  let lastTime = 0;
  let requestId = null;
  let gameRunning = false;
  let gamePause = false;
  let currentPiece = null;
  let nextPiece = null;
  let holdPiece = null;
  let canHold = true;
  
  // Tetris pieces
  const PIECES = [
    { // I
      shape: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      color: '#00FFFF'
    },
    { // J
      shape: [
        [1, 0, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      color: '#0000FF'
    },
    { // L
      shape: [
        [0, 0, 1],
        [1, 1, 1],
        [0, 0, 0]
      ],
      color: '#FF7700'
    },
    { // O
      shape: [
        [1, 1],
        [1, 1]
      ],
      color: '#FFFF00'
    },
    { // S
      shape: [
        [0, 1, 1],
        [1, 1, 0],
        [0, 0, 0]
      ],
      color: '#00FF00'
    },
    { // T
      shape: [
        [0, 1, 0],
        [1, 1, 1],
        [0, 0, 0]
      ],
      color: '#AA00FF'
    },
    { // Z
      shape: [
        [1, 1, 0],
        [0, 1, 1],
        [0, 0, 0]
      ],
      color: '#FF0000'
    }
  ];
  
  // Create an empty board
  function createBoard() {
    return Array.from({length: ROWS}, () => Array(COLS).fill(EMPTY));
  }
  
  // Resize canvas to fit container
  function resizeCanvas() {
    const container = canvas.parentElement;
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    canvas.width = containerWidth;
    canvas.height = containerHeight;
    
    // Redraw the board
    if (gameRunning && !gamePause) {
      draw();
    }
  }
  
  // Initialize game
  function init() {
    // Reset game state
    board = createBoard();
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    gameRunning = false;
    gamePause = false;
    currentPiece = null;
    nextPiece = null;
    holdPiece = null;
    canHold = true;
    
    // Update display
    scoreDisplay.textContent = score;
    levelDisplay.textContent = level;
    linesDisplay.textContent = lines;
    
    // Show start screen
    overlay.style.display = 'flex';
    gameStart.style.display = 'block';
    gamePaused.style.display = 'none';
    gameOver.style.display = 'none';
    
    // Cancel any existing animation frame
    if (requestId) {
      cancelAnimationFrame(requestId);
      requestId = null;
    }
    
    // Draw empty board
    resizeCanvas();
    drawBoard();
  }
  
  // Generate random piece
  function getRandomPiece() {
    const pieceIndex = Math.floor(Math.random() * PIECES.length);
    const piece = JSON.parse(JSON.stringify(PIECES[pieceIndex])); // Deep clone
    
    // Position at top-center
    piece.x = Math.floor(COLS / 2) - Math.floor(piece.shape[0].length / 2);
    piece.y = 0;
    
    return piece;
  }
  
  // Check if piece collides with walls or placed blocks
  function collides(piece, x, y) {
    const shape = piece.shape;
    
    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col] !== 0) {
          const newX = piece.x + col + x;
          const newY = piece.y + row + y;
          
          if (newX < 0 || newX >= COLS || newY >= ROWS) {
            return true; // Out of bounds
          }
          
          if (newY >= 0 && board[newY][newX] !== EMPTY) {
            return true; // Collision with placed block
          }
        }
      }
    }
    
    return false;
  }
  
  // Draw a single block
  function drawBlock(x, y, color) {
    const blockX = x * (canvas.width / COLS);
    const blockY = y * (canvas.height / ROWS);
    const blockWidth = canvas.width / COLS;
    const blockHeight = canvas.height / ROWS;
    
    // Block fill
    ctx.fillStyle = color;
    ctx.fillRect(blockX, blockY, blockWidth, blockHeight);
    
    // Block border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.strokeRect(blockX, blockY, blockWidth, blockHeight);
    
    // Block highlight (3D effect)
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.fillRect(blockX, blockY, blockWidth, blockHeight / 4);
    ctx.fillRect(blockX, blockY, blockWidth / 4, blockHeight);
  }
  
  // Draw the board
  function drawBoard() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw placed blocks
    for (let row = 0; row < ROWS; row++) {
      for (let col = 0; col < COLS; col++) {
        if (board[row][col] !== EMPTY) {
          drawBlock(col, row, board[row][col]);
        }
      }
    }
  }
  
  // Draw the current piece
  function drawPiece(piece) {
    const shape = piece.shape;
    
    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col] !== 0) {
          drawBlock(piece.x + col, piece.y + row, piece.color);
        }
      }
    }
  }
  
  // Draw ghost piece (where the piece will land)
  function drawGhost(piece) {
    const ghostPiece = JSON.parse(JSON.stringify(piece));
    
    // Move ghost down until it collides
    while (!collides(ghostPiece, 0, 1)) {
      ghostPiece.y++;
    }
    
    // Draw ghost
    const shape = ghostPiece.shape;
    
    ctx.globalAlpha = 0.2;
    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col] !== 0) {
          drawBlock(ghostPiece.x + col, ghostPiece.y + row, piece.color);
        }
      }
    }
    ctx.globalAlpha = 1;
  }
  
  // Draw everything
  function draw() {
    drawBoard();
    
    // Draw ghost piece
    drawGhost(currentPiece);
    
    // Draw current piece
    drawPiece(currentPiece);
  }
  
  // Rotate piece
  function rotatePiece() {
    const piece = currentPiece;
    const newShape = [];
    
    // Create new rotated shape
    for (let col = 0; col < piece.shape[0].length; col++) {
      const newRow = [];
      for (let row = piece.shape.length - 1; row >= 0; row--) {
        newRow.push(piece.shape[row][col]);
      }
      newShape.push(newRow);
    }
    
    // Test if rotation is valid
    const oldShape = piece.shape;
    piece.shape = newShape;
    
    if (collides(piece, 0, 0)) {
      // Wall kick - try to adjust position
      if (!collides(piece, 1, 0)) {
        piece.x++;
      } else if (!collides(piece, -1, 0)) {
        piece.x--;
      } else if (!collides(piece, 0, -1)) {
        piece.y--;
      } else {
        // Rotation not possible, revert
        piece.shape = oldShape;
      }
    }
    
    // Play rotation sound
    playSound('rotate');
  }
  
  // Move piece
  function movePiece(dx, dy) {
    if (!collides(currentPiece, dx, dy)) {
      currentPiece.x += dx;
      currentPiece.y += dy;
      return true;
    }
    return false;
  }
  
  // Hard drop - move piece down as far as possible
  function hardDrop() {
    while (movePiece(0, 1)) {
      score += 2; // 2 points per cell dropped
    }
    scoreDisplay.textContent = score;
    playSound('hardDrop');
    placePiece();
  }
  
  // Place the piece on the board
  function placePiece() {
    const piece = currentPiece;
    const shape = piece.shape;
    
    for (let row = 0; row < shape.length; row++) {
      for (let col = 0; col < shape[row].length; col++) {
        if (shape[row][col] !== 0) {
          const boardY = piece.y + row;
          const boardX = piece.x + col;
          
          if (boardY < 0) {
            // Game over if piece is above the board
            gameOver();
            return;
          }
          
          board[boardY][boardX] = piece.color;
        }
      }
    }
    
    // Play place sound
    playSound('place');
    
    // Check for line clears
    clearLines();
    
    // Update next piece
    currentPiece = nextPiece;
    nextPiece = getRandomPiece();
    
    // Allow holding again
    canHold = true;
    
    // Update UI elements for next piece
    updateNextPieceDisplay();
  }
  
  // Clear completed lines
  function clearLines() {
    let linesCleared = 0;
    
    for (let row = ROWS - 1; row >= 0; row--) {
      if (board[row].every(cell => cell !== EMPTY)) {
        // Line is complete
        linesCleared++;
        
        // Remove the line and add empty line at top
        board.splice(row, 1);
        board.unshift(Array(COLS).fill(EMPTY));
        
        // Check the same row again after removing
        row++;
      }
    }
    
    if (linesCleared > 0) {
      // Update lines count
      lines += linesCleared;
      linesDisplay.textContent = lines;
      
      // Update score based on lines cleared
      const linePoints = [0, 100, 300, 500, 800]; // 0, 1, 2, 3, 4 lines
      score += linePoints[linesCleared] * level;
      scoreDisplay.textContent = score;
      
      // Play line clear sound
      playSound('lineClear');
      
      // Check for level up
      const newLevel = Math.floor(lines / 10) + 1;
      if (newLevel > level) {
        level = newLevel;
        levelDisplay.textContent = level;
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
        
        // Play level up sound
        playSound('levelUp');
      }
    }
  }
  
  // Update next piece display
  function updateNextPieceDisplay() {
    // Placeholder for UI update of next pieces
    // Would replace the static pieces with dynamic ones
  }
  
  // Game loop
  function gameLoop(time = 0) {
    const deltaTime = time - lastTime;
    lastTime = time;
    
    dropCounter += deltaTime;
    
    if (dropCounter > dropInterval) {
      if (!movePiece(0, 1)) {
        // Piece can't move down, place it
        placePiece();
      }
      dropCounter = 0;
    }
    
    draw();
    requestId = requestAnimationFrame(gameLoop);
  }
  
  // Start game
  function startGame() {
    if (!gameRunning) {
      gameRunning = true;
      
      // Generate first and next piece
      currentPiece = getRandomPiece();
      nextPiece = getRandomPiece();
      
      // Hide overlay
      overlay.style.display = 'none';
      
      // Start game loop
      lastTime = 0;
      dropCounter = 0;
      gameLoop();
      
      // Play start sound
      playSound('gameStart');
    }
  }
  
  // Pause game
  function pauseGame() {
    if (gameRunning && !gamePause) {
      gamePause = true;
      
      // Cancel animation frame
      cancelAnimationFrame(requestId);
      requestId = null;
      
      // Show pause overlay
      overlay.style.display = 'flex';
      gameStart.style.display = 'none';
      gamePaused.style.display = 'block';
      gameOver.style.display = 'none';
      
      // Play pause sound
      playSound('pause');
    }
  }
  
  // Resume game
  function resumeGame() {
    if (gameRunning && gamePause) {
      gamePause = false;
      
      // Hide overlay
      overlay.style.display = 'none';
      
      // Reset time tracking
      lastTime = 0;
      
      // Restart game loop
      requestId = requestAnimationFrame(gameLoop);
      
      // Play resume sound
      playSound('resume');
    }
  }
  
  // Game over
  function gameOver() {
    gameRunning = false;
    
    // Cancel animation frame
    cancelAnimationFrame(requestId);
    requestId = null;
    
    // Show game over overlay
    overlay.style.display = 'flex';
    gameStart.style.display = 'none';
    gamePaused.style.display = 'none';
    gameOver.style.display = 'block';
    
    // Update final score
    finalScore.textContent = score;
    
    // Save score to server
    saveScore(score);
    
    // Play game over sound
    playSound('gameOver');
  }
  
  // Play sound effect
  function playSound(soundType) {
    let sound;
    
    switch (soundType) {
      case 'gameStart':
        sound = new Audio('/static/sounds/game-complete.mp3');
        break;
      case 'gameOver':
        sound = new Audio('/static/sounds/game-over.mp3');
        break;
      case 'lineClear':
        sound = new Audio('/static/sounds/success.mp3');
        break;
      case 'levelUp':
        sound = new Audio('/static/sounds/level-up.mp3');
        break;
      case 'rotate':
        sound = new Audio('/static/sounds/click.mp3');
        break;
      case 'place':
        sound = new Audio('/static/sounds/match.mp3');
        break;
      case 'hardDrop':
        sound = new Audio('/static/sounds/card-flip.mp3');
        break;
      case 'pause':
      case 'resume':
        sound = new Audio('/static/sounds/hint.mp3');
        break;
      default:
        return;
    }
    
    sound.play().catch(error => {
      console.log('Sound playback prevented:', error);
    });
  }
  
  // Save score to server
  function saveScore(score) {
    fetch('/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'tetris',
        score: score
      })
    }).catch(error => {
      console.log('Error saving score:', error);
    });
  }
  
  // Event handlers
  
  // Canvas click event (start/resume game)
  overlay.addEventListener('click', function() {
    if (!gameRunning) {
      startGame();
    } else if (gamePause) {
      resumeGame();
    }
  });
  
  // Game control buttons
  rotateBtn.addEventListener('click', function() {
    if (gameRunning && !gamePause) {
      rotatePiece();
    }
  });
  
  rightBtn.addEventListener('click', function() {
    if (gameRunning && !gamePause) {
      movePiece(1, 0);
    }
  });
  
  leftBtn.addEventListener('click', function() {
    if (gameRunning && !gamePause) {
      movePiece(-1, 0);
    }
  });
  
  downBtn.addEventListener('click', function() {
    if (gameRunning && !gamePause) {
      if (!movePiece(0, 1)) {
        placePiece();
      }
    }
  });
  
  // Play again button
  playAgainBtn.addEventListener('click', function() {
    init();
    startGame();
  });
  
  // Main menu button
  mainMenuBtn.addEventListener('click', function() {
    window.location.href = "{{ url_for('all_games') }}";
  });
  
  // Keyboard controls
  document.addEventListener('keydown', function(event) {
    if (!gameRunning || gamePause) return;
    
    switch (event.key) {
      case 'ArrowLeft':
        movePiece(-1, 0);
        break;
      case 'ArrowRight':
        movePiece(1, 0);
        break;
      case 'ArrowDown':
        if (!movePiece(0, 1)) {
          placePiece();
        }
        break;
      case 'ArrowUp':
        rotatePiece();
        break;
      case ' ': // Spacebar
        hardDrop();
        break;
      case 'p':
      case 'P':
        pauseGame();
        break;
    }
  });
  
  // Window resize event
  window.addEventListener('resize', function() {
    resizeCanvas();
  });
  
  // Double tap to pause/resume on mobile
  let lastTap = 0;
  canvas.addEventListener('touchend', function() {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    
    if (tapLength < 300 && tapLength > 0) {
      // Double tap detected
      if (gameRunning && !gamePause) {
        pauseGame();
      } else if (gameRunning && gamePause) {
        resumeGame();
      }
    }
    
    lastTap = currentTime;
  });
  
  // Initialize the game
  init();
  resizeCanvas();
});
</script>
{% endblock %}