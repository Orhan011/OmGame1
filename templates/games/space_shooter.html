{% extends "layout.html" %}

{% block title %}Space Shooter - ZekaPark{% endblock %}

{% block styles %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/game-modernizer.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/game-responsive-modernizer.css') }}">
<link rel="stylesheet" href="{{ url_for('static', filename='css/score-display.css') }}">
<style>
    .game-container {
        background-color: #0d1117;
        width: 100%;
        height: 600px;
        position: relative;
        overflow: hidden;
        border-radius: 8px;
        box-shadow: 0 4px 10px rgba(0, 0, 0, 0.3);
    }
    
    .game-bg {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: #090a0f;
        background-image: url('/static/images/space_bg.jpg');
        background-size: cover;
        background-position: center;
        opacity: 0.6;
    }
    
    .game-canvas {
        position: relative;
        z-index: 2;
        width: 100%;
        height: 100%;
    }
    
    .game-hud {
        position: absolute;
        top: 20px;
        left: 20px;
        padding: 10px 20px;
        background-color: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
        color: white;
        z-index: 3;
        display: flex;
        gap: 15px;
    }
    
    .hud-item {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .hud-icon {
        font-size: 18px;
    }
    
    .hud-value {
        font-weight: bold;
        font-size: 18px;
    }
    
    .game-controls {
        position: absolute;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background-color: rgba(0, 0, 0, 0.6);
        border-radius: 10px;
        padding: 10px 20px;
        color: white;
        z-index: 3;
        display: flex;
        gap: 20px;
        font-size: 14px;
    }
    
    .control-item {
        display: flex;
        align-items: center;
        gap: 8px;
    }
    
    .control-key {
        background-color: rgba(255, 255, 255, 0.2);
        padding: 5px 10px;
        border-radius: 4px;
        font-family: monospace;
    }
    
    .game-overlay {
        position: absolute;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background-color: rgba(0, 0, 0, 0.8);
        z-index: 10;
        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
        color: white;
    }
    
    .overlay-content {
        max-width: 400px;
        text-align: center;
    }
    
    .overlay-buttons {
        margin-top: 20px;
        display: flex;
        gap: 10px;
    }
    
    .power-up-indicator {
        position: absolute;
        top: 20px;
        right: 20px;
        display: flex;
        flex-direction: column;
        gap: 10px;
        z-index: 3;
    }
    
    .power-up {
        display: flex;
        align-items: center;
        gap: 8px;
        background-color: rgba(0, 0, 0, 0.6);
        padding: 5px 10px;
        border-radius: 5px;
        color: white;
    }
    
    .power-up-icon {
        width: 20px;
        height: 20px;
    }
    
    .power-up-timer {
        width: 50px;
        height: 5px;
        background-color: #444;
        border-radius: 3px;
        overflow: hidden;
    }
    
    .power-up-fill {
        height: 100%;
        width: 100%;
        background-color: #3498db;
    }
    
    @media (max-width: 768px) {
        .game-container {
            height: 500px;
        }
        
        .game-hud, .game-controls {
            font-size: 14px;
        }
        
        .hud-value {
            font-size: 16px;
        }
    }
    
    @media (max-width: 576px) {
        .game-container {
            height: 400px;
        }
        
        .game-hud {
            top: 10px;
            left: 10px;
            padding: 5px 10px;
        }
        
        .game-controls {
            flex-direction: column;
            gap: 5px;
            font-size: 12px;
        }
    }
</style>
{% endblock %}

{% block content %}
<div class="game-wrapper">
    <div class="game-header">
        <h1>Space Shooter</h1>
        <p class="game-description">Uzay gemisiyle düşman gemilerine ve asteroitlere karşı savaşın. Reflekslerinizi ve stratejik düşünme becerinizi test edin!</p>
    </div>
    
    <div class="game-container">
        <div class="game-bg"></div>
        <canvas class="game-canvas" id="gameCanvas"></canvas>
        
        <div class="game-hud">
            <div class="hud-item">
                <span class="hud-icon"><i class="fas fa-heart"></i></span>
                <span class="hud-value" id="lives">3</span>
            </div>
            <div class="hud-item">
                <span class="hud-icon"><i class="fas fa-star"></i></span>
                <span class="hud-value" id="score">0</span>
            </div>
            <div class="hud-item">
                <span class="hud-icon"><i class="fas fa-fighter-jet"></i></span>
                <span class="hud-value" id="level">1</span>
            </div>
        </div>
        
        <div class="power-up-indicator" id="powerUpIndicator">
            <!-- Power-up indicators will be added dynamically -->
        </div>
        
        <div class="game-controls">
            <div class="control-item">
                <span class="control-key">W</span>
                <span>İleri</span>
            </div>
            <div class="control-item">
                <span class="control-key">A</span>
                <span>Sol</span>
            </div>
            <div class="control-item">
                <span class="control-key">S</span>
                <span>Geri</span>
            </div>
            <div class="control-item">
                <span class="control-key">D</span>
                <span>Sağ</span>
            </div>
            <div class="control-item">
                <span class="control-key">Space</span>
                <span>Ateş</span>
            </div>
        </div>
        
        <div class="game-overlay" id="startOverlay">
            <div class="overlay-content">
                <h2>Space Shooter</h2>
                <p>Uzay gemisiyle düşman gemilerine ve asteroitlere karşı savaşın. WASD tuşlarıyla hareket edin, SPACE tuşuyla ateş edin.</p>
                <div class="difficulty-selection">
                    <button class="difficulty-btn" data-difficulty="easy">Kolay</button>
                    <button class="difficulty-btn" data-difficulty="medium">Orta</button>
                    <button class="difficulty-btn" data-difficulty="hard">Zor</button>
                </div>
                <div class="overlay-buttons">
                    <button id="startGameBtn" class="btn-primary">Oyunu Başlat</button>
                </div>
            </div>
        </div>
        
        <div class="game-overlay" id="gameOverOverlay" style="display: none;">
            <div class="overlay-content">
                <h2>Oyun Bitti!</h2>
                <p>Uzay geminiz yok edildi.</p>
                <div id="finalScore"></div>
                <div class="score-display-container" id="scoreDisplay">
                    <div class="score-display-header">
                        <h3>Oyun Sonucu</h3>
                    </div>
                    <div class="score-display-content">
                        <div class="score-display-item">
                            <span>Toplam Puan:</span>
                            <span id="totalPoints">0</span>
                        </div>
                        <div class="score-display-breakdown">
                            <div class="score-breakdown-item">
                                <span>Temel Puan:</span>
                                <span id="basePoints">0</span>
                            </div>
                            <div class="score-breakdown-item">
                                <span>Zorluk Çarpanı:</span>
                                <span id="difficultyMultiplier">x1.0</span>
                            </div>
                            <div class="score-breakdown-item">
                                <span>Bonus:</span>
                                <span id="bonusPoints">0</span>
                            </div>
                        </div>
                        <div class="score-display-xp">
                            <span>Kazanılan XP:</span>
                            <span id="xpEarned">0</span>
                        </div>
                    </div>
                </div>
                <div class="overlay-buttons">
                    <button id="playAgainBtn" class="btn-primary">Tekrar Oyna</button>
                    <button id="returnBtn" class="btn-secondary">Ana Sayfa</button>
                </div>
            </div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script src="{{ url_for('static', filename='js/score-display.js') }}"></script>
<script>
document.addEventListener('DOMContentLoaded', function() {
    // Game variables
    let game = {
        started: false,
        gameOver: false,
        difficulty: 'medium',
        score: 0,
        lives: 3,
        level: 1,
        player: null,
        enemies: [],
        bullets: [],
        powerUps: [],
        asteroids: [],
        activePowerUps: [],
        canvas: document.getElementById('gameCanvas'),
        ctx: null,
        keys: {},
        lastUpdateTime: 0,
        frameCount: 0,
        gameTime: 0,
        enemySpawnRate: 120, // frames between enemy spawns
        asteroidSpawnRate: 180, // frames between asteroid spawns
        powerUpSpawnRate: 600, // frames between power-up spawns
        difficultyMultipliers: {
            easy: 0.75,
            medium: 1.0,
            hard: 1.5
        },
        spriteCache: {},
        animationFrame: null
    };
    
    // Initialize canvas
    game.canvas.width = game.canvas.offsetWidth;
    game.canvas.height = game.canvas.offsetHeight;
    game.ctx = game.canvas.getContext('2d');
    
    // Load sprites
    function loadSprite(src) {
        if (game.spriteCache[src]) {
            return game.spriteCache[src];
        }
        
        const img = new Image();
        img.src = src;
        game.spriteCache[src] = img;
        return img;
    }
    
    // Player class
    class Player {
        constructor() {
            this.width = 50;
            this.height = 50;
            this.x = game.canvas.width / 2 - this.width / 2;
            this.y = game.canvas.height - this.height - 30;
            this.speed = 5;
            this.bulletCooldown = 0;
            this.bulletType = 'normal';
            this.sprite = loadSprite('/static/images/spaceship.svg');
        }
        
        draw() {
            game.ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
        }
        
        update() {
            // Movement
            if (game.keys['KeyW'] || game.keys['ArrowUp']) {
                this.y = Math.max(0, this.y - this.speed);
            }
            if (game.keys['KeyS'] || game.keys['ArrowDown']) {
                this.y = Math.min(game.canvas.height - this.height, this.y + this.speed);
            }
            if (game.keys['KeyA'] || game.keys['ArrowLeft']) {
                this.x = Math.max(0, this.x - this.speed);
            }
            if (game.keys['KeyD'] || game.keys['ArrowRight']) {
                this.x = Math.min(game.canvas.width - this.width, this.x + this.speed);
            }
            
            // Shooting
            if (this.bulletCooldown > 0) {
                this.bulletCooldown--;
            }
            
            if ((game.keys['Space'] || game.keys[' ']) && this.bulletCooldown <= 0) {
                this.shoot();
                this.bulletCooldown = 15; // Frames between shots
            }
        }
        
        shoot() {
            switch (this.bulletType) {
                case 'normal':
                    game.bullets.push(new Bullet(
                        this.x + this.width / 2 - 2,
                        this.y,
                        'normal'
                    ));
                    break;
                    
                case 'double':
                    game.bullets.push(new Bullet(
                        this.x + this.width / 4,
                        this.y,
                        'normal'
                    ));
                    game.bullets.push(new Bullet(
                        this.x + this.width * 3/4,
                        this.y,
                        'normal'
                    ));
                    break;
                    
                case 'triple':
                    game.bullets.push(new Bullet(
                        this.x + this.width / 2 - 2,
                        this.y,
                        'normal'
                    ));
                    game.bullets.push(new Bullet(
                        this.x + this.width / 4,
                        this.y + 10,
                        'normal',
                        -0.3
                    ));
                    game.bullets.push(new Bullet(
                        this.x + this.width * 3/4,
                        this.y + 10,
                        'normal',
                        0.3
                    ));
                    break;
                    
                case 'laser':
                    game.bullets.push(new Bullet(
                        this.x + this.width / 2 - 5,
                        this.y,
                        'laser'
                    ));
                    break;
            }
        }
    }
    
    // Bullet class
    class Bullet {
        constructor(x, y, type = 'normal', angleOffset = 0) {
            this.x = x;
            this.y = y;
            this.type = type;
            this.angleOffset = angleOffset;
            
            switch (type) {
                case 'normal':
                    this.width = 4;
                    this.height = 10;
                    this.speed = 10;
                    this.damage = 1;
                    this.color = '#3498db';
                    break;
                    
                case 'laser':
                    this.width = 10;
                    this.height = 20;
                    this.speed = 12;
                    this.damage = 2;
                    this.color = '#e74c3c';
                    break;
            }
        }
        
        draw() {
            game.ctx.fillStyle = this.color;
            game.ctx.fillRect(this.x, this.y, this.width, this.height);
        }
        
        update() {
            const angleRadians = this.angleOffset * Math.PI;
            this.x += Math.sin(angleRadians) * this.speed;
            this.y -= Math.cos(angleRadians) * this.speed;
            
            // Check if bullet is out of screen
            if (this.y < -this.height) {
                return true; // Remove bullet
            }
            
            return false;
        }
    }
    
    // Enemy class
    class Enemy {
        constructor(type = 'normal') {
            this.type = type;
            this.width = 40;
            this.height = 40;
            this.x = Math.random() * (game.canvas.width - this.width);
            this.y = -this.height;
            
            switch (type) {
                case 'normal':
                    this.health = 1;
                    this.speed = 2 + (game.level * 0.2);
                    this.points = 10;
                    this.sprite = loadSprite('/static/images/enemy.svg');
                    break;
                    
                case 'fast':
                    this.health = 1;
                    this.speed = 4 + (game.level * 0.3);
                    this.points = 15;
                    this.width = 30;
                    this.height = 30;
                    this.sprite = loadSprite('/static/images/enemy.svg');
                    break;
                    
                case 'tank':
                    this.health = 3;
                    this.speed = 1 + (game.level * 0.1);
                    this.points = 20;
                    this.width = 50;
                    this.height = 50;
                    this.sprite = loadSprite('/static/images/enemy.svg');
                    break;
                    
                case 'boss':
                    this.health = 10;
                    this.speed = 0.8 + (game.level * 0.08);
                    this.points = 50;
                    this.width = 80;
                    this.height = 80;
                    this.sprite = loadSprite('/static/images/boss.svg');
                    
                    // Boss shoots
                    this.shootCooldown = 60;
                    break;
            }
            
            // Apply difficulty
            this.health = Math.ceil(this.health * game.difficultyMultipliers[game.difficulty]);
            this.speed *= game.difficultyMultipliers[game.difficulty];
        }
        
        draw() {
            game.ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
        }
        
        update() {
            this.y += this.speed;
            
            // Boss shooting
            if (this.type === 'boss') {
                if (this.shootCooldown <= 0) {
                    // Shoot enemy bullet
                    const bullet = new EnemyBullet(
                        this.x + this.width / 2 - 2,
                        this.y + this.height
                    );
                    game.enemies.push(bullet);
                    this.shootCooldown = 120; // 2 seconds at 60fps
                } else {
                    this.shootCooldown--;
                }
            }
            
            // Check if enemy is out of screen
            if (this.y > game.canvas.height) {
                if (this.type !== 'bullet') {
                    // Player loses a life if enemy passes through
                    game.lives--;
                    updateGameStats();
                    
                    if (game.lives <= 0) {
                        endGame();
                    }
                }
                return true; // Remove enemy
            }
            
            return false;
        }
        
        takeDamage(damage) {
            this.health -= damage;
            
            if (this.health <= 0) {
                game.score += this.points;
                updateGameStats();
                
                // Chance to drop power-up (except for bullets)
                if (this.type !== 'bullet' && Math.random() < 0.1) {
                    game.powerUps.push(new PowerUp(
                        this.x + this.width / 2,
                        this.y + this.height / 2
                    ));
                }
                
                return true; // Enemy destroyed
            }
            
            return false;
        }
    }
    
    // Enemy Bullet class
    class EnemyBullet extends Enemy {
        constructor(x, y) {
            super('bullet');
            this.x = x;
            this.y = y;
            this.width = 4;
            this.height = 10;
            this.speed = 5;
            this.points = 0;
            this.color = '#e74c3c';
        }
        
        draw() {
            game.ctx.fillStyle = this.color;
            game.ctx.fillRect(this.x, this.y, this.width, this.height);
        }
    }
    
    // Asteroid class
    class Asteroid {
        constructor() {
            this.size = 30 + Math.random() * 30; // Random size between 30-60
            this.x = Math.random() * (game.canvas.width - this.size);
            this.y = -this.size;
            this.speed = 1 + Math.random() * 2 + (game.level * 0.1);
            this.rotationSpeed = (Math.random() - 0.5) * 0.05;
            this.rotation = 0;
            this.health = Math.ceil(this.size / 15);
            this.points = Math.ceil(this.size / 10);
            this.sprite = loadSprite('/static/images/asteroid.svg');
        }
        
        draw() {
            game.ctx.save();
            game.ctx.translate(this.x + this.size/2, this.y + this.size/2);
            game.ctx.rotate(this.rotation);
            game.ctx.drawImage(this.sprite, -this.size/2, -this.size/2, this.size, this.size);
            game.ctx.restore();
        }
        
        update() {
            this.y += this.speed;
            this.rotation += this.rotationSpeed;
            
            // Check if asteroid is out of screen
            if (this.y > game.canvas.height) {
                return true; // Remove asteroid
            }
            
            return false;
        }
        
        takeDamage(damage) {
            this.health -= damage;
            
            if (this.health <= 0) {
                game.score += this.points;
                updateGameStats();
                
                // Chance to split into smaller asteroids
                if (this.size > 40 && Math.random() < 0.3) {
                    for (let i = 0; i < 2; i++) {
                        const smallAsteroid = new Asteroid();
                        smallAsteroid.size = this.size / 2;
                        smallAsteroid.x = this.x + (i === 0 ? -10 : 10);
                        smallAsteroid.y = this.y;
                        smallAsteroid.health = Math.ceil(smallAsteroid.size / 15);
                        smallAsteroid.points = Math.ceil(smallAsteroid.size / 10);
                        game.asteroids.push(smallAsteroid);
                    }
                }
                
                return true; // Asteroid destroyed
            }
            
            return false;
        }
    }
    
    // PowerUp class
    class PowerUp {
        constructor(x, y) {
            this.x = x;
            this.y = y;
            this.width = 25;
            this.height = 25;
            this.speed = 2;
            
            const types = ['double', 'triple', 'laser', 'shield', 'life'];
            this.type = types[Math.floor(Math.random() * types.length)];
            this.sprite = loadSprite('/static/images/powerup.svg');
        }
        
        draw() {
            game.ctx.drawImage(this.sprite, this.x, this.y, this.width, this.height);
            
            // Show power-up type
            game.ctx.fillStyle = 'white';
            game.ctx.font = '12px Arial';
            game.ctx.textAlign = 'center';
            game.ctx.fillText(this.type[0].toUpperCase(), this.x + this.width/2, this.y + this.height/2 + 4);
        }
        
        update() {
            this.y += this.speed;
            
            // Check if power-up is out of screen
            if (this.y > game.canvas.height) {
                return true; // Remove power-up
            }
            
            // Check collision with player
            if (checkCollision(this, game.player)) {
                this.activate();
                return true; // Remove power-up
            }
            
            return false;
        }
        
        activate() {
            const duration = 10000; // 10 seconds
            const activePowerUp = {
                type: this.type,
                startTime: game.gameTime,
                duration: duration,
                endTime: game.gameTime + duration
            };
            
            // Apply power-up effect
            switch (this.type) {
                case 'double':
                case 'triple':
                case 'laser':
                    // Find if there's an existing weapon power-up
                    const existingWeaponIndex = game.activePowerUps.findIndex(p => 
                        ['double', 'triple', 'laser'].includes(p.type));
                    
                    if (existingWeaponIndex !== -1) {
                        // Replace existing weapon power-up
                        game.activePowerUps.splice(existingWeaponIndex, 1);
                    }
                    
                    game.player.bulletType = this.type;
                    game.activePowerUps.push(activePowerUp);
                    break;
                    
                case 'shield':
                    // Implement shield effect
                    game.activePowerUps.push(activePowerUp);
                    break;
                    
                case 'life':
                    // Add life immediately, no need to track
                    game.lives = Math.min(game.lives + 1, 5);
                    updateGameStats();
                    break;
            }
            
            updatePowerUpDisplay();
        }
    }
    
    // Explosion effect
    class Explosion {
        constructor(x, y, size) {
            this.x = x;
            this.y = y;
            this.size = size;
            this.frame = 0;
            this.maxFrames = 20;
            this.sprite = loadSprite('/static/images/explosion.svg');
        }
        
        draw() {
            const opacity = 1 - (this.frame / this.maxFrames);
            game.ctx.globalAlpha = opacity;
            game.ctx.drawImage(
                this.sprite, 
                this.x - this.size/2, 
                this.y - this.size/2, 
                this.size, 
                this.size
            );
            game.ctx.globalAlpha = 1.0;
        }
        
        update() {
            this.frame++;
            return this.frame >= this.maxFrames;
        }
    }
    
    // Check collision between two objects
    function checkCollision(obj1, obj2) {
        return obj1.x < obj2.x + obj2.width &&
               obj1.x + obj1.width > obj2.x &&
               obj1.y < obj2.y + obj2.height &&
               obj1.y + obj1.height > obj2.y;
    }
    
    // Update game stats display
    function updateGameStats() {
        document.getElementById('score').textContent = game.score;
        document.getElementById('lives').textContent = game.lives;
        document.getElementById('level').textContent = game.level;
    }
    
    // Update power-up display
    function updatePowerUpDisplay() {
        const container = document.getElementById('powerUpIndicator');
        container.innerHTML = '';
        
        game.activePowerUps.forEach(powerUp => {
            if (powerUp.type === 'life') return; // Life is immediate
            
            const remaining = powerUp.endTime - game.gameTime;
            if (remaining <= 0) return;
            
            const percentage = (remaining / powerUp.duration) * 100;
            
            const powerUpElement = document.createElement('div');
            powerUpElement.className = 'power-up';
            
            const icon = document.createElement('img');
            icon.className = 'power-up-icon';
            icon.src = '/static/images/powerup.svg';
            powerUpElement.appendChild(icon);
            
            const label = document.createElement('span');
            label.textContent = powerUp.type;
            powerUpElement.appendChild(label);
            
            const timer = document.createElement('div');
            timer.className = 'power-up-timer';
            
            const fill = document.createElement('div');
            fill.className = 'power-up-fill';
            fill.style.width = `${percentage}%`;
            
            timer.appendChild(fill);
            powerUpElement.appendChild(timer);
            
            container.appendChild(powerUpElement);
        });
    }
    
    // Start game
    function startGame() {
        if (game.started) return;
        
        game.started = true;
        game.gameOver = false;
        document.getElementById('startOverlay').style.display = 'none';
        
        // Create player
        game.player = new Player();
        
        // Reset game variables
        game.score = 0;
        game.lives = 3;
        game.level = 1;
        game.enemies = [];
        game.bullets = [];
        game.powerUps = [];
        game.asteroids = [];
        game.activePowerUps = [];
        game.explosions = [];
        game.frameCount = 0;
        game.gameTime = 0;
        
        // Start game loop
        game.lastUpdateTime = performance.now();
        gameLoop();
        
        // Update stats
        updateGameStats();
    }
    
    // Game loop
    function gameLoop(currentTime) {
        if (game.gameOver) return;
        
        // Calculate delta time
        if (!game.lastUpdateTime) {
            game.lastUpdateTime = currentTime;
        }
        
        const deltaTime = currentTime - game.lastUpdateTime;
        game.lastUpdateTime = currentTime;
        game.gameTime += deltaTime;
        
        // Clear canvas
        game.ctx.clearRect(0, 0, game.canvas.width, game.canvas.height);
        
        // Draw stars background
        drawStars();
        
        // Update frame counter
        game.frameCount++;
        
        // Spawn enemies
        if (game.frameCount % Math.max(10, game.enemySpawnRate - game.level * 5) === 0) {
            spawnEnemy();
        }
        
        // Spawn asteroids
        if (game.frameCount % Math.max(30, game.asteroidSpawnRate - game.level * 3) === 0) {
            game.asteroids.push(new Asteroid());
        }
        
        // Spawn power-ups
        if (game.frameCount % game.powerUpSpawnRate === 0) {
            if (Math.random() < 0.3) {
                const x = Math.random() * (game.canvas.width - 25);
                game.powerUps.push(new PowerUp(x, -25));
            }
        }
        
        // Level up check
        if (game.score >= game.level * 100) {
            game.level++;
            updateGameStats();
        }
        
        // Update power-ups duration
        for (let i = game.activePowerUps.length - 1; i >= 0; i--) {
            if (game.gameTime >= game.activePowerUps[i].endTime) {
                // Power-up expired
                const type = game.activePowerUps[i].type;
                
                if (['double', 'triple', 'laser'].includes(type)) {
                    game.player.bulletType = 'normal';
                }
                
                game.activePowerUps.splice(i, 1);
                updatePowerUpDisplay();
            }
        }
        
        // Update player
        game.player.update();
        
        // Update bullets
        for (let i = game.bullets.length - 1; i >= 0; i--) {
            if (game.bullets[i].update()) {
                game.bullets.splice(i, 1);
                continue;
            }
            
            // Check collision with enemies
            for (let j = game.enemies.length - 1; j >= 0; j--) {
                if (checkCollision(game.bullets[i], game.enemies[j])) {
                    // Handle bullet hit
                    if (game.enemies[j].takeDamage(game.bullets[i].damage)) {
                        // Create explosion
                        game.explosions.push(new Explosion(
                            game.enemies[j].x + game.enemies[j].width / 2,
                            game.enemies[j].y + game.enemies[j].height / 2,
                            game.enemies[j].width + 20
                        ));
                        
                        game.enemies.splice(j, 1);
                    }
                    
                    // Remove bullet
                    game.bullets.splice(i, 1);
                    break;
                }
            }
            
            // Check collision with asteroids (if bullet still exists)
            if (i < game.bullets.length) {
                for (let j = game.asteroids.length - 1; j >= 0; j--) {
                    if (checkCollision(game.bullets[i], game.asteroids[j])) {
                        // Handle bullet hit
                        if (game.asteroids[j].takeDamage(game.bullets[i].damage)) {
                            // Create explosion
                            game.explosions.push(new Explosion(
                                game.asteroids[j].x + game.asteroids[j].size / 2,
                                game.asteroids[j].y + game.asteroids[j].size / 2,
                                game.asteroids[j].size + 10
                            ));
                            
                            game.asteroids.splice(j, 1);
                        }
                        
                        // Remove bullet
                        game.bullets.splice(i, 1);
                        break;
                    }
                }
            }
        }
        
        // Update enemies
        for (let i = game.enemies.length - 1; i >= 0; i--) {
            if (game.enemies[i].update()) {
                game.enemies.splice(i, 1);
                continue;
            }
            
            // Check collision with player
            if (checkCollision(game.enemies[i], game.player)) {
                // Check if shield is active
                const hasShield = game.activePowerUps.some(p => p.type === 'shield');
                
                if (hasShield) {
                    // Remove shield power-up
                    const shieldIndex = game.activePowerUps.findIndex(p => p.type === 'shield');
                    game.activePowerUps.splice(shieldIndex, 1);
                    updatePowerUpDisplay();
                    
                    // Create explosion
                    game.explosions.push(new Explosion(
                        game.enemies[i].x + game.enemies[i].width / 2,
                        game.enemies[i].y + game.enemies[i].height / 2,
                        game.enemies[i].width + 20
                    ));
                    
                    // Remove enemy
                    game.enemies.splice(i, 1);
                } else {
                    // Player loses a life
                    game.lives--;
                    updateGameStats();
                    
                    // Create explosion
                    game.explosions.push(new Explosion(
                        game.enemies[i].x + game.enemies[i].width / 2,
                        game.enemies[i].y + game.enemies[i].height / 2,
                        game.enemies[i].width + 20
                    ));
                    
                    // Remove enemy
                    game.enemies.splice(i, 1);
                    
                    if (game.lives <= 0) {
                        endGame();
                        break;
                    }
                }
            }
        }
        
        // Update asteroids
        for (let i = game.asteroids.length - 1; i >= 0; i--) {
            if (game.asteroids[i].update()) {
                game.asteroids.splice(i, 1);
                continue;
            }
            
            // Check collision with player
            if (checkCollision(game.asteroids[i], game.player)) {
                // Check if shield is active
                const hasShield = game.activePowerUps.some(p => p.type === 'shield');
                
                if (hasShield) {
                    // Remove shield power-up
                    const shieldIndex = game.activePowerUps.findIndex(p => p.type === 'shield');
                    game.activePowerUps.splice(shieldIndex, 1);
                    updatePowerUpDisplay();
                    
                    // Create explosion
                    game.explosions.push(new Explosion(
                        game.asteroids[i].x + game.asteroids[i].size / 2,
                        game.asteroids[i].y + game.asteroids[i].size / 2,
                        game.asteroids[i].size + 10
                    ));
                    
                    // Remove asteroid
                    game.asteroids.splice(i, 1);
                } else {
                    // Player loses a life
                    game.lives--;
                    updateGameStats();
                    
                    // Create explosion
                    game.explosions.push(new Explosion(
                        game.asteroids[i].x + game.asteroids[i].size / 2,
                        game.asteroids[i].y + game.asteroids[i].size / 2,
                        game.asteroids[i].size + 10
                    ));
                    
                    // Remove asteroid
                    game.asteroids.splice(i, 1);
                    
                    if (game.lives <= 0) {
                        endGame();
                        break;
                    }
                }
            }
        }
        
        // Update power-ups
        for (let i = game.powerUps.length - 1; i >= 0; i--) {
            if (game.powerUps[i].update()) {
                game.powerUps.splice(i, 1);
            }
        }
        
        // Update explosions
        for (let i = game.explosions.length - 1; i >= 0; i--) {
            if (game.explosions[i].update()) {
                game.explosions.splice(i, 1);
            }
        }
        
        // Draw everything
        // 1. Draw asteroids
        game.asteroids.forEach(asteroid => asteroid.draw());
        
        // 2. Draw enemies
        game.enemies.forEach(enemy => enemy.draw());
        
        // 3. Draw power-ups
        game.powerUps.forEach(powerUp => powerUp.draw());
        
        // 4. Draw player
        game.player.draw();
        
        // 5. Draw bullets
        game.bullets.forEach(bullet => bullet.draw());
        
        // 6. Draw explosions
        game.explosions.forEach(explosion => explosion.draw());
        
        // Next frame
        game.animationFrame = requestAnimationFrame(gameLoop);
    }
    
    // Spawn enemy based on game level
    function spawnEnemy() {
        let enemyType = 'normal';
        
        // Determine enemy type based on level
        const roll = Math.random();
        
        if (game.level >= 5 && roll < 0.05) {
            enemyType = 'boss';
        } else if (game.level >= 3 && roll < 0.2) {
            enemyType = 'tank';
        } else if (roll < 0.3) {
            enemyType = 'fast';
        }
        
        game.enemies.push(new Enemy(enemyType));
    }
    
    // Draw starfield background
    function drawStars() {
        // Use existing canvas or time to seed star positions
        const seed = Math.floor(game.gameTime / 1000) % 100;
        
        for (let i = 0; i < 100; i++) {
            const x = ((i * 97 + seed) * 17) % game.canvas.width;
            const y = ((i * 73 + game.frameCount * 0.1) % game.canvas.height);
            const size = (i % 3) + 1;
            const alpha = 0.5 + ((i % 5) / 10);
            
            game.ctx.fillStyle = `rgba(255, 255, 255, ${alpha})`;
            game.ctx.fillRect(x, y, size, size);
        }
    }
    
    // End game
    function endGame() {
        game.gameOver = true;
        cancelAnimationFrame(game.animationFrame);
        
        // Calculate score
        const basePoints = calculateBasePoints();
        const difficultyMultiplier = calculateDifficultyMultiplier();
        const bonusPoints = calculateBonusPoints();
        const totalPoints = Math.floor((basePoints * difficultyMultiplier) + bonusPoints);
        const xpEarned = calculateXP();
        
        // Update score display
        document.getElementById('basePoints').textContent = basePoints;
        document.getElementById('difficultyMultiplier').textContent = `x${difficultyMultiplier.toFixed(1)}`;
        document.getElementById('bonusPoints').textContent = bonusPoints;
        document.getElementById('totalPoints').textContent = totalPoints;
        document.getElementById('xpEarned').textContent = xpEarned;
        
        // Game stats
        const gameStats = {
            difficulty: game.difficulty,
            level: game.level,
            score: game.score,
            gameTime: Math.floor(game.gameTime / 1000) // seconds
        };
        
        // Submit score
        if ({{session.get('user_id', 0)}} > 0) {
            submitScore(totalPoints, gameStats, xpEarned);
        }
        
        // Show game over screen
        document.getElementById('gameOverOverlay').style.display = 'flex';
    }
    
    // Score calculation functions
    function calculateBasePoints() {
        return Math.min(Math.max(game.score, 10), 100);
    }
    
    function calculateDifficultyMultiplier() {
        return game.difficultyMultipliers[game.difficulty];
    }
    
    function calculateBonusPoints() {
        // Bonus points based on level and time survived
        const levelBonus = (game.level - 1) * 5;
        const timeBonus = Math.floor(game.gameTime / 1000 / 10);
        return Math.min(levelBonus + timeBonus, 20);
    }
    
    function calculateXP() {
        // XP calculation - Based on game time and difficulty
        const baseXP = Math.floor(game.gameTime / 1000 / 12); // 1 XP per 12 seconds
        const difficultyBonus = baseXP * (game.difficultyMultipliers[game.difficulty] - 0.5);
        return Math.floor(baseXP + difficultyBonus);
    }
    
    // Submit score to server
    function submitScore(score, gameStats, xp) {
        fetch('/save-score', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                score: score,
                game_type: 'space_shooter',
                game_stats: gameStats,
                xp_earned: xp
            })
        })
        .then(response => response.json())
        .then(data => {
            console.log('Score saved:', data);
        })
        .catch(error => {
            console.error('Error saving score:', error);
        });
    }
    
    // Event listeners
    document.addEventListener('keydown', function(e) {
        game.keys[e.code] = true;
        
        // Prevent space bar scrolling
        if (e.code === 'Space') {
            e.preventDefault();
        }
    });
    
    document.addEventListener('keyup', function(e) {
        game.keys[e.code] = false;
    });
    
    // Difficulty selection
    document.querySelectorAll('.difficulty-btn').forEach(btn => {
        btn.addEventListener('click', function() {
            game.difficulty = this.dataset.difficulty;
            
            const allBtns = document.querySelectorAll('.difficulty-btn');
            allBtns.forEach(b => b.classList.remove('selected'));
            
            this.classList.add('selected');
        });
    });
    
    // Start button
    document.getElementById('startGameBtn').addEventListener('click', startGame);
    
    // Play again button
    document.getElementById('playAgainBtn').addEventListener('click', function() {
        // Reset game and show start overlay
        game = {
            started: false,
            gameOver: false,
            difficulty: game.difficulty,
            score: 0,
            lives: 3,
            level: 1,
            player: null,
            enemies: [],
            bullets: [],
            powerUps: [],
            asteroids: [],
            activePowerUps: [],
            canvas: game.canvas,
            ctx: game.ctx,
            keys: {},
            lastUpdateTime: 0,
            frameCount: 0,
            gameTime: 0,
            enemySpawnRate: 120,
            asteroidSpawnRate: 180,
            powerUpSpawnRate: 600,
            difficultyMultipliers: game.difficultyMultipliers,
            spriteCache: game.spriteCache
        };
        
        document.getElementById('gameOverOverlay').style.display = 'none';
        document.getElementById('startOverlay').style.display = 'flex';
        updateGameStats();
    });
    
    // Return button
    document.getElementById('returnBtn').addEventListener('click', function() {
        window.location.href = '/';
    });
    
    // Window resize handler
    window.addEventListener('resize', function() {
        game.canvas.width = game.canvas.offsetWidth;
        game.canvas.height = game.canvas.offsetHeight;
        
        // Reposition player if out of bounds after resize
        if (game.player) {
            game.player.x = Math.min(game.player.x, game.canvas.width - game.player.width);
            game.player.y = Math.min(game.player.y, game.canvas.height - game.player.height);
        }
    });
    
    // Initialize game stats
    updateGameStats();
});
</script>
{% endblock %}