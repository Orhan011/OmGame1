{% extends "layout.html" %}

{% block title %}Kelime Avı - OmGame{% endblock %}

{% block head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/game-components.css') }}">
<style>
  .word-search-container {
    max-width: 800px;
    margin: 0 auto;
    padding: 20px;
  }

  .game-header {
    text-align: center;
    margin-bottom: 30px;
  }

  .game-controls {
    display: flex;
    justify-content: space-between;
    margin-bottom: 20px;
  }

  .word-search-grid {
    display: grid;
    grid-template-columns: repeat(10, 1fr);
    gap: 4px;
    margin-bottom: 30px;
    user-select: none;
  }

  .word-search-cell {
    width: 100%;
    aspect-ratio: 1;
    display: flex;
    align-items: center;
    justify-content: center;
    background-color: #f5f5f5;
    border-radius: 6px;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s;
    font-size: 1.2rem;
  }

  .word-search-cell:hover {
    background-color: #e0e0e0;
  }

  .word-search-cell.selected {
    background-color: #c3e6ff;
  }

  .word-search-cell.found {
    background-color: #aaffaa;
  }

  .word-list {
    display: flex;
    flex-wrap: wrap;
    gap: 10px;
    margin-bottom: 20px;
  }

  .word-item {
    padding: 6px 12px;
    background-color: #f0f0f0;
    border-radius: 20px;
    font-size: 0.9rem;
    transition: all 0.3s;
  }

  .word-item.found {
    background-color: #aaffaa;
    text-decoration: line-through;
  }

  .difficulty-selector {
    margin-bottom: 20px;
  }

  .stats-container {
    display: flex;
    gap: 20px;
    margin-bottom: 20px;
  }

  .stat-box {
    background-color: #f5f5f5;
    padding: 10px;
    border-radius: 8px;
    flex: 1;
    text-align: center;
  }

  .stat-value {
    font-size: 1.5rem;
    font-weight: bold;
  }

  .game-message {
    text-align: center;
    padding: 20px;
    background-color: #f0f8ff;
    border-radius: 10px;
    margin: 20px 0;
    display: none;
  }

  .game-message.visible {
    display: block;
    animation: fadeIn 0.5s;
  }

  .modal-content {
    max-width: 500px;
  }

  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  /* Responsive design */
  @media (max-width: 768px) {
    .word-search-cell {
      font-size: 1rem;
    }

    .word-search-grid {
      gap: 2px;
    }
  }

  @media (max-width: 480px) {
    .word-search-cell {
      font-size: 0.8rem;
    }
  }
</style>
{% endblock %}

{% block content %}
<div class="game-container">
  <div class="game-header">
    <h1>Kelime Avı</h1>
    <p>Harf tablosunda gizli kelimeleri bulun!</p>
  </div>

  <div class="word-search-container">
    <div class="game-controls">
      <div class="difficulty-selector">
        <label for="difficulty">Zorluk Seviyesi:</label>
        <select id="difficulty" class="form-select">
          <option value="easy">Kolay</option>
          <option value="medium" selected>Orta</option>
          <option value="hard">Zor</option>
        </select>
      </div>

      <button id="new-game-btn" class="btn btn-primary">
        <i class="fas fa-sync-alt"></i> Yeni Oyun
      </button>
    </div>

    <div class="stats-container">
      <div class="stat-box">
        <div class="stat-label">Bulunan Kelimeler</div>
        <div class="stat-value" id="found-words">0/0</div>
      </div>

      <div class="stat-box">
        <div class="stat-label">Süre</div>
        <div class="stat-value" id="timer">00:00</div>
      </div>

      <div class="stat-box">
        <div class="stat-label">Puan</div>
        <div class="stat-value" id="score">0</div>
      </div>
    </div>

    <div class="word-list" id="word-list">
      <!-- Word list will be dynamically populated -->
    </div>

    <div class="word-search-grid" id="word-search-grid">
      <!-- Grid will be dynamically populated -->
    </div>

    <div class="game-message" id="game-message">
      <!-- Message will be displayed here -->
    </div>
  </div>
</div>

<!-- Game Complete Modal -->
<div class="modal fade" id="gameCompleteModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog modal-dialog-centered">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title">Tebrikler!</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Kapat"></button>
      </div>
      <div class="modal-body">
        <div class="text-center mb-4">
          <i class="fas fa-trophy text-warning" style="font-size: 3rem;"></i>
          <h3 class="mt-3">Oyunu Tamamladınız!</h3>
          <p id="modal-stats">Tüm kelimeleri buldunuz!</p>
        </div>

        <div class="result-details">
          <div class="row g-3">
            <div class="col-6">
              <div class="result-item">
                <div class="result-label">Bulunan Kelimeler:</div>
                <div class="result-value" id="result-found-words">0/0</div>
              </div>
            </div>
            <div class="col-6">
              <div class="result-item">
                <div class="result-label">Geçen Süre:</div>
                <div class="result-value" id="result-time">00:00</div>
              </div>
            </div>
            <div class="col-6">
              <div class="result-item">
                <div class="result-label">Toplam Puan:</div>
                <div class="result-value" id="result-score">0</div>
              </div>
            </div>
            <div class="col-6">
              <div class="result-item">
                <div class="result-label">Zorluk:</div>
                <div class="result-value" id="result-difficulty">Orta</div>
              </div>
            </div>
          </div>
        </div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-primary" id="new-game-modal-btn">Yeni Oyun</button>
        <button type="button" class="btn btn-outline-primary" data-bs-dismiss="modal">Kapat</button>
      </div>
    </div>
  </div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', function() {
    // DOM Elements
    const difficultySelect = document.getElementById('difficulty');
    const newGameBtn = document.getElementById('new-game-btn');
    const newGameModalBtn = document.getElementById('new-game-modal-btn');
    const wordSearchGrid = document.getElementById('word-search-grid');
    const wordList = document.getElementById('word-list');
    const foundWordsEl = document.getElementById('found-words');
    const timerEl = document.getElementById('timer');
    const scoreEl = document.getElementById('score');
    const gameMessage = document.getElementById('game-message');

    // Result elements
    const resultFoundWordsEl = document.getElementById('result-found-words');
    const resultTimeEl = document.getElementById('result-time');
    const resultScoreEl = document.getElementById('result-score');
    const resultDifficultyEl = document.getElementById('result-difficulty');

    // Game Complete Modal
    const gameCompleteModal = new bootstrap.Modal(document.getElementById('gameCompleteModal'));

    // Game State
    let words = [];
    let grid = [];
    let gridSize = 10;
    let foundWords = 0;
    let score = 0;
    let timer = 0;
    let timerInterval;
    let selectedCells = [];
    let isDragging = false;
    let lastSelectedCell = null;
    let startTime;
    let difficultyFactor = 1;
    let gameState = { foundWords: [] }; // Oyun durumunu tutmak için nesne


    // Turkish word lists by difficulty
    const wordLists = {
      easy: [
        "KEDI", "KÖPEK", "EV", "ARABA", "SU", "AŞK", "GÜL", "KAR", "YAZ", "KIŞ", 
        "BAL", "ÇAY", "EL", "GÖZ", "DİŞ", "AYAK", "SAÇ", "YÜZ", "DİL", "TUZ"
      ],
      medium: [
        "KALEM", "KİTAP", "OKUL", "DEFTER", "SINIF", "ÖĞRENCI", "BAHÇE", "PENCERE", 
        "MASA", "SANDALYE", "TELEFON", "BİLGİSAYAR", "LAMBA", "ÇANTA", "SAAT", 
        "BARDAK", "TABAK", "KAŞIK", "ÇATAL", "BIÇAK"
      ],
      hard: [
        "MUHTEŞEM", "KÜTÜPHANE", "ÜNİVERSİTE", "MATEMATİK", "ÖĞRETMEN", "BİLGİSAYAR", 
        "ARKADAŞLIK", "TEKNOLOJİ", "ULUSLARARASI", "MİKROSKOP", "PROFESYONEL", 
        "DÜŞÜNMEK", "GELİŞTİRMEK", "PROGRAM", "HEYECAN", "MÜCADELE", "ARAŞTIRMAK", 
        "TECRÜBE", "KEŞFETMEK", "BAŞARILI"
      ]
    };

    const difficultySettings = {
      easy: { 
        gridSize: 8, 
        wordCount: 6, 
        difficultyFactor: 0.8,
        directions: ['horizontal', 'vertical']
      },
      medium: { 
        gridSize: 10, 
        wordCount: 8, 
        difficultyFactor: 1,
        directions: ['horizontal', 'vertical', 'diagonal']
      },
      hard: { 
        gridSize: 12, 
        wordCount: 10, 
        difficultyFactor: 1.5,
        directions: ['horizontal', 'vertical', 'diagonal', 'reverseHorizontal', 'reverseVertical', 'reverseDiagonal']
      }
    };

    // Initialize game
    function initGame() {
      // Reset game state
      clearInterval(timerInterval);
      words = [];
      grid = [];
      foundWords = 0;
      score = 0;
      timer = 0;
      selectedCells = [];
      gameState.foundWords = []; // Bulunan kelimeleri sıfırla

      // Get current difficulty
      const difficulty = difficultySelect.value;
      const settings = difficultySettings[difficulty];

      gridSize = settings.gridSize;
      difficultyFactor = settings.difficultyFactor;

      // Select random words for the game
      const availableWords = [...wordLists[difficulty]];
      shuffle(availableWords);
      words = availableWords.slice(0, settings.wordCount);

      // Create empty grid
      grid = Array(gridSize).fill().map(() => Array(gridSize).fill(''));

      // Place words in the grid
      words.forEach(word => {
        placeWord(word, settings.directions);
      });

      // Fill empty cells with random letters
      fillEmptyCells();

      // Update UI
      renderGrid();
      renderWordList();
      updateStats();

      // Start timer
      startTime = new Date();
      timerInterval = setInterval(updateTimer, 1000);

      // Hide message
      gameMessage.classList.remove('visible');

      // Play sound
      playSound('success');
    }

    // Update game timer
    function updateTimer() {
      const now = new Date();
      const elapsedSeconds = Math.floor((now - startTime) / 1000);
      timer = elapsedSeconds;

      const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
      const seconds = (timer % 60).toString().padStart(2, '0');

      timerEl.textContent = `${minutes}:${seconds}`;
    }

    // Update game statistics
    function updateStats() {
      foundWordsEl.textContent = `${foundWords}/${words.length}`;
      scoreEl.textContent = score;
    }

    // Place a word in the grid
    function placeWord(word, availableDirections) {
      let placed = false;
      let attempts = 0;
      const maxAttempts = 100;

      while (!placed && attempts < maxAttempts) {
        attempts++;

        // Pick random direction
        const direction = availableDirections[Math.floor(Math.random() * availableDirections.length)];

        // Pick random starting position
        let row, col;
        let valid = false;

        switch (direction) {
          case 'horizontal':
            row = Math.floor(Math.random() * gridSize);
            col = Math.floor(Math.random() * (gridSize - word.length + 1));
            valid = checkWordFit(word, row, col, 0, 1);
            break;
          case 'reverseHorizontal':
            row = Math.floor(Math.random() * gridSize);
            col = Math.floor(Math.random() * (gridSize - word.length + 1)) + word.length - 1;
            valid = checkWordFit(word, row, col, 0, -1);
            break;
          case 'vertical':
            row = Math.floor(Math.random() * (gridSize - word.length + 1));
            col = Math.floor(Math.random() * gridSize);
            valid = checkWordFit(word, row, col, 1, 0);
            break;
          case 'reverseVertical':
            row = Math.floor(Math.random() * (gridSize - word.length + 1)) + word.length - 1;
            col = Math.floor(Math.random() * gridSize);
            valid = checkWordFit(word, row, col, -1, 0);
            break;
          case 'diagonal':
            row = Math.floor(Math.random() * (gridSize - word.length + 1));
            col = Math.floor(Math.random() * (gridSize - word.length + 1));
            valid = checkWordFit(word, row, col, 1, 1);
            break;
          case 'reverseDiagonal':
            row = Math.floor(Math.random() * (gridSize - word.length + 1));
            col = Math.floor(Math.random() * (gridSize - word.length + 1)) + word.length - 1;
            valid = checkWordFit(word, row, col, 1, -1);
            break;
        }

        if (valid) {
          // Place the word
          placeWordInGrid(word, row, col, direction);
          placed = true;
        }
      }

      return placed;
    }

    // Check if a word fits at the given position and direction
    function checkWordFit(word, row, col, rowChange, colChange) {
      for (let i = 0; i < word.length; i++) {
        const currRow = row + i * rowChange;
        const currCol = col + i * colChange;

        // Check bounds
        if (currRow < 0 || currRow >= gridSize || currCol < 0 || currCol >= gridSize) {
          return false;
        }

        // Check if cell is empty or has the same letter
        if (grid[currRow][currCol] !== '' && grid[currRow][currCol] !== word[i]) {
          return false;
        }
      }

      return true;
    }

    // Place a word in the grid at the specified position and direction
    function placeWordInGrid(word, row, col, direction) {
      let rowChange = 0;
      let colChange = 0;

      switch (direction) {
        case 'horizontal':
          colChange = 1;
          break;
        case 'reverseHorizontal':
          colChange = -1;
          break;
        case 'vertical':
          rowChange = 1;
          break;
        case 'reverseVertical':
          rowChange = -1;
          break;
        case 'diagonal':
          rowChange = 1;
          colChange = 1;
          break;
        case 'reverseDiagonal':
          rowChange = 1;
          colChange = -1;
          break;
      }

      for (let i = 0; i < word.length; i++) {
        const currRow = row + i * rowChange;
        const currCol = col + i * colChange;
        grid[currRow][currCol] = word[i];
      }
    }

    // Fill empty cells with random letters
    function fillEmptyCells() {
      const turkishLetters = 'ABCÇDEFGĞHIİJKLMNOÖPRSŞTUÜVYZ';

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          if (grid[i][j] === '') {
            const randomIndex = Math.floor(Math.random() * turkishLetters.length);
            grid[i][j] = turkishLetters[randomIndex];
          }
        }
      }
    }

    // Render the grid
    function renderGrid() {
      wordSearchGrid.innerHTML = '';

      for (let i = 0; i < gridSize; i++) {
        for (let j = 0; j < gridSize; j++) {
          const cell = document.createElement('div');
          cell.className = 'word-search-cell';
          cell.dataset.row = i;
          cell.dataset.col = j;
          cell.textContent = grid[i][j];

          // Add event listeners
          cell.addEventListener('mousedown', handleCellMouseDown);
          cell.addEventListener('mouseover', handleCellMouseOver);
          cell.addEventListener('touchstart', handleCellTouchStart, { passive: true });
          cell.addEventListener('touchmove', handleCellTouchMove, { passive: true });

          wordSearchGrid.appendChild(cell);
        }
      }

      // Set grid columns based on grid size
      wordSearchGrid.style.gridTemplateColumns = `repeat(${gridSize}, 1fr)`;

      // Add document-level mouse up event
      document.addEventListener('mouseup', handleMouseUp);
      document.addEventListener('touchend', handleTouchEnd);
    }

    // Render the word list
    function renderWordList() {
      wordList.innerHTML = '';

      words.forEach(word => {
        const wordItem = document.createElement('div');
        wordItem.className = 'word-item';
        wordItem.dataset.word = word;
        wordItem.textContent = word;
        wordList.appendChild(wordItem);
      });
    }

    // Handle cell mouse down
    function handleCellMouseDown(e) {
      e.preventDefault();
      const row = parseInt(this.dataset.row);
      const col = parseInt(this.dataset.col);

      // Start selection
      isDragging = true;
      selectedCells = [{ row, col, element: this }];
      this.classList.add('selected');
      lastSelectedCell = { row, col };
    }

    // Handle cell mouse over
    function handleCellMouseOver(e) {
      e.preventDefault();

      if (!isDragging) return;

      const row = parseInt(this.dataset.row);
      const col = parseInt(this.dataset.col);

      // Ensure we're selecting in a straight line (horizontal, vertical, or diagonal)
      if (!isValidSelection(lastSelectedCell.row, lastSelectedCell.col, row, col)) {
        return;
      }

      // Check if cell is already selected
      const alreadySelected = selectedCells.some(cell => cell.row === row && cell.col === col);

      if (!alreadySelected) {
        // Add cell to selection
        selectedCells.push({ row, col, element: this });
        this.classList.add('selected');
        lastSelectedCell = { row, col };
      }
    }

    // Handle touch start
    function handleCellTouchStart(e) {
      const touch = e.touches[0];
      const element = document.elementFromPoint(touch.clientX, touch.clientY);

      if (element && element.classList.contains('word-search-cell')) {
        const row = parseInt(element.dataset.row);
        const col = parseInt(element.dataset.col);

        // Start selection
        isDragging = true;
        selectedCells = [{ row, col, element }];
        element.classList.add('selected');
        lastSelectedCell = { row, col };
      }
    }

    // Handle touch move
    function handleCellTouchMove(e) {
      if (!isDragging) return;

      const touch = e.touches[0];
      const element = document.elementFromPoint(touch.clientX, touch.clientY);

      if (element && element.classList.contains('word-search-cell')) {
        const row = parseInt(element.dataset.row);
        const col = parseInt(element.dataset.col);

        // Check if this is a new cell
        const alreadySelected = selectedCells.some(cell => cell.row === row && cell.col === col);

        if (!alreadySelected && isValidSelection(lastSelectedCell.row, lastSelectedCell.col, row, col)) {
          // Add cell to selection
          selectedCells.push({ row, col, element });
          element.classList.add('selected');
          lastSelectedCell = { row, col };
        }
      }
    }

    // Handle mouse up / touch end
    function handleMouseUp() {
      if (isDragging) {
        checkSelectedWord();
        resetSelection();
      }
    }

    function handleTouchEnd() {
      if (isDragging) {
        checkSelectedWord();
        resetSelection();
      }
    }

    // Check if the selected cells form a valid word
    function checkSelectedWord() {
      if (selectedCells.length < 2) return;

      // Extract the letters from selected cells
      let selectedWord = '';
      selectedCells.forEach(cell => {
        selectedWord += grid[cell.row][cell.col];
      });

      // Check if the word is in our word list
      const wordIndex = words.indexOf(selectedWord);

      if (wordIndex !== -1) {
        // Word found!
        foundWords++;
        gameState.foundWords.push(selectedWord); // Bulunan kelimeyi ekle

        // Calculate score based on word length and difficulty
        const wordScore = selectedWord.length * 10 * difficultyFactor + checkTimeBonus(); // Zaman bonusunu ekle
        score += wordScore;

        // Mark cells as found
        selectedCells.forEach(cell => {
          cell.element.classList.add('found');
        });

        // Mark word as found in the list
        const wordItems = document.querySelectorAll('.word-item');
        wordItems.forEach(item => {
          if (item.dataset.word === selectedWord) {
            item.classList.add('found');
          }
        });

        // Play sound
        playSound('correct');

        // Show message
        showMessage(`"${selectedWord}" kelimesini buldunuz! +${wordScore} puan kazandınız.`, 'success');

        // Update stats
        updateStats();
        updateStreak(); // Streak güncelle

        // Check if all words are found
        if (foundWords === words.length) {
          gameComplete();
        }
      } else {
        // Wrong word
        playSound('wrong');
      }
    }

    // Reset the selection
    function resetSelection() {
      selectedCells.forEach(cell => {
        // Remove selected class but keep found class
        if (!cell.element.classList.contains('found')) {
          cell.element.classList.remove('selected');
        }
      });

      selectedCells = [];
      isDragging = false;
      lastSelectedCell = null;
    }

    // Check if a move is valid (straight line)
    function isValidSelection(startRow, startCol, endRow, endCol) {
      // Check if cells are adjacent
      const rowDiff = Math.abs(endRow - startRow);
      const colDiff = Math.abs(endCol - startCol);

      // Must be in straight line (horizontal, vertical, diagonal)
      if (
        (rowDiff === 0 && colDiff === 1) || // Horizontal
        (rowDiff === 1 && colDiff === 0) || // Vertical
        (rowDiff === 1 && colDiff === 1)    // Diagonal
      ) {
        return true;
      }

      // Check if it continues in the same direction as the current selection
      if (selectedCells.length >= 2) {
        const prevRow = selectedCells[selectedCells.length - 2].row;
        const prevCol = selectedCells[selectedCells.length - 2].col;

        const currRow = selectedCells[selectedCells.length - 1].row;
        const currCol = selectedCells[selectedCells.length - 1].col;

        // Direction from prev to current
        const dirRow = currRow - prevRow;
        const dirCol = currCol - prevCol;

        // Direction from current to end
        const newDirRow = endRow - currRow;
        const newDirCol = endCol - currCol;

        // Must continue in same direction
        return dirRow === newDirRow && dirCol === newDirCol;
      }

      return false;
    }

    // Show a message
    function showMessage(text, type = 'info') {
      gameMessage.textContent = text;
      gameMessage.className = `game-message visible ${type}`;

      // Hide after 3 seconds
      setTimeout(() => {
        gameMessage.classList.remove('visible');
      }, 3000);
    }

    // Game complete
    function gameComplete() {
      clearInterval(timerInterval);

      // Update results
      const minutes = Math.floor(timer / 60).toString().padStart(2, '0');
      const seconds = (timer % 60).toString().padStart(2, '0');

      resultFoundWordsEl.textContent = `${foundWords}/${words.length}`;
      resultTimeEl.textContent = `${minutes}:${seconds}`;
      resultScoreEl.textContent = score;
      resultDifficultyEl.textContent = difficultySelect.options[difficultySelect.selectedIndex].text;

      // Show modal
      setTimeout(() => {
        gameCompleteModal.show();
        playSound('game-complete');
      }, 500);

      // Post score to server
      saveScore();
    }

    // Save score to server
    function saveScore() {
      // Create score data
      const scoreData = {
        game_type: 'word_search',
        difficulty: difficultySelect.value,
        score: score,
        time_taken: timer,
        details: {
          words_found: foundWords,
          total_words: words.length
        }
      };

      // Send score to server
      fetch('/api/save_score', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(scoreData)
      })
      .then(response => response.json())
      .then(data => {
        console.log('Score saved:', data);
      })
      .catch(error => {
        console.error('Error saving score:', error);
      });
    }

    // Utility to shuffle array
    function shuffle(array) {
      for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [array[i], array[j]] = [array[j], array[i]];
      }
      return array;
    }

    // Play sound
    function playSound(soundName) {
      try {
        const audio = new Audio(`/static/sounds/${soundName}.mp3`);
        audio.play().catch(error => {
          console.log('Sound playback prevented', error);
        });
      } catch (error) {
        console.error('Error playing sound:', error);
      }
    }

    // Yeni özellikler için ek değişkenler
    let hints = 3; // İpucu sayısı
    let streakCount = 0; // Arka arkaya bulunan kelime sayısı
    let timeBonus = 0; // Zaman bonusu

    // Hint butonu oluştur
    const hintButton = document.createElement('button');
    hintButton.id = 'hint-btn';
    hintButton.className = 'btn btn-warning';
    hintButton.innerHTML = `<i class="fas fa-lightbulb"></i> İpucu (${hints})`;

    // Hint butonunu game controls'a ekle
    const gameControls = document.querySelector('.game-controls');
    if (gameControls) {
      gameControls.appendChild(hintButton);
    }

    // Hint fonksiyonu
    function showHint() {
      if (hints <= 0) {
        showMessage("İpucu hakkınız kalmadı!", "warning");
        return;
      }

      // Henüz bulunmamış kelimelerden rastgele birini seç
      const unFoundWords = words.filter(word => !gameState.foundWords.includes(word));

      if (unFoundWords.length === 0) {
        showMessage("Tüm kelimeleri zaten buldunuz!", "info");
        return;
      }

      // Rastgele bir kelime seç
      const randomWord = unFoundWords[Math.floor(Math.random() * unFoundWords.length)];

      // İpucu mesajı göster
      showMessage(`İpucu: "${randomWord}" kelimesinin ilk harfi "${randomWord[0]}"`, "info");

      // İpucu sayısını azalt
      hints--;
      hintButton.innerHTML = `<i class="fas fa-lightbulb"></i> İpucu (${hints})`;

      // İpucu sesini çal
      playSound('hint');
    }

    // Hint butonu event listener
    hintButton.addEventListener('click', showHint);

    // Oyun başlatıldığında streak'i ve ipuçlarını sıfırla
    function resetGameStats() {
      hints = 3;
      streakCount = 0;
      timeBonus = 0;

      // Hint butonunu güncelle
      hintButton.innerHTML = `<i class="fas fa-lightbulb"></i> İpucu (${hints})`;
    }

    // Kelime bulunduğunda streak sayısını arttır ve bonus hesapla
    function updateStreak() {
      streakCount++;

      // Her 3 kelime streak'i için ekstra puan ve ipucu
      if (streakCount % 3 === 0) {
        score += 50; // Bonus puan
        hints++; // Ekstra ipucu
        hintButton.innerHTML = `<i class="fas fa-lightbulb"></i> İpucu (${hints})`;
        showMessage(`3 kelime serisi! +50 bonus puan ve 1 ipucu kazandınız!`, "success");
      }
    }

    // Zamanı kontrol eden fonksiyon
    function checkTimeBonus() {
      // İlk 60 saniye içinde bulunan her kelime için bonus puan
      if (timer < 60) {
        timeBonus = 10;
        return timeBonus;
      }
      return 0;
    }

    // Event Listeners
    newGameBtn.addEventListener('click', () => {
      playSound('click');
      resetGameStats();
      initGame();
    });

    newGameModalBtn.addEventListener('click', () => {
      playSound('click');
      gameCompleteModal.hide();
      resetGameStats();
      initGame();
    });

    difficultySelect.addEventListener('change', () => {
      // Reset and initialize game when difficulty changes
      playSound('click');
      resetGameStats();
      initGame();
    });

    // Ses efektlerini çalmak için fonksiyon
    function playSound(soundName) {
      tryconst audio = new Audio(`/static/sounds/${soundName}.mp3`);
        audio.play().catch(error => {
          console.log('Sound playback prevented', error);
        });
      } catch (error) {
        console.error('Error playing sound:', error);
      }
    }

    // Mobil dostu bir deneyim için dokunma desteğini geliştir
    function enhanceTouchSupport() {
      // Dokunma hareketleri için threshold değerleri
      const touchThreshold = 20; // piksel
      let startTouchX, startTouchY;

      // Dokunma başladığında koordinatları kaydet
      wordSearchGrid.addEventListener('touchstart', function(e) {
        startTouchX = e.touches[0].clientX;
        startTouchY = e.touches[0].clientY;
      });

      // Dokunma bittiğinde hareketin yönünü kontrol et
      wordSearchGrid.addEventListener('touchend', function(e) {
        // Hareket mesafesini hesapla
        const deltaX = e.changedTouches[0].clientX - startTouchX;
        const deltaY = e.changedTouches[0].clientY - startTouchY;

        // Hareket yeterince büyükse yönlendirme yap
        if (Math.abs(deltaX) > touchThreshold || Math.abs(deltaY) > touchThreshold) {
          // Yatay kaydırma
          if (Math.abs(deltaX) > Math.abs(deltaY)) {
            if (deltaX > 0) {
              // Sağa kaydırma - yeni oyun başlat
              resetGameStats();
              initGame();
            }
          }
        }
      });
    }

    // Responsive tasarımı güçlendir
    function enhanceResponsiveness() {
      // Ekran boyutunu kontrol et ve grid boyutunu ayarla
      function adjustGridSize() {
        const windowWidth = window.innerWidth;

        if (windowWidth <= 576) { // Mobil
          document.documentElement.style.setProperty('--cell-font-size', '0.9rem');
        } else if (windowWidth <= 768) { // Tablet
          document.documentElement.style.setProperty('--cell-font-size', '1.1rem');
        } else { // Desktop
          document.documentElement.style.setProperty('--cell-font-size', '1.3rem');
        }
      }

      // İlk yükleme ve ekran boyutu değişikliklerinde grid boyutunu ayarla
      adjustGridSize();
      window.addEventListener('resize', adjustGridSize);
    }

    // Initialize game with enhanced features
    resetGameStats();
    initGame();
    enhanceTouchSupport();
    enhanceResponsiveness();

    // Modernizasyon uygula
    try {
      if (typeof applyGeneralModernization === 'function') {
        applyGeneralModernization();
      }
      console.log("Kelime Avı oyunu modernize edildi ve geliştirildi.");
    } catch (e) {
      console.log("Modernizasyon uygulanamadı:", e);
    }
  });
</script>
{% endblock %}