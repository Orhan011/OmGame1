{% extends "layout.html" %}

{% block title %}Snake{% endblock %}

{% block content %}
<div class="game-container">
  <div class="snake-container">
    <div class="game-stats">
      <div>Skor: <span id="score">0</span></div>
      <div>En Yüksek Skor: <span id="highScore">0</span></div>
    </div>
    <canvas id="snakeCanvas" width="400" height="400"></canvas>
    <div class="game-controls">
      <button id="startGame" class="btn btn-primary">Başlat</button>
      <button id="pauseGame" class="btn btn-warning">Duraklat</button>
    </div>
  </div>
</div>
{% endblock %}

{% block styles %}
<style>
.snake-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 15px;
}

.game-stats {
  font-size: 20px;
  color: var(--accent-color);
  display: flex;
  gap: 20px;
}

#snakeCanvas {
  background: rgba(0, 0, 0, 0.8);
  border: 2px solid var(--accent-color);
  border-radius: 10px;
}

.game-controls {
  display: flex;
  gap: 10px;
}
</style>
{% endblock %}

{% block scripts %}
<script>
const canvas = document.getElementById('snakeCanvas');
const ctx = canvas.getContext('2d');
const scoreElement = document.getElementById('score');
const highScoreElement = document.getElementById('highScore');
const startBtn = document.getElementById('startGame');
const pauseBtn = document.getElementById('pauseGame');

const GRID_SIZE = 20;
const GRID_COUNT = canvas.width / GRID_SIZE;

let snake = [];
let food = {};
let direction = 'right';
let score = 0;
let highScore = 0;
let gameLoop = null;
let isPaused = false;

function initGame() {
  snake = [
    {x: 3, y: 1},
    {x: 2, y: 1},
    {x: 1, y: 1}
  ];
  direction = 'right';
  score = 0;
  generateFood();
  updateScore();
}

function generateFood() {
  food = {
    x: Math.floor(Math.random() * GRID_COUNT),
    y: Math.floor(Math.random() * GRID_COUNT)
  };

  // Make sure food doesn't spawn on snake
  while (snake.some(segment => segment.x === food.x && segment.y === food.y)) {
    food = {
      x: Math.floor(Math.random() * GRID_COUNT),
      y: Math.floor(Math.random() * GRID_COUNT)
    };
  }
}

function draw() {
  // Clear canvas
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw snake
  ctx.fillStyle = '#0F0';
  snake.forEach((segment, i) => {
    ctx.fillRect(
      segment.x * GRID_SIZE,
      segment.y * GRID_SIZE,
      GRID_SIZE - 2,
      GRID_SIZE - 2
    );
  });

  // Draw food
  ctx.fillStyle = '#F00';
  ctx.fillRect(
    food.x * GRID_SIZE,
    food.y * GRID_SIZE,
    GRID_SIZE - 2,
    GRID_SIZE - 2
  );
}

function moveSnake() {
  const head = {x: snake[0].x, y: snake[0].y};

  switch(direction) {
    case 'up':
      head.y--;
      break;
    case 'down':
      head.y++;
      break;
    case 'left':
      head.x--;
      break;
    case 'right':
      head.x++;
      break;
  }

  // Check collision with walls
  if (head.x < 0 || head.x >= GRID_COUNT ||
      head.y < 0 || head.y >= GRID_COUNT) {
    gameOver();
    return;
  }

  // Check collision with self
  if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
    gameOver();
    return;
  }

  snake.unshift(head);

  // Check if snake ate food
  if (head.x === food.x && head.y === food.y) {
    score += 10;
    updateScore();
    generateFood();
  } else {
    snake.pop();
  }
}

function gameOver() {
  if (score > highScore) {
    highScore = score;
    highScoreElement.textContent = highScore;
    saveScore(score);
  }
  cancelAnimationFrame(gameLoop);
  gameLoop = null;
  alert('Oyun Bitti! Skorunuz: ' + score);
}

function updateScore() {
  scoreElement.textContent = score;
}

function update() {
  if (!isPaused) {
    moveSnake();
    draw();
  }
  gameLoop = requestAnimationFrame(update);
}

function saveScore(score) {
  fetch('/api/save-score', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
    },
    body: JSON.stringify({
      score: score,
      gameType: 'snake'
    })
  });
}

document.addEventListener('keydown', (e) => {
  if (!isPaused) {
    switch(e.key) {
      case 'ArrowUp':
        if (direction !== 'down') direction = 'up';
        break;
      case 'ArrowDown':
        if (direction !== 'up') direction = 'down';
        break;
      case 'ArrowLeft':
        if (direction !== 'right') direction = 'left';
        break;
      case 'ArrowRight':
        if (direction !== 'left') direction = 'right';
        break;
    }
  }
});

startBtn.addEventListener('click', () => {
  if (!gameLoop) {
    initGame();
    update();
  }
});

pauseBtn.addEventListener('click', () => {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? 'Devam Et' : 'Duraklat';
});

// Initial setup
initGame();
</script>
{% endblock %}