{% extends 'layout.html' %}

{% block title %}Modern Tetris - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="tetris-modern-container">
    <div class="tetris-modern-sidebar">
      <div class="tetris-modern-stats">
        <h2 class="tetris-modern-title">Tetris</h2>
        <div class="tetris-modern-score">
          <div class="tetris-modern-stat">
            <span class="stat-label">Skor</span>
            <span id="score" class="stat-value">0</span>
          </div>
          <div class="tetris-modern-stat">
            <span class="stat-label">Seviye</span>
            <span id="level" class="stat-value">1</span>
          </div>
          <div class="tetris-modern-stat">
            <span class="stat-label">Çizgiler</span>
            <span id="lines" class="stat-value">0</span>
          </div>
        </div>
      </div>

      <div class="tetris-modern-next">
        <h3>Sonraki Parça</h3>
        <canvas id="next-piece" width="60" height="60"></canvas> </div>

      <div class="tetris-modern-controls">
        <button id="start-button" class="btn-modern primary">
          <i class="fas fa-play"></i> Başla
        </button>
        <button id="pause-button" class="btn-modern secondary" disabled>
          <i class="fas fa-pause"></i> Duraklat
        </button>
        <button id="restart-button" class="btn-modern danger">
          <i class="fas fa-redo"></i> Yeniden Başlat
        </button>
      </div>

      <div class="tetris-modern-help">
        <h3>Kontroller</h3>
        <div class="control-item">
          <div class="key">←</div>
          <span>Sola Hareket</span>
        </div>
        <div class="control-item">
          <div class="key">→</div>
          <span>Sağa Hareket</span>
        </div>
        <div class="control-item">
          <div class="key">↑</div>
          <span>Döndür</span>
        </div>
        <div class="control-item">
          <div class="key">↓</div>
          <span>Hızlı Düşür</span>
        </div>
        <div class="control-item">
          <div class="key">Space</div>
          <span>Anında Düşür</span>
        </div>
      </div>
    </div>

    <div class="tetris-modern-board">
      <canvas id="tetris-canvas"></canvas>
      <div class="tetris-control-buttons">
        <button class="control-button" id="rotate-button">
          <i class="fas fa-redo"></i>
        </button>
        <button class="control-button" id="left-button">
          <i class="fas fa-arrow-left"></i>
        </button>
        <button class="control-button" id="right-button">
          <i class="fas fa-arrow-right"></i>
        </button>
        <button class="control-button" id="down-button">
          <i class="fas fa-arrow-down"></i>
        </button>
      </div>
      <div id="game-overlay" class="tetris-modern-overlay">
        <div id="start-screen" class="overlay-content">
          <h2>Tetris</h2>
          <p>Klasik Tetris oyununa hoş geldiniz!</p>
          <button class="btn-modern primary">Oyuna Başla</button>
        </div>

        <div id="pause-screen" class="overlay-content" style="display: none;">
          <h2>Oyun Duraklatıldı</h2>
          <button class="btn-modern primary">Devam Et</button>
        </div>

        <div id="gameover-screen" class="overlay-content" style="display: none;">
          <h2>Oyun Bitti!</h2>
          <div class="final-score">
            <span>Final Skoru</span>
            <span id="final-score">0</span>
          </div>
          <button class="btn-modern primary">Tekrar Oyna</button>
        </div>
      </div>
    </div>

    <div id="mobile-controls" class="tetris-modern-mobile-controls">
      <button id="mobile-left" class="mobile-btn">
        <i class="fas fa-arrow-left"></i>
      </button>
      <button id="mobile-rotate" class="mobile-btn">
        <i class="fas fa-redo"></i>
      </button>
      <button id="mobile-right" class="mobile-btn">
        <i class="fas fa-arrow-right"></i>
      </button>
      <button id="mobile-down" class="mobile-btn">
        <i class="fas fa-arrow-down"></i>
      </button>
    </div>
  </div>
</div>

<style>
.tetris-modern-container {
  display: flex;
  gap: 2rem;
  padding: 2rem;
  max-width: 1200px;
  margin: 0 auto;
  flex-wrap: wrap;
  justify-content: center;
}

.tetris-modern-sidebar {
  flex: 1;
  min-width: 300px;
  display: flex;
  flex-direction: column;
  gap: 2rem;
}

.tetris-modern-stats {
  background: rgba(30, 30, 60, 0.8);
  border-radius: 1rem;
  padding: 1.5rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
}

.tetris-modern-title {
  font-size: 2rem;
  color: var(--accent-color);
  margin-bottom: 1.5rem;
  text-align: center;
}

.tetris-modern-score {
  display: flex;
  flex-direction: column;
  gap: 1rem;
}

.tetris-modern-stat {
  display: flex;
  justify-content: space-between;
  align-items: center;
  background: rgba(40, 40, 80, 0.5);
  padding: 1rem;
  border-radius: 0.5rem;
}

.stat-label {
  color: rgba(255, 255, 255, 0.8);
  font-size: 1rem;
}

.stat-value {
  color: var(--accent-color);
  font-size: 1.5rem;
  font-weight: bold;
}

.tetris-modern-next {
  background: rgba(30, 30, 60, 0.8);
  border-radius: 1rem;
  padding: 1.5rem;
  text-align: center;
}

.tetris-modern-next h3 {
  color: rgba(255, 255, 255, 0.9);
  margin-bottom: 1rem;
}

.tetris-modern-controls {
  display: flex;
  flex-direction: column;
  gap: 0.75rem;
}

.btn-modern {
  padding: 1rem;
  border: none;
  border-radius: 0.5rem;
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.2s ease;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 0.5rem;
}

.btn-modern.primary {
  background: var(--accent-color);
  color: white;
}

.btn-modern.secondary {
  background: rgba(106, 90, 205, 0.3);
  color: rgba(255, 255, 255, 0.9);
}

.btn-modern.danger {
  background: rgba(220, 53, 69, 0.3);
  color: rgba(255, 255, 255, 0.9);
}

.btn-modern:hover {
  transform: translateY(-2px);
  filter: brightness(1.1);
}

.btn-modern:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.tetris-modern-help {
  background: rgba(30, 30, 60, 0.8);
  border-radius: 1rem;
  padding: 1.5rem;
}

.tetris-modern-help h3 {
  color: rgba(255, 255, 255, 0.9);
  margin-bottom: 1rem;
  text-align: center;
}

.control-item {
  display: flex;
  align-items: center;
  gap: 1rem;
  margin-bottom: 0.75rem;
}

.key {
  background: rgba(106, 90, 205, 0.3);
  padding: 0.5rem;
  border-radius: 0.25rem;
  min-width: 2.5rem;
  text-align: center;
  color: var(--accent-color);
  font-size: 0.9rem;
}

.tetris-modern-board {
  flex: 2;
  min-width: 300px;
  position: relative;
  background: rgba(30, 30, 60, 0.8);
  border-radius: 1rem;
  padding: 1rem;
  box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
  display: flex;
  justify-content: center;
  margin-right: 80px;
}

.tetris-control-buttons {
  position: absolute;
  right: -70px;
  top: 50%;
  transform: translateY(-50%);
  display: flex;
  flex-direction: column;
  gap: 15px;
  background: rgba(30, 30, 60, 0.4);
  padding: 10px;
  border-radius: 10px;
}

.control-button {
  width: 50px;
  height: 50px;
  border-radius: 50%;
  border: none;
  background: rgba(106, 90, 205, 0.3);
  color: white;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  transition: all 0.2s;
}

.control-button:active {
  background: rgba(106, 90, 205, 0.5);
  transform: scale(0.95);
}

#tetris-canvas {
  width: 100%;
  height: auto;
  display: block;
  border-radius: 0.5rem;
}

.rotate-button {
  position: absolute;
  top: 1rem;
  right: 1rem;
  background-color: rgba(106, 90, 205, 0.3);
  border: none;
  border-radius: 50%;
  width: 3rem;
  height: 3rem;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  cursor: pointer;
}


.tetris-modern-overlay {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(20, 20, 40, 0.9);
  display: flex;
  justify-content: center;
  align-items: center;
  border-radius: 1rem;
}

.overlay-content {
  text-align: center;
  padding: 2rem;
}

.overlay-content h2 {
  color: var(--accent-color);
  font-size: 2rem;
  margin-bottom: 1rem;
}

.overlay-content p {
  color: rgba(255, 255, 255, 0.8);
  margin-bottom: 2rem;
}

.final-score {
  background: rgba(40, 40, 80, 0.5);
  padding: 1.5rem;
  border-radius: 0.5rem;
  margin: 1.5rem 0;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.final-score span:first-child {
  color: rgba(255, 255, 255, 0.8);
}

.final-score span:last-child {
  color: var(--accent-color);
  font-size: 2.5rem;
  font-weight: bold;
}

.tetris-modern-mobile-controls {
  display: none;
  grid-template-columns: repeat(4, 1fr);
  gap: 1rem;
  width: 100%;
  padding: 1rem;
  margin-top: 1rem;
}

.mobile-btn {
  background: rgba(106, 90, 205, 0.3);
  border: none;
  border-radius: 50%;
  width: 3.5rem;
  height: 3.5rem;
  display: flex;
  align-items: center;
  justify-content: center;
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.25rem;
  cursor: pointer;
  transition: all 0.2s ease;
}

.mobile-btn:active {
  background: rgba(106, 90, 205, 0.5);
  transform: scale(0.95);
}

@media (max-width: 768px) {
  .tetris-modern-container {
    padding: 1rem;
    gap: 1rem;
  }

  .tetris-modern-sidebar {
    order: 2;
    min-width: 100%;
  }

  .tetris-modern-board {
    order: 1;
    min-width: 100%;
  }

  .tetris-modern-mobile-controls {
    display: grid;
    order: 3;
  }

  .tetris-modern-help {
    display: none;
  }
}

/* Animations */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

.overlay-content {
  animation: slideUp 0.3s ease-out;
}

.stat-value.updated {
  animation: pulse 0.3s ease-out;
}

@keyframes pulse {
  0% { transform: scale(1); }
  50% { transform: scale(1.1); }
  100% { transform: scale(1); }
}
</style>

<script>
document.addEventListener('DOMContentLoaded', () => {
  // Canvas setup
  const canvas = document.getElementById('tetris-canvas');
  const ctx = canvas.getContext('2d');
  const nextCanvas = document.getElementById('next-piece');
  const nextCtx = nextCanvas.getContext('2d');

  // Game constants
  const COLS = 10;
  const ROWS = 20;
  const BLOCK_SIZE = 30;
  const COLORS = [
    null,
    '#FF0D72', // I
    '#0DC2FF', // J
    '#0DFF72', // L
    '#F538FF', // O
    '#FF8E0D', // S
    '#FFE138', // T
    '#FF1C0D'  // Z
  ];

  // Set canvas dimensions
  canvas.width = COLS * BLOCK_SIZE;
  canvas.height = ROWS * BLOCK_SIZE;
  nextCanvas.width = 4 * BLOCK_SIZE;
  nextCanvas.height = 4 * BLOCK_SIZE;

  // Game variables
  let dropCounter = 0;
  let dropInterval = 1000;
  let lastTime = 0;
  let score = 0;
  let level = 1;
  let lines = 0;
  let gameOver = false;
  let paused = false;

  // Piece shapes
  const PIECES = [
    [
      [0, 0, 0, 0],
      [1, 1, 1, 1],
      [0, 0, 0, 0],
      [0, 0, 0, 0]
    ],
    [
      [2, 0, 0],
      [2, 2, 2],
      [0, 0, 0]
    ],
    [
      [0, 0, 3],
      [3, 3, 3],
      [0, 0, 0]
    ],
    [
      [4, 4],
      [4, 4]
    ],
    [
      [0, 5, 5],
      [5, 5, 0],
      [0, 0, 0]
    ],
    [
      [0, 6, 0],
      [6, 6, 6],
      [0, 0, 0]
    ],
    [
      [7, 7, 0],
      [0, 7, 7],
      [0, 0, 0]
    ]
  ];

  // Game state
  const player = {
    pos: {x: 0, y: 0},
    matrix: null,
    score: 0
  };

  const arena = createMatrix(COLS, ROWS);

  function createMatrix(w, h) {
    const matrix = [];
    while (h--) {
      matrix.push(new Array(w).fill(0));
    }
    return matrix;
  }

  function collide(arena, player) {
    const [m, o] = [player.matrix, player.pos];
    for (let y = 0; y < m.length; ++y) {
      for (let x = 0; x < m[y].length; ++x) {
        if (m[y][x] !== 0 &&
            (arena[y + o.y] &&
            arena[y + o.y][x + o.x]) !== 0) {
          return true;
        }
      }
    }
    return false;
  }

  function merge(arena, player) {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          arena[y + player.pos.y][x + player.pos.x] = value;
        }
      });
    });
  }

  function rotate(matrix, dir) {
    for (let y = 0; y < matrix.length; ++y) {
      for (let x = 0; x < y; ++x) {
        [
          matrix[x][y],
          matrix[y][x],
        ] = [
          matrix[y][x],
          matrix[x][y],
        ];
      }
    }

    if (dir > 0) {
      matrix.forEach(row => row.reverse());
    } else {
      matrix.reverse();
    }
  }

  function playerDrop() {
    player.pos.y++;
    if (collide(arena, player)) {
      player.pos.y--;
      merge(arena, player);
      playerReset();
      arenaSweep();
      updateScore();
    }
    dropCounter = 0;
  }

  function playerMove(dir) {
    player.pos.x += dir;
    if (collide(arena, player)) {
      player.pos.x -= dir;
    }
  }

  function playerReset() {
    const pieces = 'ILJOTSZ';
    player.matrix = createPiece(pieces[pieces.length * Math.random() | 0]);
    player.pos.y = 0;
    player.pos.x = (arena[0].length / 2 | 0) -
                   (player.matrix[0].length / 2 | 0);

    if (collide(arena, player)) {
      gameOver = true;
      showGameOver();
    }
  }

  function playerRotate(dir) {
    const pos = player.pos.x;
    let offset = 1;
    rotate(player.matrix, dir);
    while (collide(arena, player)) {
      player.pos.x += offset;
      offset = -(offset + (offset > 0 ? 1 : -1));
      if (offset > player.matrix[0].length) {
        rotate(player.matrix, -dir);
        player.pos.x = pos;
        return;
      }
    }
  }

  function createPiece(type) {
    switch (type) {
      case 'I': return PIECES[0];
      case 'J': return PIECES[1];
      case 'L': return PIECES[2];
      case 'O': return PIECES[3];
      case 'S': return PIECES[4];
      case 'T': return PIECES[5];
      case 'Z': return PIECES[6];
    }
  }

  function arenaSweep() {
    let rowCount = 1;
    outer: for (let y = arena.length - 1; y > 0; --y) {
      for (let x = 0; x < arena[y].length; ++x) {
        if (arena[y][x] === 0) {
          continue outer;
        }
      }

      const row = arena.splice(y, 1)[0].fill(0);
      arena.unshift(row);
      ++y;

      score += rowCount * 100;
      rowCount *= 2;
      lines++;

      // Level up every 10 lines
      if (lines % 10 === 0) {
        level++;
        dropInterval = Math.max(100, 1000 - (level - 1) * 50);
      }
    }
  }

  function draw() {
    // Clear canvas
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    // Draw arena
    drawMatrix(arena, {x: 0, y: 0});

    // Draw current piece
    drawMatrix(player.matrix, player.pos);

    // Draw grid
    drawGrid();
  }

  function drawGrid() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;

    // Vertical lines
    for (let i = 0; i <= COLS; i++) {
      ctx.beginPath();
      ctx.moveTo(i * BLOCK_SIZE, 0);
      ctx.lineTo(i * BLOCK_SIZE, canvas.height);
      ctx.stroke();
    }

    // Horizontal lines
    for (let i = 0; i <= ROWS; i++) {
      ctx.beginPath();
      ctx.moveTo(0, i * BLOCK_SIZE);
      ctx.lineTo(canvas.width, i * BLOCK_SIZE);
      ctx.stroke();
    }
  }

  function drawMatrix(matrix, offset) {
    matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          ctx.fillStyle = COLORS[value];
          ctx.fillRect((x + offset.x) * BLOCK_SIZE,
                      (y + offset.y) * BLOCK_SIZE,
                      BLOCK_SIZE, BLOCK_SIZE);

          // Draw block border
          ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          ctx.strokeRect((x + offset.x) * BLOCK_SIZE,
                        (y + offset.y) * BLOCK_SIZE,
                        BLOCK_SIZE, BLOCK_SIZE);
        }
      });
    });
  }

  function updateScore() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
  }

  function update(time = 0) {
    if (gameOver || paused) return;

    const deltaTime = time - lastTime;
    lastTime = time;
    dropCounter += deltaTime;

    if (dropCounter > dropInterval) {
      playerDrop();
    }

    draw();
    requestAnimationFrame(update);
  }

  function showGameOver() {
    document.getElementById('final-score').textContent = score;
    document.getElementById('gameover-screen').style.display = 'block';
    document.getElementById('start-screen').style.display = 'none';
    document.getElementById('pause-screen').style.display = 'none';
  }

  // Controls
  document.addEventListener('keydown', event => {
    if (gameOver) return;

    switch (event.keyCode) {
      case 37: // Left arrow
        playerMove(-1);
        break;
      case 39: // Right arrow
        playerMove(1);
        break;
      case 40: // Down arrow
        playerDrop();
        break;
      case 38: // Up arrow
        playerRotate(1);
        break;
      case 32: // Space
        while (!collide(arena, player)) {
          player.pos.y++;
        }
        player.pos.y--;
        merge(arena, player);
        playerReset();
        arenaSweep();
        updateScore();
        break;
    }
  });

  // Touch controls
  document.getElementById('rotate-button').addEventListener('click', () => playerRotate(1));
  document.getElementById('left-button').addEventListener('click', () => playerMove(-1));
  document.getElementById('right-button').addEventListener('click', () => playerMove(1));
  document.getElementById('down-button').addEventListener('click', () => playerDrop());

  // Touch events for swipe controls
  let touchStartX = 0;
  let touchStartY = 0;

  canvas.addEventListener('touchstart', (e) => {
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
  });

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    const touchEndX = e.touches[0].clientX;
    const touchEndY = e.touches[0].clientY;
    const diffX = touchEndX - touchStartX;
    const diffY = touchEndY - touchStartY;

    if (Math.abs(diffX) > Math.abs(diffY)) {
      if (diffX > 0) {
        playerMove(1);
      } else {
        playerMove(-1);
      }
    } else {
      if (diffY > 0) {
        playerDrop();
      }
    }

    touchStartX = touchEndX;
    touchStartY = touchEndY;
  });


  // Start game
  document.getElementById('start-button').addEventListener('click', () => {
    gameOver = false;
    paused = false;
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    arena.forEach(row => row.fill(0));
    playerReset();
    updateScore();
    document.getElementById('game-overlay').style.display = 'none';
    update();
  });

  // Initialize game
  playerReset();
  updateScore();
  draw();
});
</script>
{% endblock %}