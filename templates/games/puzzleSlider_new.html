{% extends 'layout.html' %}

{% block title %}Puzzle Slider - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1 class="game-title">Puzzle Slider <span class="game-badge">Görsel Bulmaca</span></h1>
      <p class="game-description">Görsel dikkat ve mekansal becerileri geliştiren modern bulmaca oyunu.</p>
    </div>

    <div class="puzzle-app">
      <!-- Game Dashboard -->
      <div class="puzzle-dashboard">
        <div class="puzzle-stats">
          <div class="stat-card">
            <div class="stat-icon"><i class="fas fa-chart-line"></i></div>
            <div class="stat-content">
              <div class="stat-value" id="moves-count">0</div>
              <div class="stat-label">Hamleler</div>
            </div>
          </div>
          <div class="stat-card">
            <div class="stat-icon"><i class="fas fa-clock"></i></div>
            <div class="stat-content">
              <div class="stat-value" id="time-count">00:00</div>
              <div class="stat-label">Süre</div>
            </div>
          </div>
        </div>

        <div class="puzzle-difficulty">
          <div class="difficulty-label">Zorluk</div>
          <div class="difficulty-options">
            <button class="difficulty-btn active" data-size="3">3×3</button>
            <button class="difficulty-btn" data-size="4">4×4</button>
            <button class="difficulty-btn" data-size="5">5×5</button>
          </div>
        </div>
      </div>

      <!-- Game Board Area -->
      <div class="puzzle-board-area">
        <div id="puzzle-board" class="puzzle-board size-3">
          <!-- Tiles will be generated by JavaScript -->
        </div>
      </div>

      <!-- Game Controls -->
      <div class="puzzle-controls">
        <button id="shuffle-btn" class="game-btn primary">
          <i class="fas fa-random"></i>
          <span>Karıştır</span>
        </button>
        <button id="restart-btn" class="game-btn warning">
          <i class="fas fa-redo-alt"></i>
          <span>Yeniden Başlat</span>
        </button>
        <button id="hint-btn" class="game-btn info">
          <i class="fas fa-lightbulb"></i>
          <span>İpucu</span>
        </button>
        <button id="theme-btn" class="game-btn secondary">
          <i class="fas fa-palette"></i>
          <span>Tema</span>
        </button>
      </div>

      <!-- Theme Selector (initially hidden) -->
      <div id="theme-panel" class="theme-panel">
        <div class="theme-header">
          <h3>Tema Seçimi</h3>
          <button id="close-theme-btn" class="close-btn"><i class="fas fa-times"></i></button>
        </div>
        <div class="theme-options">
          <div class="theme-option" data-theme="default">
            <div class="theme-preview default-theme"></div>
            <span>Klasik</span>
          </div>
          <div class="theme-option" data-theme="gradient">
            <div class="theme-preview gradient-theme"></div>
            <span>Gradyan</span>
          </div>
          <div class="theme-option" data-theme="neon">
            <div class="theme-preview neon-theme"></div>
            <span>Neon</span>
          </div>
          <div class="theme-option" data-theme="dark">
            <div class="theme-preview dark-theme"></div>
            <span>Karanlık</span>
          </div>
          <div class="theme-option" data-theme="nature">
            <div class="theme-preview nature-theme"></div>
            <span>Doğa</span>
          </div>
        </div>
      </div>

      <!-- Game Instructions -->
      <div class="game-instructions">
        <div class="instructions-header">
          <h3><i class="fas fa-info-circle"></i> Nasıl Oynanır?</h3>
          <button class="toggle-instructions-btn"><i class="fas fa-chevron-down"></i></button>
        </div>
        <div class="instructions-content">
          <ul>
            <li>Kareleri doğru sırayla dizmeye çalışın.</li>
            <li>Boş kareye komşu olan bir kareye tıklayarak hareket ettirebilirsiniz.</li>
            <li>Tüm kareleri 1'den başlayarak sırayla yerleştirin.</li>
            <li>Son kare boş kalmalıdır.</li>
            <li>"İpucu" düğmesi, bir sonraki yapmanız gereken hamleyi gösterir.</li>
            <li>Zorluk seviyesini ve temayı değiştirerek oyunu kişiselleştirebilirsiniz.</li>
          </ul>
        </div>
      </div>
    </div>

    <!-- Success Modal -->
    <div id="success-modal" class="success-modal">
      <div class="success-content">
        <div class="success-header">
          <div class="trophy-icon"><i class="fas fa-trophy"></i></div>
          <h2>Tebrikler!</h2>
          <p>Puzzle'ı başarıyla tamamladınız!</p>
        </div>
        
        <div class="success-stats">
          <div class="success-stat">
            <div class="success-stat-icon"><i class="fas fa-running"></i></div>
            <div class="success-stat-value" id="final-moves">0</div>
            <div class="success-stat-label">Hamle</div>
          </div>
          <div class="success-stat">
            <div class="success-stat-icon"><i class="fas fa-stopwatch"></i></div>
            <div class="success-stat-value" id="final-time">00:00</div>
            <div class="success-stat-label">Süre</div>
          </div>
        </div>
        
        <div class="success-actions">
          <button id="play-again-btn" class="game-btn primary">
            <i class="fas fa-redo-alt"></i>
            <span>Tekrar Oyna</span>
          </button>
          <a href="{{ url_for('all_games') }}" class="game-btn secondary">
            <i class="fas fa-th-large"></i>
            <span>Tüm Oyunlar</span>
          </a>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
/* Modern Puzzle Slider Game Styles */
:root {
  --puzzle-primary: #5D5FEF;
  --puzzle-primary-dark: #4A4CC4;
  --puzzle-secondary: #FF7F50;
  --puzzle-warning: #FFAA00;
  --puzzle-info: #00BCD4;
  --puzzle-success: #4CAF50;
  --puzzle-dark: #1A1A2E;
  --puzzle-light: #FFFFFF;
  --puzzle-bg: #121230;
  --puzzle-card-bg: rgba(30, 30, 60, 0.7);
  --puzzle-text: #FFFFFF;
  --puzzle-border-radius: 12px;
  --puzzle-shadow: 0 8px 20px rgba(0, 0, 0, 0.25);
  --puzzle-transition: all 0.3s ease;
}

/* Game Container Styles */
.puzzle-app {
  width: 100%;
  max-width: 1000px;
  margin: 0 auto;
  display: flex;
  flex-direction: column;
  gap: 20px;
  padding: 0 15px;
}

/* Dashboard Styles */
.puzzle-dashboard {
  display: flex;
  justify-content: space-between;
  align-items: center;
  flex-wrap: wrap;
  gap: 20px;
}

/* Stats Cards Styles */
.puzzle-stats {
  display: flex;
  gap: 15px;
}

.stat-card {
  background: var(--puzzle-card-bg);
  border-radius: var(--puzzle-border-radius);
  padding: 15px;
  min-width: 110px;
  display: flex;
  align-items: center;
  gap: 12px;
  box-shadow: var(--puzzle-shadow);
}

.stat-icon {
  background: rgba(255, 255, 255, 0.1);
  border-radius: 50%;
  width: 40px;
  height: 40px;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 1.2rem;
  color: var(--puzzle-primary);
}

.stat-content {
  display: flex;
  flex-direction: column;
}

.stat-value {
  font-size: 1.5rem;
  font-weight: 700;
  color: var(--puzzle-light);
  line-height: 1.2;
}

.stat-label {
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.7);
}

/* Difficulty Selector Styles */
.puzzle-difficulty {
  background: var(--puzzle-card-bg);
  border-radius: var(--puzzle-border-radius);
  padding: 10px 15px;
  box-shadow: var(--puzzle-shadow);
}

.difficulty-label {
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.7);
  margin-bottom: 8px;
  text-align: center;
}

.difficulty-options {
  display: flex;
  gap: 5px;
}

.difficulty-btn {
  background: rgba(255, 255, 255, 0.1);
  color: var(--puzzle-text);
  border: none;
  border-radius: 6px;
  padding: 8px 15px;
  font-size: 0.9rem;
  cursor: pointer;
  transition: var(--puzzle-transition);
}

.difficulty-btn:hover {
  background: rgba(255, 255, 255, 0.2);
}

.difficulty-btn.active {
  background: var(--puzzle-primary);
  color: white;
}

/* Board Area Styles */
.puzzle-board-area {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 10px 0;
}

.puzzle-board {
  display: grid;
  gap: 8px;
  background: var(--puzzle-card-bg);
  padding: 15px;
  border-radius: var(--puzzle-border-radius);
  box-shadow: var(--puzzle-shadow);
  max-width: 100%;
}

.size-3 {
  grid-template-columns: repeat(3, 1fr);
  grid-template-rows: repeat(3, 1fr);
}

.size-4 {
  grid-template-columns: repeat(4, 1fr);
  grid-template-rows: repeat(4, 1fr);
}

.size-5 {
  grid-template-columns: repeat(5, 1fr);
  grid-template-rows: repeat(5, 1fr);
}

/* Puzzle Tile Styles */
.puzzle-tile {
  width: 80px;
  height: 80px;
  background: var(--puzzle-primary);
  border-radius: 8px;
  display: flex;
  justify-content: center;
  align-items: center;
  font-size: 1.8rem;
  font-weight: 700;
  color: white;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  user-select: none;
  position: relative;
  overflow: hidden;
}

.puzzle-tile::before {
  content: '';
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: linear-gradient(135deg, rgba(255,255,255,0.15) 0%, rgba(255,255,255,0) 50%);
  pointer-events: none;
}

.puzzle-tile:hover {
  transform: translateY(-3px);
  box-shadow: 0 6px 12px rgba(0, 0, 0, 0.3);
}

.puzzle-tile.empty {
  background: transparent;
  box-shadow: none;
  cursor: default;
}

.puzzle-tile.empty:hover {
  transform: none;
}

.puzzle-tile.highlight {
  animation: highlight-pulse 1.5s infinite;
}

@keyframes highlight-pulse {
  0% {
    box-shadow: 0 0 0 0 rgba(93, 95, 239, 0.7);
  }
  70% {
    box-shadow: 0 0 0 10px rgba(93, 95, 239, 0);
  }
  100% {
    box-shadow: 0 0 0 0 rgba(93, 95, 239, 0);
  }
}

/* Game Controls Styles */
.puzzle-controls {
  display: flex;
  justify-content: center;
  gap: 12px;
  flex-wrap: wrap;
}

.game-btn {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 12px 18px;
  border-radius: 8px;
  font-weight: 600;
  font-size: 0.95rem;
  border: none;
  cursor: pointer;
  transition: all 0.2s ease;
  box-shadow: 0 4px 6px rgba(0, 0, 0, 0.15);
}

.game-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 6px 10px rgba(0, 0, 0, 0.2);
}

.game-btn:active {
  transform: translateY(0);
}

.game-btn.primary {
  background: var(--puzzle-primary);
  color: white;
}

.game-btn.primary:hover {
  background: var(--puzzle-primary-dark);
}

.game-btn.secondary {
  background: rgba(255, 255, 255, 0.15);
  color: white;
}

.game-btn.secondary:hover {
  background: rgba(255, 255, 255, 0.25);
}

.game-btn.warning {
  background: var(--puzzle-warning);
  color: white;
}

.game-btn.info {
  background: var(--puzzle-info);
  color: white;
}

/* Theme Panel Styles */
.theme-panel {
  background: var(--puzzle-card-bg);
  border-radius: var(--puzzle-border-radius);
  padding: 20px;
  box-shadow: var(--puzzle-shadow);
  position: relative;
  margin-top: 10px;
  display: none;
}

.theme-panel.active {
  display: block;
  animation: fadeIn 0.3s;
}

.theme-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 15px;
}

.theme-header h3 {
  color: var(--puzzle-primary);
  margin: 0;
  font-size: 1.2rem;
}

.close-btn {
  background: none;
  border: none;
  color: rgba(255, 255, 255, 0.7);
  font-size: 1.2rem;
  cursor: pointer;
  transition: color 0.2s;
}

.close-btn:hover {
  color: white;
}

.theme-options {
  display: flex;
  gap: 15px;
  flex-wrap: wrap;
  justify-content: center;
}

.theme-option {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  transition: transform 0.2s;
}

.theme-option:hover {
  transform: translateY(-3px);
}

.theme-option.active .theme-preview {
  border: 2px solid var(--puzzle-primary);
  box-shadow: 0 0 0 2px var(--puzzle-primary);
}

.theme-preview {
  width: 60px;
  height: 60px;
  border-radius: 8px;
  border: 2px solid transparent;
  transition: all 0.2s;
}

.theme-option span {
  font-size: 0.85rem;
  color: rgba(255, 255, 255, 0.9);
}

/* Theme Preview Styles */
.default-theme {
  background: linear-gradient(135deg, #5D5FEF, #7B7DF8);
}

.gradient-theme {
  background: linear-gradient(135deg, #FF416C, #FF4B2B);
}

.neon-theme {
  background: #000;
  box-shadow: 0 0 8px #0ff, inset 0 0 5px #0ff;
  border: 1px solid #0ff;
}

.dark-theme {
  background: #121212;
  border: 1px solid #333;
}

.nature-theme {
  background: linear-gradient(135deg, #43a047, #1de9b6);
}

/* Game Instructions Styles */
.game-instructions {
  background: var(--puzzle-card-bg);
  border-radius: var(--puzzle-border-radius);
  overflow: hidden;
  box-shadow: var(--puzzle-shadow);
  margin-top: 10px;
}

.instructions-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: 15px 20px;
  background: rgba(0, 0, 0, 0.2);
  cursor: pointer;
}

.instructions-header h3 {
  margin: 0;
  color: var(--puzzle-primary);
  font-size: 1.1rem;
  display: flex;
  align-items: center;
  gap: 8px;
}

.toggle-instructions-btn {
  background: none;
  border: none;
  color: rgba(255, 255, 255, 0.7);
  font-size: 1rem;
  cursor: pointer;
  transition: all 0.3s;
}

.instructions-content {
  max-height: 0;
  overflow: hidden;
  transition: max-height 0.3s ease;
}

.instructions-content.active {
  max-height: 300px;
  padding: 0 20px 15px;
}

.instructions-content ul {
  margin: 0;
  padding-left: 25px;
}

.instructions-content li {
  color: rgba(255, 255, 255, 0.9);
  margin-bottom: 8px;
  font-size: 0.95rem;
}

/* Success Modal Styles */
.success-modal {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background: rgba(0, 0, 0, 0.85);
  display: none;
  justify-content: center;
  align-items: center;
  z-index: 1000;
}

.success-content {
  background: var(--puzzle-bg);
  border-radius: 20px;
  padding: 30px;
  max-width: 90%;
  width: 450px;
  box-shadow: 0 15px 30px rgba(0, 0, 0, 0.3);
  text-align: center;
  animation: modalFadeIn 0.5s;
  border: 1px solid rgba(93, 95, 239, 0.3);
}

.success-header {
  margin-bottom: 25px;
}

.trophy-icon {
  font-size: 3rem;
  color: #FFD700;
  margin-bottom: 15px;
  text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
  animation: trophy-shine 2s infinite;
}

@keyframes trophy-shine {
  0%, 100% {
    transform: scale(1);
    text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
  }
  50% {
    transform: scale(1.1);
    text-shadow: 0 0 20px rgba(255, 215, 0, 0.7);
  }
}

.success-header h2 {
  color: white;
  margin: 0 0 10px;
  font-size: 2rem;
}

.success-header p {
  color: rgba(255, 255, 255, 0.9);
  font-size: 1.1rem;
  margin: 0;
}

.success-stats {
  display: flex;
  justify-content: space-around;
  margin-bottom: 30px;
}

.success-stat {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 5px;
}

.success-stat-icon {
  font-size: 1.5rem;
  color: var(--puzzle-primary);
  margin-bottom: 5px;
}

.success-stat-value {
  font-size: 2.2rem;
  font-weight: 700;
  color: white;
}

.success-stat-label {
  font-size: 0.9rem;
  color: rgba(255, 255, 255, 0.7);
}

.success-actions {
  display: flex;
  flex-direction: column;
  gap: 10px;
}

@keyframes modalFadeIn {
  from {
    opacity: 0;
    transform: translateY(-20px);
  }
  to {
    opacity: 1;
    transform: translateY(0);
  }
}

/* Tile Theme Styles */
.puzzle-tile.theme-default {
  background: linear-gradient(135deg, #5D5FEF, #7B7DF8);
}

.puzzle-tile.theme-gradient {
  background: linear-gradient(135deg, #FF416C, #FF4B2B);
}

.puzzle-tile.theme-neon {
  background: #000;
  color: #0ff;
  text-shadow: 0 0 5px #0ff, 0 0 10px #0ff;
  border: 2px solid #0ff;
  box-shadow: 0 0 8px #0ff, inset 0 0 5px #0ff;
}

.puzzle-tile.theme-dark {
  background: #121212;
  color: #e0e0e0;
  border: 1px solid #333;
}

.puzzle-tile.theme-nature {
  background: linear-gradient(135deg, #43a047, #1de9b6);
}

/* Animation Keyframes */
@keyframes fadeIn {
  from { opacity: 0; }
  to { opacity: 1; }
}

@keyframes slideUp {
  from { transform: translateY(20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes slideDown {
  from { transform: translateY(-20px); opacity: 0; }
  to { transform: translateY(0); opacity: 1; }
}

@keyframes confetti-fall {
  0% { transform: translateY(-10px) rotate(0deg); opacity: 1; }
  100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
}

/* Responsive Styles */
@media (max-width: 768px) {
  .puzzle-dashboard {
    flex-direction: column;
    align-items: stretch;
  }
  
  .puzzle-stats {
    justify-content: space-between;
  }
  
  .puzzle-tile {
    width: 70px;
    height: 70px;
    font-size: 1.5rem;
  }
  
  .size-5 .puzzle-tile {
    width: 55px;
    height: 55px;
    font-size: 1.2rem;
  }
}

@media (max-width: 576px) {
  .puzzle-tile {
    width: 60px;
    height: 60px;
    font-size: 1.3rem;
  }
  
  .size-4 .puzzle-tile {
    width: 50px;
    height: 50px;
    font-size: 1.2rem;
  }
  
  .size-5 .puzzle-tile {
    width: 40px;
    height: 40px;
    font-size: 1rem;
  }
  
  .game-btn {
    padding: 10px 15px;
    font-size: 0.9rem;
  }
  
  .puzzle-controls {
    gap: 8px;
  }
  
  .stat-card {
    min-width: auto;
    flex: 1;
  }
}

/* Special Effects */
.tile-correct {
  animation: correct-position 0.5s;
}

@keyframes correct-position {
  0%, 100% { transform: scale(1); }
  50% { transform: scale(1.05); box-shadow: 0 0 15px var(--puzzle-success); }
}

.tile-move {
  animation: tile-move 0.2s;
}

@keyframes tile-move {
  0% { transform: scale(1); }
  50% { transform: scale(0.95); }
  100% { transform: scale(1); }
}

.board-shuffle {
  animation: board-shuffle 0.5s;
}

@keyframes board-shuffle {
  0% { transform: rotate(0deg); }
  25% { transform: rotate(-2deg); }
  75% { transform: rotate(2deg); }
  100% { transform: rotate(0deg); }
}

.confetti {
  position: absolute;
  width: 10px;
  height: 10px;
  border-radius: 50%;
  opacity: 0;
  animation: confetti-fall 3s ease-in-out forwards;
  z-index: 10;
  pointer-events: none;
}

.tile-touch {
  transform: scale(0.95);
}
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const puzzleBoard = document.getElementById('puzzle-board');
  const difficultyBtns = document.querySelectorAll('.difficulty-btn');
  const shuffleBtn = document.getElementById('shuffle-btn');
  const restartBtn = document.getElementById('restart-btn');
  const hintBtn = document.getElementById('hint-btn');
  const themeBtn = document.getElementById('theme-btn');
  const themePanel = document.getElementById('theme-panel');
  const closeThemeBtn = document.getElementById('close-theme-btn');
  const themeOptions = document.querySelectorAll('.theme-option');
  const movesDisplay = document.getElementById('moves-count');
  const timerDisplay = document.getElementById('time-count');
  const successModal = document.getElementById('success-modal');
  const finalMovesDisplay = document.getElementById('final-moves');
  const finalTimeDisplay = document.getElementById('final-time');
  const playAgainBtn = document.getElementById('play-again-btn');
  const instructionsHeader = document.querySelector('.instructions-header');
  const instructionsContent = document.querySelector('.instructions-content');
  const toggleInstructionsBtn = document.querySelector('.toggle-instructions-btn');

  // Game State
  let boardSize = 3;
  let tiles = [];
  let emptyTileIndex = boardSize * boardSize - 1;
  let moves = 0;
  let timer = null;
  let seconds = 0;
  let gameStarted = false;
  let currentTheme = 'default';
  
  // Initialize game
  createBoard();
  shuffleTiles();

  // Event listeners for difficulty buttons
  difficultyBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const newSize = parseInt(this.getAttribute('data-size'));
      if (newSize !== boardSize) {
        boardSize = newSize;
        
        // Update board class
        puzzleBoard.className = `puzzle-board size-${boardSize}`;
        
        // Reset game
        resetGame();
        createBoard();
        shuffleTiles();
        
        // Update active button
        difficultyBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
      }
    });
  });

  // Toggle theme panel
  themeBtn.addEventListener('click', function() {
    themePanel.classList.toggle('active');
  });

  // Close theme panel
  closeThemeBtn.addEventListener('click', function() {
    themePanel.classList.remove('active');
  });

  // Theme options
  themeOptions.forEach(option => {
    option.addEventListener('click', function() {
      const theme = this.getAttribute('data-theme');
      currentTheme = theme;
      
      // Update active theme
      themeOptions.forEach(opt => opt.classList.remove('active'));
      this.classList.add('active');
      
      // Apply theme to tiles
      applyThemeToTiles(theme);
      
      // Close theme panel after selection
      themePanel.classList.remove('active');
    });
  });

  // Toggle instructions
  instructionsHeader.addEventListener('click', function() {
    instructionsContent.classList.toggle('active');
    toggleInstructionsBtn.style.transform = instructionsContent.classList.contains('active') 
      ? 'rotate(180deg)' 
      : 'rotate(0deg)';
  });

  // Shuffle button
  shuffleBtn.addEventListener('click', function() {
    resetGame();
    shuffleTiles();
    
    // Add shuffle animation to board
    puzzleBoard.classList.add('board-shuffle');
    setTimeout(() => {
      puzzleBoard.classList.remove('board-shuffle');
    }, 500);
  });

  // Restart button
  restartBtn.addEventListener('click', function() {
    resetGame();
    
    // Add shuffle animation to board
    puzzleBoard.classList.add('board-shuffle');
    setTimeout(() => {
      puzzleBoard.classList.remove('board-shuffle');
    }, 500);
  });

  // Hint button
  hintBtn.addEventListener('click', showHint);

  // Play again button
  playAgainBtn.addEventListener('click', function() {
    successModal.style.display = 'none';
    resetGame();
    shuffleTiles();
  });

  // Create the puzzle board
  function createBoard() {
    // Clear previous board
    puzzleBoard.innerHTML = '';
    tiles = [];
    
    // Create tiles
    for (let i = 0; i < boardSize * boardSize; i++) {
      const tile = document.createElement('div');
      tile.className = 'puzzle-tile';
      
      // Last tile is empty
      if (i === boardSize * boardSize - 1) {
        tile.classList.add('empty');
      } else {
        tile.textContent = i + 1;
        tile.classList.add(`theme-${currentTheme}`);
      }
      
      // Add click event
      tile.addEventListener('click', () => moveTile(i));
      
      // Add touch events for mobile
      tile.addEventListener('touchstart', (e) => {
        e.preventDefault(); // Prevent scrolling
        tile.classList.add('tile-touch');
      });
      
      tile.addEventListener('touchend', (e) => {
        e.preventDefault();
        tile.classList.remove('tile-touch');
        moveTile(i);
      });
      
      tile.addEventListener('touchcancel', (e) => {
        tile.classList.remove('tile-touch');
      });
      
      puzzleBoard.appendChild(tile);
      tiles.push(tile);
    }
    
    // Set the empty tile index
    emptyTileIndex = boardSize * boardSize - 1;
  }

  // Shuffle the tiles
  function shuffleTiles() {
    // Make random valid moves to shuffle
    const moves = boardSize * boardSize * 5; // More moves for a good shuffle
    
    for (let i = 0; i < moves; i++) {
      const validMoves = getValidMoves();
      const randomMove = validMoves[Math.floor(Math.random() * validMoves.length)];
      swapTiles(randomMove, emptyTileIndex);
      emptyTileIndex = randomMove;
    }
    
    // Make sure the puzzle is not already solved
    if (isSolved()) {
      shuffleTiles();
      return;
    }
    
    // Start the game
    startGame();
  }

  // Get valid moves
  function getValidMoves() {
    const validMoves = [];
    const row = Math.floor(emptyTileIndex / boardSize);
    const col = emptyTileIndex % boardSize;
    
    // Check top
    if (row > 0) {
      validMoves.push(emptyTileIndex - boardSize);
    }
    
    // Check bottom
    if (row < boardSize - 1) {
      validMoves.push(emptyTileIndex + boardSize);
    }
    
    // Check left
    if (col > 0) {
      validMoves.push(emptyTileIndex - 1);
    }
    
    // Check right
    if (col < boardSize - 1) {
      validMoves.push(emptyTileIndex + 1);
    }
    
    return validMoves;
  }

  // Move a tile
  function moveTile(index) {
    if (!gameStarted) {
      startGame();
    }
    
    // Check if the move is valid
    if (isValidMove(index)) {
      // Play move sound
      playSound('click');
      
      // Increment moves counter
      moves++;
      movesDisplay.textContent = moves;
      
      // Add animation class
      tiles[index].classList.add('tile-move');
      
      // Swap tiles
      swapTiles(index, emptyTileIndex);
      
      // Update empty tile index
      emptyTileIndex = index;
      
      // Remove animation class after animation completes
      setTimeout(() => {
        tiles.forEach(tile => tile.classList.remove('tile-move'));
      }, 300);
      
      // Check if the puzzle is solved
      if (isSolved()) {
        gameComplete();
      }
    }
  }

  // Check if a move is valid
  function isValidMove(index) {
    const emptyRow = Math.floor(emptyTileIndex / boardSize);
    const emptyCol = emptyTileIndex % boardSize;
    const tileRow = Math.floor(index / boardSize);
    const tileCol = index % boardSize;
    
    // The tile must be adjacent to the empty space
    return (
      (Math.abs(emptyRow - tileRow) === 1 && emptyCol === tileCol) ||
      (Math.abs(emptyCol - tileCol) === 1 && emptyRow === tileRow)
    );
  }

  // Swap two tiles
  function swapTiles(index1, index2) {
    const temp = tiles[index1].innerHTML;
    const tempClass = tiles[index1].className;
    
    tiles[index1].innerHTML = tiles[index2].innerHTML;
    tiles[index1].className = tiles[index2].className;
    
    tiles[index2].innerHTML = temp;
    tiles[index2].className = tempClass;
  }

  // Start the game
  function startGame() {
    if (!gameStarted) {
      gameStarted = true;
      seconds = 0;
      moves = 0;
      movesDisplay.textContent = '0';
      timerDisplay.textContent = '00:00';
      
      // Start the timer
      clearInterval(timer);
      timer = setInterval(updateTimer, 1000);
    }
  }

  // Update the timer
  function updateTimer() {
    seconds++;
    const minutes = Math.floor(seconds / 60);
    const remainingSeconds = seconds % 60;
    timerDisplay.textContent = `${padZero(minutes)}:${padZero(remainingSeconds)}`;
  }

  // Pad numbers with leading zeros
  function padZero(num) {
    return num.toString().padStart(2, '0');
  }

  // Reset the game
  function resetGame() {
    // Reset game state
    gameStarted = false;
    clearInterval(timer);
    seconds = 0;
    moves = 0;
    movesDisplay.textContent = '0';
    timerDisplay.textContent = '00:00';
    
    // Reset the board
    for (let i = 0; i < tiles.length; i++) {
      if (i === tiles.length - 1) {
        tiles[i].textContent = '';
        tiles[i].className = 'puzzle-tile empty';
      } else {
        tiles[i].textContent = i + 1;
        tiles[i].className = `puzzle-tile theme-${currentTheme}`;
      }
    }
    
    // Reset empty tile index
    emptyTileIndex = boardSize * boardSize - 1;
  }

  // Check if the puzzle is solved
  function isSolved() {
    for (let i = 0; i < boardSize * boardSize - 1; i++) {
      if (parseInt(tiles[i].textContent) !== i + 1) {
        return false;
      }
    }
    return true;
  }

  // Game completion
  function gameComplete() {
    // Stop the timer
    clearInterval(timer);
    gameStarted = false;
    
    // Play completion sound
    playSound('complete');
    
    // Create celebration effect with confetti
    createConfetti();
    
    // Update final stats
    finalMovesDisplay.textContent = moves;
    finalTimeDisplay.textContent = timerDisplay.textContent;
    
    // Show success modal after animation
    setTimeout(() => {
      successModal.style.display = 'flex';
    }, 800);
    
    // Save score to the server if user is logged in
    saveScore();
  }

  // Create confetti effect
  function createConfetti() {
    const colors = ['#5D5FEF', '#FF416C', '#FFD700', '#4CAF50', '#00BCD4', '#9C27B0'];
    const confettiCount = 150;
    
    for (let i = 0; i < confettiCount; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.left = `${Math.random() * 100}%`;
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.animation = `confetti-fall ${Math.random() * 3 + 2}s ease-in-out forwards`;
      confetti.style.animationDelay = `${Math.random() * 0.5}s`;
      document.body.appendChild(confetti);
      
      // Remove confetti after animation
      setTimeout(() => {
        document.body.removeChild(confetti);
      }, 5000);
    }
  }

  // Show a hint
  function showHint() {
    // If game is not started, start it
    if (!gameStarted) {
      startGame();
    }
    
    // Play hint sound
    playSound('hint');
    
    // Find a valid move that gets closer to the solution
    const validMoves = getValidMoves();
    let bestMove = validMoves[0];
    let bestScore = -Infinity;
    
    for (const move of validMoves) {
      const tileValue = parseInt(tiles[move].textContent);
      const targetRow = Math.floor((tileValue - 1) / boardSize);
      const targetCol = (tileValue - 1) % boardSize;
      const currentRow = Math.floor(move / boardSize);
      const currentCol = move % boardSize;
      
      // Check if this move puts a tile in the correct position
      const distanceToTarget = Math.abs(targetRow - currentRow) + Math.abs(targetCol - currentCol);
      const score = -distanceToTarget;
      
      if (score > bestScore) {
        bestScore = score;
        bestMove = move;
      }
    }
    
    // Highlight the tile that should be moved
    const hintTile = tiles[bestMove];
    hintTile.classList.add('highlight');
    
    // Remove highlighting after 1.5 seconds
    setTimeout(() => {
      hintTile.classList.remove('highlight');
    }, 1500);
  }

  // Apply theme to tiles
  function applyThemeToTiles(theme) {
    tiles.forEach(tile => {
      if (!tile.classList.contains('empty')) {
        // Remove previous theme classes
        tile.classList.remove('theme-default', 'theme-gradient', 'theme-neon', 'theme-dark', 'theme-nature');
        // Add new theme
        tile.classList.add(`theme-${theme}`);
      }
    });
  }

  // Play sound effects
  function playSound(type) {
    let soundUrl;
    let volume = 0.5;
    
    switch(type) {
      case 'click':
        soundUrl = '/static/sounds/click.mp3';
        break;
      case 'hint':
        soundUrl = '/static/sounds/hint.mp3';
        break;
      case 'complete':
        soundUrl = '/static/sounds/game-complete.mp3';
        volume = 0.7;
        break;
      default:
        return;
    }
    
    const sound = new Audio(soundUrl);
    sound.volume = volume;
    sound.play().catch(e => console.log('Sound playback prevented:', e));
  }

  // Save score to the server
  function saveScore() {
    // Only save score if user is logged in
    fetch('/api/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'puzzleSlider',
        score: calculateScore(),
      }),
    })
    .then(response => response.json())
    .then(data => {
      console.log('Score saved:', data);
    })
    .catch(error => {
      console.error('Error saving score:', error);
    });
  }

  // Calculate score based on moves, time and board size
  function calculateScore() {
    const baseScore = 1000;
    const movesPenalty = moves * 5; // 5 points per move
    const timePenalty = seconds * 2; // 2 points per second
    const sizeBonus = (boardSize - 3) * 500; // 500 points for each size above 3x3
    
    let score = baseScore - movesPenalty - timePenalty + sizeBonus;
    return Math.max(100, score); // Minimum score is 100
  }
});
</script>
{% endblock %}
