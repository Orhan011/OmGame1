{% extends 'layout.html' %}

{% block title %}Tetris - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>Tetris <span class="badge">Klasik Blok Puzzle</span></h1>
      <p class="game-description">Düşen blokları doğru yerleştirerek çizgileri tamamlayın.</p>
    </div>

    <div class="tetris-container">
      <div class="tetris-layout">
        <div class="tetris-info-panel">
          <div class="tetris-score-panel">
            <div class="tetris-score-item">
              <div class="tetris-score-label">Skor</div>
              <div class="tetris-score-value" id="score">0</div>
            </div>
            <div class="tetris-score-item">
              <div class="tetris-score-label">Level</div>
              <div class="tetris-score-value" id="level">1</div>
            </div>
            <div class="tetris-score-item">
              <div class="tetris-score-label">Çizgiler</div>
              <div class="tetris-score-value" id="lines">0</div>
            </div>
          </div>

          <div class="tetris-next-piece">
            <div class="tetris-next-label">Sonraki Parça</div>
            <canvas id="next-piece-canvas" width="100" height="100"></canvas>
          </div>

          <div class="tetris-controls">
            <button id="start-game" class="btn btn-primary btn-lg">
              <i class="fas fa-play me-2"></i>Başla
            </button>
            <button id="pause-game" class="btn btn-outline-light" disabled>
              <i class="fas fa-pause me-2"></i>Duraklat
            </button>
            <button id="reset-game" class="btn btn-outline-danger">
              <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
            </button>
          </div>

          <div class="tetris-help">
            <h4 class="tetris-help-title"><i class="fas fa-keyboard me-2"></i>Kontroller</h4>
            <div class="tetris-help-items">
              <div class="tetris-help-item">
                <div class="tetris-key">←</div>
                <span>Sola Hareket</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">→</div>
                <span>Sağa Hareket</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↓</div>
                <span>Hızlı Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↑</div>
                <span>Döndür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">Boşluk</div>
                <span>Anında Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">P</div>
                <span>Duraklat</span>
              </div>
            </div>
          </div>
        </div>

        <div class="tetris-board-container">
          <canvas id="tetris-canvas" width="300" height="600"></canvas>
          
          <div id="tetris-overlay" class="tetris-overlay">
            <div class="tetris-overlay-content" id="pause-overlay" style="display: none;">
              <h2><i class="fas fa-pause me-2"></i>Oyun Duraklatıldı</h2>
              <p>Devam etmek için "Devam Et" düğmesine basın</p>
              <button id="resume-game" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Devam Et
              </button>
            </div>
            
            <div class="tetris-overlay-content" id="game-start-overlay">
              <h2>Tetris</h2>
              <p>Klasik Tetris oyununa hoş geldiniz!</p>
              <p>Düşen blokları yerleştirin ve çizgiler oluşturun</p>
              <button id="start-button" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Oyuna Başla
              </button>
            </div>
            
            <div class="tetris-overlay-content" id="game-over-overlay" style="display: none;">
              <h2><i class="fas fa-trophy me-2"></i>Oyun Bitti!</h2>
              <div class="tetris-final-score">
                <div class="tetris-final-score-label">Final Skoru</div>
                <div class="tetris-final-score-value" id="final-score">0</div>
              </div>
              <button id="play-again" class="btn btn-primary btn-lg">
                <i class="fas fa-redo-alt me-2"></i>Tekrar Oyna
              </button>
              <a href="{{ url_for('all_games') }}" class="btn btn-outline-light btn-lg mt-3">
                <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
              </a>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .tetris-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 10px;
  }

  .tetris-layout {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .tetris-info-panel {
    width: 250px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .tetris-score-panel {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .tetris-score-label {
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
  }

  .tetris-score-value {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  .tetris-next-piece {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-next-label {
    text-align: center;
    margin-bottom: 8px;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
  }

  #next-piece-canvas {
    display: block;
    margin: 0 auto;
    background: rgba(20, 20, 40, 0.5);
  }

  .tetris-controls {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-help {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-help-title {
    margin-bottom: 10px;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
  }

  .tetris-help-items {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .tetris-help-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .tetris-key {
    background: rgba(106, 90, 224, 0.3);
    padding: 4px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    min-width: 25px;
    text-align: center;
    color: var(--accent-color);
  }

  .tetris-help-item span {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
  }

  .tetris-board-container {
    position: relative;
    width: 300px;
    height: 600px;
  }

  #tetris-canvas {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 100%;
    height: 100%;
  }

  .tetris-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 15, 35, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 15px;
    z-index: 10;
  }

  .tetris-overlay-content {
    text-align: center;
    padding: 20px;
    max-width: 90%;
  }

  .tetris-overlay-content h2 {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 1.6rem;
  }

  .tetris-overlay-content p {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
    font-size: 0.95rem;
  }

  .tetris-final-score {
    background: rgba(40, 40, 80, 0.5);
    border-radius: 15px;
    padding: 15px;
    margin: 15px 0 20px;
  }

  .tetris-final-score-label {
    font-size: 0.95rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
  }

  .tetris-final-score-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .game-container {
      padding: 10px;
    }
    
    .game-header h1 {
      font-size: 1.5rem;
    }
    
    .game-header .badge {
      font-size: 0.8rem;
    }
    
    .game-description {
      font-size: 0.9rem;
    }
    
    .tetris-layout {
      flex-direction: column-reverse;
      align-items: center;
      gap: 15px;
    }
    
    .tetris-info-panel {
      width: 100%;
      max-width: 350px;
    }
    
    .tetris-board-container {
      width: 90vw;
      max-width: 350px;
      height: 180vw;
      max-height: 700px;
    }
    
    .tetris-score-panel, .tetris-next-piece, .tetris-controls, .tetris-help {
      padding: 12px;
    }
    
    .tetris-score-label {
      font-size: 0.9rem;
    }
    
    .tetris-score-value {
      font-size: 1.2rem;
    }
    
    .tetris-next-label {
      font-size: 0.9rem;
    }
    
    .tetris-help-title {
      font-size: 0.9rem;
    }
    
    .tetris-help-items {
      grid-template-columns: 1fr 1fr 1fr;
    }
    
    .tetris-help-item span {
      font-size: 0.8rem;
    }
    
    .tetris-key {
      font-size: 0.75rem;
      padding: 3px 6px;
    }
    
    .tetris-overlay-content h2 {
      font-size: 1.4rem;
    }
    
    .tetris-overlay-content p {
      font-size: 0.85rem;
    }
    
    .tetris-final-score-value {
      font-size: 2rem;
    }
  }
  
  /* Handle Landscape Mobile */
  @media (max-width: 1000px) and (max-height: 500px) and (orientation: landscape) {
    .tetris-layout {
      flex-direction: row;
      align-items: flex-start;
    }
    
    .tetris-info-panel {
      width: 40%;
      min-width: 200px;
    }
    
    .tetris-board-container {
      width: 50vh;
      height: 90vh;
      max-height: 450px;
    }
    
    .tetris-help-items {
      grid-template-columns: 1fr 1fr;
    }
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const canvas = document.getElementById('tetris-canvas');
  const nextPieceCanvas = document.getElementById('next-piece-canvas');
  const scoreElement = document.getElementById('score');
  const levelElement = document.getElementById('level');
  const linesElement = document.getElementById('lines');
  const finalScoreElement = document.getElementById('final-score');
  
  const startButton = document.getElementById('start-button');
  const startGameButton = document.getElementById('start-game');
  const pauseGameButton = document.getElementById('pause-game');
  const resetGameButton = document.getElementById('reset-game');
  const resumeGameButton = document.getElementById('resume-game');
  const playAgainButton = document.getElementById('play-again');
  
  const tetrisOverlay = document.getElementById('tetris-overlay');
  const gameStartOverlay = document.getElementById('game-start-overlay');
  const pauseOverlay = document.getElementById('pause-overlay');
  const gameOverOverlay = document.getElementById('game-over-overlay');
  
  // Game Constants
  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 30;
  const SHAPES = [
    // I Piece
    {
      matrix: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      color: '#00f0f0' // Cyan
    },
    // J Piece
    {
      matrix: [
        [2, 0, 0],
        [2, 2, 2],
        [0, 0, 0]
      ],
      color: '#0000f0' // Blue
    },
    // L Piece
    {
      matrix: [
        [0, 0, 3],
        [3, 3, 3],
        [0, 0, 0]
      ],
      color: '#f0a000' // Orange
    },
    // O Piece
    {
      matrix: [
        [4, 4],
        [4, 4]
      ],
      color: '#f0f000' // Yellow
    },
    // S Piece
    {
      matrix: [
        [0, 5, 5],
        [5, 5, 0],
        [0, 0, 0]
      ],
      color: '#00f000' // Green
    },
    // T Piece
    {
      matrix: [
        [0, 6, 0],
        [6, 6, 6],
        [0, 0, 0]
      ],
      color: '#a000f0' // Purple
    },
    // Z Piece
    {
      matrix: [
        [7, 7, 0],
        [0, 7, 7],
        [0, 0, 0]
      ],
      color: '#f00000' // Red
    }
  ];
  
  // Resize canvas based on container size
  function resizeCanvas() {
    const container = document.querySelector('.tetris-board-container');
    if (!container) return;
    
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Calculate block size based on container dimensions
    const blockSizeW = containerWidth / COLS;
    const blockSizeH = containerHeight / ROWS;
    
    // Set canvas dimensions
    canvas.width = containerWidth;
    canvas.height = containerHeight;
    
    // Update drawing scale
    ctx.scale(blockSizeW / BLOCK_SIZE, blockSizeH / BLOCK_SIZE);
    
    // Redraw if game is in progress
    if (!gameOver && !paused) {
      drawBoard();
    }
  }
  
  // Game variables
  const ctx = canvas.getContext('2d');
  const nextCtx = nextPieceCanvas.getContext('2d');
  
  let board = createBoard();
  let animationId = null;
  let gameOver = false;
  let paused = false;
  let score = 0;
  let level = 1;
  let lines = 0;
  let dropInterval = 1000; // milliseconds
  let lastDropTime = 0;
  
  let player = {
    matrix: null,
    pos: {x: 0, y: 0},
    color: ''
  };
  
  let nextPiece = {
    matrix: null,
    color: ''
  };
  
  // Create empty game board
  function createBoard() {
    return Array.from(
      {length: ROWS}, () => Array(COLS).fill(0)
    );
  }
  
  // Initialize the game
  function init() {
    // Reset board
    board = createBoard();
    
    // Reset game variables
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    gameOver = false;
    
    // Update UI
    scoreElement.textContent = score;
    levelElement.textContent = level;
    linesElement.textContent = lines;
    
    // Start with a new piece
    resetPlayer();
    getNextPiece();
    
    // Hide overlays
    tetrisOverlay.style.display = 'flex';
    gameStartOverlay.style.display = 'block';
    pauseOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    
    // Update button states
    pauseGameButton.disabled = true;
    
    // Draw board
    drawBoard();
  }
  
  // Start the game
  function startGame() {
    // Hide overlays
    tetrisOverlay.style.display = 'none';
    
    // Start game loop
    lastDropTime = performance.now();
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    gameLoop();
    
    // Update button states
    pauseGameButton.disabled = false;
  }
  
  // Pause the game
  function pauseGame() {
    if (gameOver) return;
    
    paused = true;
    cancelAnimationFrame(animationId);
    
    // Show pause overlay
    tetrisOverlay.style.display = 'flex';
    pauseOverlay.style.display = 'block';
  }
  
  // Resume the game
  function resumeGame() {
    paused = false;
    tetrisOverlay.style.display = 'none';
    lastDropTime = performance.now();
    gameLoop();
  }
  
  // Game loop
  function gameLoop(time = 0) {
    const deltaTime = time - lastDropTime;
    
    if (deltaTime > dropInterval) {
      drop();
      lastDropTime = time;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(gameLoop);
  }
  
  // Draw the board and current piece
  function drawBoard() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw board background
    ctx.fillStyle = 'rgba(20, 20, 40, 0.5)';
    ctx.fillRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(50, 50, 80, 0.5)';
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK_SIZE, 0);
      ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK_SIZE);
      ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Draw board pieces
    board.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Get color based on piece type
          const color = SHAPES[value - 1].color;
          drawBlock(x, y, color);
        }
      });
    });
    
    // Draw current piece
    if (player.matrix) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            drawBlock(x + player.pos.x, y + player.pos.y, player.color);
          }
        });
      });
    }
    
    // Draw ghost piece (shadow of where piece will land)
    drawGhostPiece();
    
    // Draw next piece preview
    drawNextPiece();
  }
  
  // Draw a single block
  function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    // Draw block border
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    // Draw block highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.beginPath();
    ctx.moveTo(x * BLOCK_SIZE, y * BLOCK_SIZE);
    ctx.lineTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
    ctx.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    ctx.fill();
  }
  
  // Draw ghost piece (shadow of where piece will land)
  function drawGhostPiece() {
    // Create a copy of player position
    const ghostPos = {
      x: player.pos.x,
      y: player.pos.y
    };
    
    // Move ghost down until collision
    while (!checkCollision(player.matrix, ghostPos)) {
      ghostPos.y++;
    }
    
    // Move back up one
    ghostPos.y--;
    
    // Draw ghost piece
    ctx.globalAlpha = 0.2;
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          drawBlock(x + ghostPos.x, y + ghostPos.y, player.color);
        }
      });
    });
    ctx.globalAlpha = 1;
  }
  
  // Draw next piece preview
  function drawNextPiece() {
    if (!nextPiece.matrix) return;
    
    // Clear next piece canvas
    nextCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    
    // Draw background
    nextCtx.fillStyle = 'rgba(20, 20, 40, 0.5)';
    nextCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    
    // Calculate offset to center the piece
    const blockSizeNext = Math.min(
      nextPieceCanvas.width / (nextPiece.matrix[0].length + 2),
      nextPieceCanvas.height / (nextPiece.matrix.length + 2)
    );
    
    const offset = {
      x: (nextPieceCanvas.width - nextPiece.matrix[0].length * blockSizeNext) / 2 / blockSizeNext,
      y: (nextPieceCanvas.height - nextPiece.matrix.length * blockSizeNext) / 2 / blockSizeNext
    };
    
    // Draw next piece
    nextPiece.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Draw block
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(
            (x + offset.x) * blockSizeNext, 
            (y + offset.y) * blockSizeNext, 
            blockSizeNext, 
            blockSizeNext
          );
          
          // Draw block border
          nextCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          nextCtx.lineWidth = 2;
          nextCtx.strokeRect(
            (x + offset.x) * blockSizeNext, 
            (y + offset.y) * blockSizeNext, 
            blockSizeNext, 
            blockSizeNext
          );
          
          // Draw block highlight
          nextCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          nextCtx.beginPath();
          nextCtx.moveTo((x + offset.x) * blockSizeNext, (y + offset.y) * blockSizeNext);
          nextCtx.lineTo((x + offset.x + 1) * blockSizeNext, (y + offset.y) * blockSizeNext);
          nextCtx.lineTo((x + offset.x) * blockSizeNext, (y + offset.y + 1) * blockSizeNext);
          nextCtx.fill();
        }
      });
    });
  }
  
  // Reset player with next piece
  function resetPlayer() {
    if (nextPiece.matrix) {
      player.matrix = nextPiece.matrix;
      player.color = nextPiece.color;
    } else {
      // First piece
      const pieceIndex = Math.floor(Math.random() * SHAPES.length);
      player.matrix = SHAPES[pieceIndex].matrix;
      player.color = SHAPES[pieceIndex].color;
    }
    
    // Set position at top-center
    player.pos.y = 0;
    player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
    
    // Check for game over
    if (checkCollision()) {
      endGame();
    }
  }

  function endGame() {
    gameOver = true;
    cancelAnimationFrame(animationId);

    // Update final results
    finalScoreElement.textContent = score;
    
    // Save score to the server
    saveScore(score);
    
    // Show game over overlay
    tetrisOverlay.style.display = 'flex';
    gameOverOverlay.style.display = 'block';
    
    // Update button states
    pauseGameButton.disabled = true;
  }
  
  // Function to save score to the server
  function saveScore(score) {
    fetch('/api/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'tetris',
        score: score
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log('Score saved:', data);
    })
    .catch(error => {
      console.error('Error saving score:', error);
    });
  }
  
  // Get next piece
  function getNextPiece() {
    const pieceIndex = Math.floor(Math.random() * SHAPES.length);
    nextPiece.matrix = SHAPES[pieceIndex].matrix;
    nextPiece.color = SHAPES[pieceIndex].color;
  }
  
  // Move piece down
  function drop() {
    player.pos.y++;
    
    // Check for collision
    if (checkCollision()) {
      player.pos.y--;
      mergePiece();
      resetPlayer();
      getNextPiece();
      
      // Check for line clears
      checkLines();
    }
  }
  
  // Hard drop piece
  function hardDrop() {
    while (!checkCollision()) {
      player.pos.y++;
    }
    
    player.pos.y--;
    mergePiece();
    resetPlayer();
    getNextPiece();
    
    // Check for line clears
    checkLines();
  }
  
  // Move piece horizontally
  function move(dir) {
    player.pos.x += dir;
    
    if (checkCollision()) {
      player.pos.x -= dir;
    }
  }
  
  // Rotate piece
  function rotate() {
    const matrix = player.matrix;
    const N = matrix.length;
    
    // Create rotated matrix
    const rotated = Array.from(
      {length: N}, () => Array(N).fill(0)
    );
    
    // Perform rotation (90 degrees clockwise)
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        rotated[x][N - 1 - y] = matrix[y][x];
      }
    }
    
    // Save original matrix
    const originalMatrix = player.matrix;
    
    // Try rotation
    player.matrix = rotated;
    
    // If collision, try wall kick
    if (checkCollision()) {
      // Try moving left
      player.pos.x--;
      
      // If still collision, try moving right
      if (checkCollision()) {
        player.pos.x += 2;
        
        // If still collision, revert rotation
        if (checkCollision()) {
          player.pos.x--;
          player.matrix = originalMatrix;
        }
      }
    }
  }
  
  // Check for collision
  function checkCollision(matrix = player.matrix, pos = player.pos) {
    if (!matrix) return false;
    
    for (let y = 0; y < matrix.length; y++) {
      for (let x = 0; x < matrix[y].length; x++) {
        if (matrix[y][x] !== 0 &&
            (board[y + pos.y] === undefined ||
             board[y + pos.y][x + pos.x] === undefined ||
             board[y + pos.y][x + pos.x] !== 0)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  // Merge piece with board
  function mergePiece() {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Store the piece type (1-7) on the board
          const pieceType = SHAPES.findIndex(shape => 
            shape.matrix === player.matrix) + 1;
          board[y + player.pos.y][x + player.pos.x] = pieceType;
        }
      });
    });
  }
  
  // Check for completed lines
  function checkLines() {
    let linesCleared = 0;
    
    // Check each row from bottom to top
    for (let y = ROWS - 1; y >= 0; y--) {
      // Check if row is full
      if (board[y].every(value => value !== 0)) {
        // Remove row
        board.splice(y, 1);
        
        // Add empty row at top
        board.unshift(Array(COLS).fill(0));
        
        // Increment lines cleared
        linesCleared++;
        
        // Check the same row again (since rows shifted down)
        y++;
      }
    }
    
    // Update score and level if lines were cleared
    if (linesCleared > 0) {
      // Update lines
      lines += linesCleared;
      linesElement.textContent = lines;
      
      // Calculate score
      // 100 for 1 line, 300 for 2 lines, 500 for 3 lines, 800 for 4 lines
      const linePoints = [0, 100, 300, 500, 800];
      score += linePoints[linesCleared] * level;
      
      // Update score display
      scoreElement.textContent = score;
      
      // Check for level up (every 10 lines)
      if (Math.floor(lines / 10) + 1 > level) {
        level = Math.floor(lines / 10) + 1;
        levelElement.textContent = level;
        
        // Increase speed
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      }
      
      // Play sound effect
      const audio = new Audio('/static/sounds/success.mp3');
      audio.play();
    }
  }
  
  // Keyboard controls
  document.addEventListener('keydown', event => {
    if (gameOver || paused) return;
    
    switch(event.key) {
      case 'ArrowLeft':
        move(-1);
        event.preventDefault();
        break;
      case 'ArrowRight':
        move(1);
        event.preventDefault();
        break;
      case 'ArrowDown':
        drop();
        event.preventDefault();
        break;
      case 'ArrowUp':
        rotate();
        event.preventDefault();
        break;
      case ' ':
        hardDrop();
        event.preventDefault();
        break;
      case 'p':
      case 'P':
        pauseGame();
        event.preventDefault();
        break;
    }
  });
  
  // Touch controls for mobile
  let touchStartX = null;
  let touchStartY = null;
  
  canvas.addEventListener('touchstart', function(e) {
    if (gameOver || paused) return;
    
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchmove', function(e) {
    if (gameOver || paused || touchStartX === null) return;
    
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    
    const diffX = touchX - touchStartX;
    const diffY = touchY - touchStartY;
    
    // Require minimum movement to trigger action
    const minSwipe = 20;
    
    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > minSwipe) {
      // Horizontal swipe
      if (diffX > 0) {
        move(1); // Right
      } else {
        move(-1); // Left
      }
      touchStartX = touchX;
      touchStartY = touchY;
    } else if (Math.abs(diffY) > Math.abs(diffX) && diffY > minSwipe) {
      // Downward swipe
      drop();
      touchStartX = touchX;
      touchStartY = touchY;
    }
    
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchend', function(e) {
    touchStartX = null;
    touchStartY = null;
  });
  
  // Double tap to rotate
  let lastTap = 0;
  canvas.addEventListener('touchend', function(e) {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    
    if (tapLength < 300 && tapLength > 0) {
      // Double tap detected
      rotate();
      e.preventDefault();
    }
    
    lastTap = currentTime;
  });
  
  // Button event listeners
  startButton.addEventListener('click', startGame);
  startGameButton.addEventListener('click', startGame);
  pauseGameButton.addEventListener('click', pauseGame);
  resetGameButton.addEventListener('click', init);
  resumeGameButton.addEventListener('click', resumeGame);
  playAgainButton.addEventListener('click', function() {
    init();
    startGame();
  });
  
  // Window resize event
  window.addEventListener('resize', resizeCanvas);
  
  // Initialize game
  init();
  resizeCanvas();
});
</script>
{% endblock %}
