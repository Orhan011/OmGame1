{% extends 'layout.html' %}

{% block title %}Tetris - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>Tetris <span class="badge">Klasik Blok Puzzle</span></h1>
      <p class="game-description">Düşen blokları doğru yerleştirerek çizgileri tamamlayın.</p>
    </div>

    <div class="tetris-container">
      <div class="tetris-layout">
        <div class="tetris-info-panel">
          <div class="tetris-score-panel">
            <div class="tetris-score-item">
              <div class="tetris-score-label">Skor</div>
              <div class="tetris-score-value" id="score">0</div>
            </div>
            <div class="tetris-score-item">
              <div class="tetris-score-label">Level</div>
              <div class="tetris-score-value" id="level">1</div>
            </div>
            <div class="tetris-score-item">
              <div class="tetris-score-label">Çizgiler</div>
              <div class="tetris-score-value" id="lines">0</div>
            </div>
          </div>

          <div class="tetris-next-piece">
            <div class="tetris-next-label">Sonraki Parça</div>
            <canvas id="next-piece-canvas" width="100" height="100"></canvas>
          </div>

          <div class="tetris-controls">
            <button id="start-game" class="btn btn-primary btn-lg">
              <i class="fas fa-play me-2"></i>Başla
            </button>
            <button id="pause-game" class="btn btn-outline-light" disabled>
              <i class="fas fa-pause me-2"></i>Duraklat
            </button>
            <button id="reset-game" class="btn btn-outline-danger">
              <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
            </button>
          </div>

          <div class="tetris-help">
            <h4 class="tetris-help-title"><i class="fas fa-keyboard me-2"></i>Kontroller</h4>
            <div class="tetris-help-items">
              <div class="tetris-help-item">
                <div class="tetris-key">←</div>
                <span>Sola Hareket</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">→</div>
                <span>Sağa Hareket</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↓</div>
                <span>Hızlı Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↑</div>
                <span>Döndür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">Boşluk</div>
                <span>Anında Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">P</div>
                <span>Duraklat</span>
              </div>
            </div>
          </div>
        </div>

        <div class="tetris-board-container">
          <canvas id="tetris-canvas" width="300" height="600"></canvas>
          
          <div id="tetris-overlay" class="tetris-overlay">
            <div class="tetris-overlay-content" id="pause-overlay" style="display: none;">
              <h2><i class="fas fa-pause me-2"></i>Oyun Duraklatıldı</h2>
              <p>Devam etmek için "Devam Et" düğmesine basın</p>
              <button id="resume-game" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Devam Et
              </button>
            </div>
            
            <div class="tetris-overlay-content" id="game-start-overlay">
              <h2>Tetris</h2>
              <p>Klasik Tetris oyununa hoş geldiniz!</p>
              <p>Düşen blokları yerleştirin ve çizgiler oluşturun</p>
              <button id="start-button" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Oyuna Başla
              </button>
            </div>
            
            <div class="tetris-overlay-content" id="game-over-overlay" style="display: none;">
              <h2><i class="fas fa-trophy me-2"></i>Oyun Bitti!</h2>
              <div class="tetris-final-score">
                <div class="tetris-final-score-label">Final Skoru</div>
                <div class="tetris-final-score-value" id="final-score">0</div>
              </div>
              
              <!-- XP ve Seviye Bilgisi -->
              <div class="tetris-xp-info" style="display: none;">
                <div class="tetris-xp-gain">
                  <div class="tetris-xp-gain-label"><i class="fas fa-star me-2"></i>Kazanılan XP</div>
                  <div class="tetris-xp-gain-value" id="xp-gain">0</div>
                </div>
                <div class="tetris-level-info">
                  <div class="tetris-level-label">Seviye</div>
                  <div class="tetris-level-value" id="current-level">1</div>
                </div>
              </div>
              
              <!-- Misafir kullanıcı bilgilendirme -->
              <div id="guest-info" class="guest-info" style="display: none;">
                <p class="guest-message"><i class="fas fa-info-circle me-2"></i>Misafir olarak oynuyorsunuz! Skorunuzu kaydetmek ve XP kazanmak için giriş yapın.</p>
                <div class="guest-buttons">
                  <a href="{{ url_for('login') }}" class="btn btn-success">
                    <i class="fas fa-sign-in-alt me-2"></i>Giriş Yap
                  </a>
                  <a href="{{ url_for('register') }}" class="btn btn-outline-info">
                    <i class="fas fa-user-plus me-2"></i>Kaydol
                  </a>
                </div>
              </div>
              
              <button id="play-again" class="btn btn-primary btn-lg mt-3">
                <i class="fas fa-redo-alt me-2"></i>Tekrar Oyna
              </button>
              <a href="{{ url_for('all_games') }}" class="btn btn-outline-light btn-lg mt-3">
                <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
              </a>
            </div>
          </div>
          
          <!-- Mobile touch controls -->
          <div class="touch-controls" id="touch-controls" style="display: none;">
            <button class="touch-control-btn" id="touch-left">
              <i class="fas fa-arrow-left"></i>
            </button>
            <button class="touch-control-btn" id="touch-rotate">
              <i class="fas fa-redo"></i>
            </button>
            <button class="touch-control-btn" id="touch-right">
              <i class="fas fa-arrow-right"></i>
            </button>
            <button class="touch-control-btn" id="touch-down">
              <i class="fas fa-arrow-down"></i>
            </button>
            <button class="touch-control-btn" id="touch-drop">
              <i class="fas fa-angle-double-down"></i>
            </button>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .tetris-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 10px;
  }

  .tetris-layout {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .tetris-info-panel {
    width: 250px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .tetris-score-panel {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .tetris-score-label {
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
  }

  .tetris-score-value {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  .tetris-next-piece {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-next-label {
    text-align: center;
    margin-bottom: 8px;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
  }

  #next-piece-canvas {
    display: block;
    margin: 0 auto;
    background: rgba(20, 20, 40, 0.5);
  }

  .tetris-controls {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-help {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-help-title {
    margin-bottom: 10px;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
  }

  .tetris-help-items {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .tetris-help-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .tetris-key {
    background: rgba(106, 90, 224, 0.3);
    padding: 4px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    min-width: 25px;
    text-align: center;
    color: var(--accent-color);
  }

  .tetris-help-item span {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
  }

  .tetris-board-container {
    position: relative;
    width: 250px;
    height: 500px;
  }

  #tetris-canvas {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 100%;
    height: 100%;
  }

  .tetris-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 15, 35, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 15px;
    z-index: 10;
  }

  .tetris-overlay-content {
    text-align: center;
    padding: 20px;
    max-width: 90%;
  }

  .tetris-overlay-content h2 {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 1.6rem;
  }

  .tetris-overlay-content p {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
    font-size: 0.95rem;
  }

  .tetris-final-score {
    background: rgba(40, 40, 80, 0.5);
    border-radius: 15px;
    padding: 15px;
    margin: 15px 0 20px;
  }

  .tetris-final-score-label {
    font-size: 0.95rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
  }

  .tetris-final-score-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--accent-color);
  }
  
  /* XP Info styling */
  .tetris-xp-info {
    background: rgba(40, 40, 80, 0.5);
    border-radius: 15px;
    padding: 15px;
    margin: 0 0 20px;
    display: flex;
    flex-wrap: wrap;
    gap: 12px;
    justify-content: space-between;
  }
  
  .tetris-xp-gain, .tetris-level-info {
    flex: 1;
    min-width: 100px;
  }
  
  .tetris-xp-gain-label, .tetris-level-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 5px;
  }
  
  .tetris-xp-gain-value {
    font-size: 1.6rem;
    font-weight: 700;
    color: #ffc107; /* Gold color for XP */
  }
  
  .tetris-level-value {
    font-size: 1.6rem;
    font-weight: 700;
    color: #8BC34A; /* Green color for level */
  }
  
  /* Bonus details styling */
  .tetris-bonus-details {
    margin-top: 10px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.8);
    background: rgba(30, 30, 60, 0.3);
    border-radius: 8px;
    padding: 10px;
  }
  
  .tetris-bonus-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .tetris-bonus-item span {
    color: rgba(255, 255, 255, 0.7);
  }
  
  .tetris-bonus-item strong {
    font-weight: 600;
    color: #a890ff;
  }
  
  /* Bonus types */
  .daily-bonus strong {
    color: #FFD54F; /* Amber color for daily bonus */
  }
  
  .streak-bonus strong {
    color: #FF7043; /* Deep Orange for streak bonus */
  }

  /* Animations */
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  @keyframes scaleUp {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
  }
  
  @keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
  }
  
  @keyframes levelUpAnimation {
    0% { transform: translateY(20px); opacity: 0; }
    20% { transform: translateY(-10px); opacity: 1; }
    80% { transform: translateY(-10px); opacity: 1; }
    100% { transform: translateY(-30px); opacity: 0; }
  }
  
  /* Misafir kullanıcı bilgilendirme */
  .guest-info {
    background: rgba(40, 40, 80, 0.5);
    border-radius: 15px;
    padding: 15px;
    margin: 15px 0;
    transition: all 0.3s ease;
    border: 1px solid rgba(106, 90, 224, 0.3);
  }
  
  .guest-message {
    color: #FFC107;
    font-size: 0.95rem;
    margin-bottom: 10px;
  }
  
  .guest-message-api {
    color: #4CAF50;
    font-size: 0.9rem;
    padding: 8px 12px;
    background: rgba(76, 175, 80, 0.1);
    border-radius: 8px;
    margin-top: 12px;
  }
  
  .guest-buttons {
    display: flex;
    gap: 10px;
    justify-content: center;
    margin-top: 8px;
  }
  
  /* Giriş vurgulama sınıfı */
  .highlight-login {
    background: rgba(106, 90, 224, 0.2);
    border: 2px solid rgba(106, 90, 224, 0.5);
    animation: pulse-border 1.5s infinite;
  }
  
  /* Giriş butonları animasyonu */
  .animate-buttons .btn {
    animation: pulse-buttons 1.5s infinite;
    transform-origin: center;
  }
  
  /* Buton animasyonu için keyframes */
  @keyframes pulse-buttons {
    0% { transform: scale(1); }
    50% { transform: scale(1.1); box-shadow: 0 0 15px rgba(106, 90, 224, 0.7); }
    100% { transform: scale(1); }
  }
  
  /* Kenarlık animasyonu için keyframes */
  @keyframes pulse-border {
    0% { border-color: rgba(106, 90, 224, 0.3); }
    50% { border-color: rgba(106, 90, 224, 0.8); }
    100% { border-color: rgba(106, 90, 224, 0.3); }
  }

  /* Level up animation */
  .level-up-animation {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 28px;
    font-weight: bold;
    color: var(--accent-color);
    text-shadow: 0 0 10px rgba(100, 50, 255, 0.8);
    z-index: 100;
    animation: levelUpAnimation 2s forwards;
    pointer-events: none;
  }

  /* Animate overlay */
  .tetris-overlay-content {
    animation: scaleUp 0.3s ease-out;
  }
  
  /* Score value animation */
  .score-update {
    animation: pulse 0.3s ease-out;
  }
  
  /* Tetris grid lines */
  .grid-line {
    position: absolute;
    background-color: rgba(200, 200, 255, 0.05);
    z-index: 1;
  }
  
  .grid-horizontal {
    height: 1px;
    width: 100%;
  }
  
  .grid-vertical {
    width: 1px;
    height: 100%;
  }
  
  /* Controls enhancement */
  .tetris-key {
    background: rgba(106, 90, 224, 0.3);
    padding: 4px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    min-width: 25px;
    text-align: center;
    color: var(--accent-color);
    transition: all 0.2s ease;
    border: 1px solid rgba(106, 90, 224, 0.3);
  }
  
  .tetris-key:hover {
    background: rgba(106, 90, 224, 0.6);
    transform: translateY(-2px);
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .game-container {
      padding: 10px;
    }
    
    .game-header h1 {
      font-size: 1.5rem;
    }
    
    .game-header .badge {
      font-size: 0.8rem;
    }
    
    .game-description {
      font-size: 0.9rem;
    }
    
    .tetris-layout {
      flex-direction: column-reverse;
      align-items: center;
      gap: 15px;
    }
    
    .tetris-info-panel {
      width: 100%;
      max-width: 350px;
    }
    
    .tetris-board-container {
      width: 80vw;
      max-width: 250px;
      height: 160vw;
      max-height: 500px;
    }
    
    .tetris-score-panel, .tetris-next-piece, .tetris-controls, .tetris-help {
      padding: 12px;
    }
    
    .tetris-score-label {
      font-size: 0.9rem;
    }
    
    .tetris-score-value {
      font-size: 1.2rem;
    }
    
    .tetris-next-label {
      font-size: 0.9rem;
    }
    
    .tetris-help-title {
      font-size: 0.9rem;
    }
    
    .tetris-help-items {
      grid-template-columns: 1fr 1fr 1fr;
    }
    
    .tetris-help-item span {
      font-size: 0.8rem;
    }
    
    .tetris-key {
      font-size: 0.75rem;
      padding: 3px 6px;
    }
    
    .tetris-overlay-content h2 {
      font-size: 1.4rem;
    }
    
    .tetris-overlay-content p {
      font-size: 0.85rem;
    }
    
    .tetris-final-score-value {
      font-size: 2rem;
    }
    
    /* Add touchscreen controls for mobile */
    .touch-controls {
      display: flex;
      justify-content: center;
      gap: 12px;
      margin-top: 15px;
    }
    
    .touch-control-btn {
      width: 50px;
      height: 50px;
      background: rgba(106, 90, 224, 0.3);
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 20px;
      color: rgba(255, 255, 255, 0.9);
      border: none;
      touch-action: manipulation;
    }
    
    .touch-control-btn:active {
      background: rgba(106, 90, 224, 0.6);
      transform: scale(0.95);
    }
  }
  
  /* Handle Landscape Mobile */
  @media (max-width: 1000px) and (max-height: 500px) and (orientation: landscape) {
    .tetris-layout {
      flex-direction: row;
      align-items: flex-start;
    }
    
    .tetris-info-panel {
      width: 40%;
      min-width: 200px;
    }
    
    .tetris-board-container {
      width: 50vh;
      height: 90vh;
      max-height: 450px;
    }
    
    .tetris-help-items {
      grid-template-columns: 1fr 1fr;
    }
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const canvas = document.getElementById('tetris-canvas');
  const nextPieceCanvas = document.getElementById('next-piece-canvas');
  const scoreElement = document.getElementById('score');
  const levelElement = document.getElementById('level');
  const linesElement = document.getElementById('lines');
  const finalScoreElement = document.getElementById('final-score');
  
  // Oyun başlangıç zamanını kaydetmek için
  let gameStartTime;
  
  // Canvas boyutlarını ayarla
  if (canvas) {
    canvas.width = 250;
    canvas.height = 500;
  }
  
  const startButton = document.getElementById('start-button');
  const startGameButton = document.getElementById('start-game');
  const pauseGameButton = document.getElementById('pause-game');
  const resetGameButton = document.getElementById('reset-game');
  const resumeGameButton = document.getElementById('resume-game');
  const playAgainButton = document.getElementById('play-again');
  
  const tetrisOverlay = document.getElementById('tetris-overlay');
  const gameStartOverlay = document.getElementById('game-start-overlay');
  const pauseOverlay = document.getElementById('pause-overlay');
  const gameOverOverlay = document.getElementById('game-over-overlay');

  // Eğer gerekli DOM elementleri bulunamazsa, erken dön
  if (!canvas || !nextPieceCanvas) {
    console.error('Gerekli canvas elementleri bulunamadı!');
    return;
  }
  
  // Game Constants
  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 30;
  const SHAPES = [
    // I Piece
    {
      matrix: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      color: '#00f0f0' // Cyan
    },
    // J Piece
    {
      matrix: [
        [2, 0, 0],
        [2, 2, 2],
        [0, 0, 0]
      ],
      color: '#0000f0' // Blue
    },
    // L Piece
    {
      matrix: [
        [0, 0, 3],
        [3, 3, 3],
        [0, 0, 0]
      ],
      color: '#f0a000' // Orange
    },
    // O Piece
    {
      matrix: [
        [4, 4],
        [4, 4]
      ],
      color: '#f0f000' // Yellow
    },
    // S Piece
    {
      matrix: [
        [0, 5, 5],
        [5, 5, 0],
        [0, 0, 0]
      ],
      color: '#00f000' // Green
    },
    // T Piece
    {
      matrix: [
        [0, 6, 0],
        [6, 6, 6],
        [0, 0, 0]
      ],
      color: '#a000f0' // Purple
    },
    // Z Piece
    {
      matrix: [
        [7, 7, 0],
        [0, 7, 7],
        [0, 0, 0]
      ],
      color: '#f00000' // Red
    }
  ];
  
  // Resize canvas based on container size
  function resizeCanvas() {
    const container = document.querySelector('.tetris-board-container');
    if (!container) return;
    
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Calculate block size based on container dimensions
    const blockSizeW = containerWidth / COLS;
    const blockSizeH = containerHeight / ROWS;
    
    // Set canvas dimensions
    canvas.width = containerWidth;
    canvas.height = containerHeight;
    
    // Update drawing scale
    ctx.scale(blockSizeW / BLOCK_SIZE, blockSizeH / BLOCK_SIZE);
    
    // Redraw if game is in progress
    if (!gameOver && !paused) {
      drawBoard();
    }
  }
  
  // Game variables
  const ctx = canvas.getContext('2d');
  const nextCtx = nextPieceCanvas.getContext('2d');
  
  let board = createBoard();
  let animationId = null;
  let gameOver = false;
  let paused = false;
  let score = 0;
  let level = 1;
  let lines = 0;
  let dropInterval = 1000; // milliseconds
  let lastDropTime = 0;
  
  // İstatistikler için oyun verileri
  let totalMoves = 0;      // Toplam hamle sayısı
  let hintCount = 0;       // İpucu kullanma sayısı (tetris'te yok)
  let rotateCount = 0;     // Döndürme sayısı
  let hardDropCount = 0;   // Sert düşürme sayısı
  let accuracy = 100;      // Doğruluk yüzdesi (tetris'te varsayılan olarak 100)
  
  let player = {
    matrix: null,
    pos: {x: 0, y: 0},
    color: ''
  };
  
  let nextPiece = {
    matrix: null,
    color: ''
  };
  
  // Create empty game board
  function createBoard() {
    return Array.from(
      {length: ROWS}, () => Array(COLS).fill(0)
    );
  }
  
  // Initialize the game
  function init() {
    // Reset board
    board = createBoard();
    
    // Reset game variables
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    gameOver = false;
    
    // Reset oyun istatistikleri
    totalMoves = 0;
    hintCount = 0;
    rotateCount = 0;
    hardDropCount = 0;
    accuracy = 100;
    
    // Update UI
    scoreElement.textContent = score;
    levelElement.textContent = level;
    linesElement.textContent = lines;
    
    // Start with a new piece
    resetPlayer();
    getNextPiece();
    
    // Hide overlays
    tetrisOverlay.style.display = 'flex';
    gameStartOverlay.style.display = 'block';
    pauseOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    
    // Update button states
    pauseGameButton.disabled = true;
    
    // Draw board
    drawBoard();
  }
  
  // Start the game
  function startGame() {
    // Play start sound
    const startSound = new Audio('/static/sounds/success.mp3');
    startSound.play().catch(e => console.log('Start sound playback prevented', e));
    
    // Hide overlays
    tetrisOverlay.style.display = 'none';
    
    // Oyun başlangıç zamanını kaydet
    gameStartTime = new Date();
    
    // Start game loop
    lastDropTime = performance.now();
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    gameLoop();
    
    // Update button states
    pauseGameButton.disabled = false;
  }
  
  // Pause the game
  function pauseGame() {
    if (gameOver) return;
    
    paused = true;
    cancelAnimationFrame(animationId);
    
    // Show pause overlay
    tetrisOverlay.style.display = 'flex';
    pauseOverlay.style.display = 'block';
  }
  
  // Resume the game
  function resumeGame() {
    paused = false;
    tetrisOverlay.style.display = 'none';
    lastDropTime = performance.now();
    gameLoop();
  }
  
  // Game loop
  function gameLoop(time = 0) {
    const deltaTime = time - lastDropTime;
    
    if (deltaTime > dropInterval) {
      drop();
      lastDropTime = time;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(gameLoop);
  }
  
  // Draw the board and current piece
  function drawBoard() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw board background
    ctx.fillStyle = 'rgba(20, 20, 40, 0.5)';
    ctx.fillRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(50, 50, 80, 0.5)';
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK_SIZE, 0);
      ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK_SIZE);
      ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Draw board pieces
    board.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Get color based on piece type
          const color = SHAPES[value - 1].color;
          drawBlock(x, y, color);
        }
      });
    });
    
    // Draw current piece
    if (player.matrix) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            drawBlock(x + player.pos.x, y + player.pos.y, player.color);
          }
        });
      });
    }
    
    // Draw ghost piece (shadow of where piece will land)
    drawGhostPiece();
    
    // Draw next piece preview
    drawNextPiece();
  }
  
  // Draw a single block
  function drawBlock(x, y, color) {
    ctx.fillStyle = color;
    ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    // Draw block border
    ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    ctx.lineWidth = 2;
    ctx.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    // Draw block highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.beginPath();
    ctx.moveTo(x * BLOCK_SIZE, y * BLOCK_SIZE);
    ctx.lineTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
    ctx.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    ctx.fill();
  }
  
  // Draw ghost piece (shadow of where piece will land)
  function drawGhostPiece() {
    // Create a copy of player position
    const ghostPos = {
      x: player.pos.x,
      y: player.pos.y
    };
    
    // Move ghost down until collision
    while (!checkCollision(player.matrix, ghostPos)) {
      ghostPos.y++;
    }
    
    // Move back up one
    ghostPos.y--;
    
    // Draw ghost piece
    ctx.globalAlpha = 0.2;
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          drawBlock(x + ghostPos.x, y + ghostPos.y, player.color);
        }
      });
    });
    ctx.globalAlpha = 1;
  }
  
  // Draw next piece preview
  function drawNextPiece() {
    if (!nextPiece.matrix) return;
    
    // Clear next piece canvas
    nextCtx.clearRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    
    // Draw background
    nextCtx.fillStyle = 'rgba(20, 20, 40, 0.5)';
    nextCtx.fillRect(0, 0, nextPieceCanvas.width, nextPieceCanvas.height);
    
    // Calculate offset to center the piece
    const blockSizeNext = Math.min(
      nextPieceCanvas.width / (nextPiece.matrix[0].length + 2),
      nextPieceCanvas.height / (nextPiece.matrix.length + 2)
    );
    
    const offset = {
      x: (nextPieceCanvas.width - nextPiece.matrix[0].length * blockSizeNext) / 2 / blockSizeNext,
      y: (nextPieceCanvas.height - nextPiece.matrix.length * blockSizeNext) / 2 / blockSizeNext
    };
    
    // Draw next piece
    nextPiece.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Draw block
          nextCtx.fillStyle = nextPiece.color;
          nextCtx.fillRect(
            (x + offset.x) * blockSizeNext, 
            (y + offset.y) * blockSizeNext, 
            blockSizeNext, 
            blockSizeNext
          );
          
          // Draw block border
          nextCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
          nextCtx.lineWidth = 2;
          nextCtx.strokeRect(
            (x + offset.x) * blockSizeNext, 
            (y + offset.y) * blockSizeNext, 
            blockSizeNext, 
            blockSizeNext
          );
          
          // Draw block highlight
          nextCtx.fillStyle = 'rgba(255, 255, 255, 0.1)';
          nextCtx.beginPath();
          nextCtx.moveTo((x + offset.x) * blockSizeNext, (y + offset.y) * blockSizeNext);
          nextCtx.lineTo((x + offset.x + 1) * blockSizeNext, (y + offset.y) * blockSizeNext);
          nextCtx.lineTo((x + offset.x) * blockSizeNext, (y + offset.y + 1) * blockSizeNext);
          nextCtx.fill();
        }
      });
    });
  }
  
  // Reset player with next piece
  function resetPlayer() {
    if (nextPiece.matrix) {
      player.matrix = nextPiece.matrix;
      player.color = nextPiece.color;
    } else {
      // First piece
      const pieceIndex = Math.floor(Math.random() * SHAPES.length);
      player.matrix = SHAPES[pieceIndex].matrix;
      player.color = SHAPES[pieceIndex].color;
    }
    
    // Set position at top-center
    player.pos.y = 0;
    player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
    
    // Check for game over
    if (checkCollision()) {
      endGame();
    }
  }

  function endGame() {
    gameOver = true;
    cancelAnimationFrame(animationId);

    // Play game over sound
    const gameOverSound = new Audio('/static/sounds/game-over.mp3');
    gameOverSound.play().catch(e => console.log('Game over sound playback prevented', e));

    // Update final results
    finalScoreElement.textContent = score;
    
    // Save score to the server
    saveScore(score);
    
    // Show game over overlay with animation
    tetrisOverlay.style.display = 'flex';
    gameOverOverlay.style.display = 'block';
    gameOverOverlay.classList.add('animate-in');
    
    // Update button states
    pauseGameButton.disabled = true;
  }
  
  // Function to save score to the server
  function saveScore(score) {
    // Oyun süresini hesapla (saniye olarak) - varsayılan 180 saniye
    const playtime = Math.floor((new Date() - gameStartTime) / 1000) || 180;

    // Zorluk seviyesini belirle (level'e göre)
    let difficulty = 'easy';
    if (level > 10) {
      difficulty = 'expert';
    } else if (level > 7) {
      difficulty = 'hard';
    } else if (level > 3) {
      difficulty = 'medium';
    }
    
    // Oyun istatistiklerini topla
    const gameStats = {
      duration_seconds: playtime,
      move_count: totalMoves,
      hint_count: hintCount,
      rotate_count: rotateCount,
      hard_drop_count: hardDropCount,
      accuracy: accuracy
    };

    fetch('/api/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'tetris',
        score: score,
        playtime: playtime,
        difficulty: difficulty,
        game_stats: gameStats
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log('Score saved:', data);
      
      // Yeni puan ve XP verilerini göster
      if (data.success) {
        const xpGainElement = document.getElementById('xp-gain');
        const currentLevelElement = document.getElementById('current-level');
        const xpInfoElement = document.querySelector('.tetris-xp-info');
        const guestInfoElement = document.getElementById('guest-info');
        
        // Misafir kullanıcı kontrolü
        if (data.guest) {
          // Misafir kullanıcı bilgilerini göster
          if (guestInfoElement) {
            guestInfoElement.style.display = 'block';
          }
        }
        
        if (xpGainElement && currentLevelElement && xpInfoElement) {
          // XP verilerini güncelle
          xpGainElement.textContent = data.xp.gain;
          currentLevelElement.textContent = data.xp.level || 1;
          
          // Bonus puanlarını ve detayları göster
          const finalScoreContainer = document.querySelector('.tetris-final-score');
          if (finalScoreContainer) {
            // Diğer veriler için yeni elementler oluştur
            // Puan detayları
            const bonusDetails = document.createElement('div');
            bonusDetails.className = 'tetris-bonus-details';
            
            // Yeni puanlama sistem bilgisi
            let scoringSystemInfo = '';
            if (data.score_info && data.score_info.total_score) {
              scoringSystemInfo = `
                <div class="tetris-scoring-systems">
                  <div class="tetris-scoring-title">Puanlama Detayları:</div>
                  <div class="tetris-bonus-item">
                    <span>Oyun Skoru:</span>
                    <strong>${score}</strong>
                  </div>
                  <div class="tetris-bonus-item">
                    <span>Performans Puanı:</span>
                    <strong>${data.score_info.total_score}</strong>
                  </div>
                </div>
              `;
            }
            
            bonusDetails.innerHTML = `
              <div class="tetris-bonus-item">
                <span>Temel Puan:</span>
                <strong>${data.points.rewards.base_points}</strong>
              </div>
              <div class="tetris-bonus-item">
                <span>Skor Bonusu:</span>
                <strong>${Math.floor(data.points.rewards.score_points)}</strong>
              </div>
              ${data.points.rewards.daily_bonus > 0 ? `
                <div class="tetris-bonus-item daily-bonus">
                  <span>Günlük Bonus:</span>
                  <strong>+${data.points.rewards.daily_bonus}</strong>
                </div>` : ''}
              ${data.points.rewards.streak_bonus > 0 ? `
                <div class="tetris-bonus-item streak-bonus">
                  <span>Seri Bonusu:</span>
                  <strong>+${data.points.rewards.streak_bonus}</strong>
                </div>` : ''}
              ${scoringSystemInfo}
            `;
            
            // Element bulunmazsa ekleme yap
            if (!document.querySelector('.tetris-bonus-details')) {
              finalScoreContainer.appendChild(bonusDetails);
            }
            
            // Toplam puanı güncelle
            finalScoreElement.textContent = data.points.total;
          }
          
          // XP bilgilerini göster (misafir için de bilgilendirici olarak gösterilir)
          xpInfoElement.style.display = 'block';
          
          // XP kazanımı animasyonu
          xpGainElement.classList.add('score-update');
          setTimeout(() => {
            xpGainElement.classList.remove('score-update');
          }, 300);
          
          // Seviye animasyonu
          currentLevelElement.classList.add('score-update');
          setTimeout(() => {
            currentLevelElement.classList.remove('score-update');
          }, 300);
          
          // Eğer API'den özel bir mesaj geldiyse göster
          if (data.message) {
            const messageEl = document.createElement('div');
            messageEl.className = 'guest-message-api mt-2';
            messageEl.innerHTML = `<i class="fas fa-info-circle me-2"></i>${data.message}`;
            
            // Önceki mesaj varsa kaldır
            const oldMessage = document.querySelector('.guest-message-api');
            if (oldMessage) {
              oldMessage.remove();
            }
            
            // Game over overlay'e ekle
            const gameOverOverlay = document.getElementById('game-over-overlay');
            if (gameOverOverlay) {
              gameOverOverlay.appendChild(messageEl);
            }
          }
          
          // Eğer giriş yapılması gerekiyorsa vurgula
          if (data.login_required) {
            const guestInfo = document.getElementById('guest-info');
            if (guestInfo) {
              guestInfo.classList.add('highlight-login');
              
              // Giriş butonlarını daha belirgin yap
              const loginButtons = guestInfo.querySelector('.guest-buttons');
              if (loginButtons) {
                loginButtons.classList.add('animate-buttons');
              }
            }
          }
        }
      }
    })
    .catch(error => {
      console.error('Error saving score:', error);
    });
  }
  
  // Get next piece
  function getNextPiece() {
    const pieceIndex = Math.floor(Math.random() * SHAPES.length);
    nextPiece.matrix = SHAPES[pieceIndex].matrix;
    nextPiece.color = SHAPES[pieceIndex].color;
  }
  
  // Move piece down
  function drop() {
    player.pos.y++;
    
    // Check for collision
    if (checkCollision()) {
      player.pos.y--;
      mergePiece();
      resetPlayer();
      getNextPiece();
      
      // Check for line clears
      checkLines();
    } else {
      // Drop hareketi de bir hamledir
      totalMoves++;
    }
  }
  
  // Hard drop piece
  function hardDrop() {
    let dropDistance = 0;
    while (!checkCollision()) {
      player.pos.y++;
      dropDistance++;
    }
    
    player.pos.y--;
    mergePiece();
    resetPlayer();
    getNextPiece();
    
    // İstatistikleri güncelle
    hardDropCount++;
    totalMoves++;
    
    // Check for line clears
    checkLines();
  }
  
  // Move piece horizontally
  function move(dir) {
    player.pos.x += dir;
    
    if (checkCollision()) {
      player.pos.x -= dir;
    } else {
      // Hamle sayısını artır
      totalMoves++;
    }
  }
  
  // Rotate piece
  function rotate() {
    const matrix = player.matrix;
    const N = matrix.length;
    
    // Create rotated matrix
    const rotated = Array.from(
      {length: N}, () => Array(N).fill(0)
    );
    
    // Perform rotation (90 degrees clockwise)
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        rotated[x][N - 1 - y] = matrix[y][x];
      }
    }
    
    // Save original matrix
    const originalMatrix = player.matrix;
    
    // Try rotation
    player.matrix = rotated;
    
    // If collision, try wall kick
    if (checkCollision()) {
      // Try moving left
      player.pos.x--;
      
      // If still collision, try moving right
      if (checkCollision()) {
        player.pos.x += 2;
        
        // If still collision, revert rotation
        if (checkCollision()) {
          player.pos.x--;
          player.matrix = originalMatrix;
        } else {
          // Rotasyon başarılı olduysa
          rotateCount++;
          totalMoves++;
        }
      } else {
        // Rotasyon başarılı olduysa
        rotateCount++;
        totalMoves++;
      }
    } else {
      // Rotasyon başarılı olduysa
      rotateCount++;
      totalMoves++;
    }
  }
  
  // Check for collision
  function checkCollision(matrix = player.matrix, pos = player.pos) {
    if (!matrix) return false;
    
    for (let y = 0; y < matrix.length; y++) {
      for (let x = 0; x < matrix[y].length; x++) {
        if (matrix[y][x] !== 0 &&
            (board[y + pos.y] === undefined ||
             board[y + pos.y][x + pos.x] === undefined ||
             board[y + pos.y][x + pos.x] !== 0)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  // Merge piece with board
  function mergePiece() {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Store the piece type (1-7) on the board
          const pieceType = SHAPES.findIndex(shape => 
            shape.matrix === player.matrix) + 1;
          board[y + player.pos.y][x + player.pos.x] = pieceType;
        }
      });
    });
  }
  
  // Check for completed lines
  function checkLines() {
    let linesCleared = 0;
    
    // Check each row from bottom to top
    for (let y = ROWS - 1; y >= 0; y--) {
      // Check if row is full
      if (board[y].every(value => value !== 0)) {
        // Remove row
        board.splice(y, 1);
        
        // Add empty row at top
        board.unshift(Array(COLS).fill(0));
        
        // Increment lines cleared
        linesCleared++;
        
        // Check the same row again (since rows shifted down)
        y++;
      }
    }
    
    // Update score and level if lines were cleared
    if (linesCleared > 0) {
      // Update lines
      lines += linesCleared;
      linesElement.textContent = lines;
      
      // Calculate score
      // 100 for 1 line, 300 for 2 lines, 500 for 3 lines, 800 for 4 lines
      const linePoints = [0, 100, 300, 500, 800];
      score += linePoints[linesCleared] * level;
      
      // Update score display
      scoreElement.textContent = score;
      
      // Check for level up (every 10 lines)
      if (Math.floor(lines / 10) + 1 > level) {
        level = Math.floor(lines / 10) + 1;
        levelElement.textContent = level;
        
        // Level up animation and sound
        const levelUpAnim = document.createElement('div');
        levelUpAnim.className = 'level-up-animation';
        levelUpAnim.textContent = 'LEVEL UP!';
        document.querySelector('.tetris-board-container').appendChild(levelUpAnim);
        
        // Play level up sound
        const levelUpSound = new Audio('/static/sounds/level-up.mp3');
        levelUpSound.play().catch(e => console.log('Level up sound playback prevented', e));
        
        // Remove animation after delay
        setTimeout(() => {
          levelUpAnim.remove();
        }, 2000);
        
        // Increase speed
        dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      }
      
      // Play sound effect
      const audio = new Audio('/static/sounds/success.mp3');
      audio.play().catch(err => console.log('Ses çalma hatası:', err));
    }
  }
  
  // Keyboard controls
  document.addEventListener('keydown', event => {
    if (gameOver || paused) return;
    
    switch(event.key) {
      case 'ArrowLeft':
        move(-1);
        event.preventDefault();
        break;
      case 'ArrowRight':
        move(1);
        event.preventDefault();
        break;
      case 'ArrowDown':
        drop();
        event.preventDefault();
        break;
      case 'ArrowUp':
        rotate();
        event.preventDefault();
        break;
      case ' ':
        hardDrop();
        event.preventDefault();
        break;
      case 'p':
      case 'P':
        pauseGame();
        event.preventDefault();
        break;
    }
  });
  
  // Touch controls for mobile
  let touchStartX = null;
  let touchStartY = null;
  
  canvas.addEventListener('touchstart', function(e) {
    if (gameOver || paused) return;
    
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchmove', function(e) {
    if (gameOver || paused || touchStartX === null) return;
    
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    
    const diffX = touchX - touchStartX;
    const diffY = touchY - touchStartY;
    
    // Require minimum movement to trigger action
    const minSwipe = 20;
    
    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > minSwipe) {
      // Horizontal swipe
      if (diffX > 0) {
        move(1); // Right
      } else {
        move(-1); // Left
      }
      touchStartX = touchX;
      touchStartY = touchY;
    } else if (Math.abs(diffY) > Math.abs(diffX) && diffY > minSwipe) {
      // Downward swipe
      drop();
      touchStartX = touchX;
      touchStartY = touchY;
    }
    
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchend', function(e) {
    touchStartX = null;
    touchStartY = null;
  });
  
  // Double tap to rotate
  let lastTap = 0;
  canvas.addEventListener('touchend', function(e) {
    const currentTime = new Date().getTime();
    const tapLength = currentTime - lastTap;
    
    if (tapLength < 300 && tapLength > 0) {
      // Double tap detected
      rotate();
      e.preventDefault();
    }
    
    lastTap = currentTime;
  });
  
  // Touch controls for mobile
  const touchControls = document.getElementById('touch-controls');
  const touchLeft = document.getElementById('touch-left');
  const touchRight = document.getElementById('touch-right');
  const touchRotate = document.getElementById('touch-rotate');
  const touchDown = document.getElementById('touch-down');
  const touchDrop = document.getElementById('touch-drop');
  
  // Show touch controls on mobile devices
  if ('ontouchstart' in window || navigator.maxTouchPoints > 0) {
    touchControls.style.display = 'flex';
  }
  
  // Touch control event listeners
  if (touchLeft) {
    touchLeft.addEventListener('click', () => move(-1));
    touchRight.addEventListener('click', () => move(1));
    touchRotate.addEventListener('click', rotate);
    touchDown.addEventListener('click', () => drop());
    touchDrop.addEventListener('click', () => {
      while(!collide(board, player)) {
        player.pos.y++;
      }
      player.pos.y--;
      merge(board, player);
      resetPlayer();
      clearLines();
    });
  }
  
  // Button event listeners
  startButton.addEventListener('click', startGame);
  startGameButton.addEventListener('click', startGame);
  pauseGameButton.addEventListener('click', pauseGame);
  resetGameButton.addEventListener('click', init);
  resumeGameButton.addEventListener('click', resumeGame);
  playAgainButton.addEventListener('click', function() {
    init();
    startGame();
  });
  
  // Window resize event
  window.addEventListener('resize', resizeCanvas);
  
  // Initialize game
  init();
  resizeCanvas();
});
</script>
{% endblock %}
