{% extends 'layout.html' %}

{% block title %}Tetris{% endblock %}

{% block content %}
<div class="tetris-container">
  <h1>Tetris</h1>
  
  <!-- Next Piece Display -->
  <div class="next-piece">
    <span class="next-label">Sonraki Parça</span>
    <canvas id="nextPiece" width="100" height="100"></canvas>
  </div>
  
  <!-- Game Board -->
  <div class="board">
    <canvas id="board" width="280" height="448"></canvas>
  </div>
  
  <!-- Score Display -->
  <div class="score-panel">
    <div class="score-item">
      <span class="score-label">Skor:</span>
      <span id="score" class="score-value">0</span>
    </div>
    <div class="score-item">
      <span class="score-label">Seviye:</span>
      <span id="level" class="score-value">1</span>
    </div>
    <div class="score-item">
      <span class="score-label">Satır:</span>
      <span id="lines" class="score-value">0</span>
    </div>
  </div>
  
  <!-- Game Controls -->
  <div class="controls">
    <button id="startBtn">Başlat</button>
    <button id="pauseBtn" disabled>Duraklat</button>
    <button id="resetBtn">Yeniden Başlat</button>
  </div>
  
  <!-- Mobile Touch Controls -->
  <div class="touch-controls">
    <div class="touch-row">
      <button id="rotateBtn">↻ Döndür</button>
    </div>
    <div class="touch-row">
      <button id="leftBtn">← Sol</button>
      <button id="downBtn">↓ Aşağı</button>
      <button id="rightBtn">→ Sağ</button>
    </div>
    <div class="touch-row">
      <button id="dropBtn">⤓ Düşür</button>
    </div>
  </div>
</div>

<style>
  .tetris-container {
    max-width: 500px;
    margin: 0 auto;
    text-align: center;
    padding: 10px;
  }
  
  h1 {
    margin-bottom: 15px;
    color: #ffffff;
  }
  
  .next-piece {
    background: rgba(0, 0, 0, 0.2);
    padding: 10px;
    border-radius: 10px;
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 15px;
    margin-bottom: 15px;
  }
  
  .next-label {
    font-weight: bold;
    color: #ffffff;
  }
  
  #nextPiece {
    background: rgba(0, 0, 0, 0.3);
    border-radius: 5px;
  }
  
  .board {
    margin: 0 auto 15px;
  }
  
  #board {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 5px;
  }
  
  .score-panel {
    display: flex;
    justify-content: space-around;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
    padding: 10px;
    margin-bottom: 15px;
  }
  
  .score-item {
    display: flex;
    flex-direction: column;
  }
  
  .score-label {
    font-size: 14px;
    color: #cccccc;
  }
  
  .score-value {
    font-size: 20px;
    font-weight: bold;
    color: #ffffff;
  }
  
  .controls {
    margin-bottom: 20px;
  }
  
  .controls button {
    padding: 10px 15px;
    margin: 0 5px;
    background: #6C5CE7;
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
  }
  
  .controls button:hover {
    background: #5649c0;
  }
  
  .controls button:disabled {
    background: #999999;
    cursor: not-allowed;
  }
  
  .touch-controls {
    display: flex;
    flex-direction: column;
    gap: 10px;
  }
  
  .touch-row {
    display: flex;
    justify-content: center;
    gap: 10px;
  }
  
  .touch-controls button {
    padding: 15px;
    background: rgba(108, 92, 231, 0.5);
    color: white;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    font-size: 16px;
    min-width: 60px;
  }
  
  .touch-controls button:active {
    background: rgba(108, 92, 231, 0.8);
  }
  
  /* Hide touch controls on desktop */
  @media (min-width: 769px) {
    .touch-controls {
      display: none;
    }
  }
</style>

<script>
// Tetris Game
document.addEventListener('DOMContentLoaded', function() {
  // Canvas and Context
  const boardCanvas = document.getElementById('board');
  const boardCtx = boardCanvas.getContext('2d');
  
  const nextCanvas = document.getElementById('nextPiece');
  const nextCtx = nextCanvas.getContext('2d');
  
  // Game Constants
  const COLS = 10;
  const ROWS = 16;
  const BLOCK_SIZE = 28;
  const NEXT_BLOCK_SIZE = 20;
  
  // Game State
  let board = [];
  let currentPiece = null;
  let nextPiece = null;
  let score = 0;
  let lines = 0;
  let level = 1;
  let gameOver = false;
  let paused = false;
  let dropCounter = 0;
  let dropInterval = 1000; // 1 second
  let lastTime = 0;
  let gameTimerId = null;
  
  // Colors for pieces
  const colors = [
    null,
    '#FF0000', // I - Red
    '#00FF00', // O - Green
    '#0000FF', // T - Blue
    '#FFFF00', // L - Yellow
    '#FF00FF', // J - Purple
    '#00FFFF', // S - Cyan
    '#FF8800'  // Z - Orange
  ];
  
  // Shapes of tetrominoes
  const shapes = [
    null,
    [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
    [[2,2], [2,2]],                               // O
    [[0,3,0], [3,3,3], [0,0,0]],                  // T
    [[0,0,4], [4,4,4], [0,0,0]],                  // L
    [[5,0,0], [5,5,5], [0,0,0]],                  // J
    [[0,6,6], [6,6,0], [0,0,0]],                  // S
    [[7,7,0], [0,7,7], [0,0,0]]                   // Z
  ];
  
  // Initialize Game
  function init() {
    // Button event listeners
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    
    // Keyboard controls
    document.addEventListener('keydown', handleKeyPress);
    
    // Touch controls
    setupTouchControls();
    
    // Create empty board
    resetGame();
  }
  
  // Setup touch controls
  function setupTouchControls() {
    // Swipe detection on board
    let touchStartX = 0;
    let touchStartY = 0;
    
    boardCanvas.addEventListener('touchstart', function(e) {
      touchStartX = e.touches[0].clientX;
      touchStartY = e.touches[0].clientY;
    });
    
    boardCanvas.addEventListener('touchend', function(e) {
      if (gameOver || paused) return;
      
      const touchEndX = e.changedTouches[0].clientX;
      const touchEndY = e.changedTouches[0].clientY;
      
      const diffX = touchStartX - touchEndX;
      const diffY = touchStartY - touchEndY;
      
      // Detect horizontal swipe
      if (Math.abs(diffX) > Math.abs(diffY)) {
        if (diffX > 0) {
          moveLeft();
        } else {
          moveRight();
        }
      } 
      // Detect vertical swipe
      else {
        if (diffY > 0) {
          rotate();
        } else {
          if (Math.abs(diffY) > 50) {
            hardDrop();
          } else {
            moveDown();
          }
        }
      }
    });
    
    // Button controls for mobile
    document.getElementById('leftBtn').addEventListener('click', moveLeft);
    document.getElementById('rightBtn').addEventListener('click', moveRight);
    document.getElementById('downBtn').addEventListener('click', moveDown);
    document.getElementById('rotateBtn').addEventListener('click', rotate);
    document.getElementById('dropBtn').addEventListener('click', hardDrop);
  }
  
  // Start the game
  function startGame() {
    if (gameOver || paused) {
      resetGame();
    }
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('pauseBtn').disabled = false;
    
    gameTimerId = requestAnimationFrame(update);
  }
  
  // Reset the game
  function resetGame() {
    // Clear the board
    board = Array(ROWS).fill().map(() => Array(COLS).fill(0));
    
    // Reset game state
    score = 0;
    lines = 0;
    level = 1;
    gameOver = false;
    paused = false;
    dropInterval = 1000;
    
    // Create new pieces
    currentPiece = createRandomPiece();
    nextPiece = createRandomPiece();
    
    // Update UI
    updateScore();
    document.getElementById('startBtn').disabled = false;
    document.getElementById('pauseBtn').disabled = true;
    document.getElementById('pauseBtn').textContent = 'Duraklat';
    
    // Draw game
    draw();
    drawNextPiece();
  }
  
  // Toggle pause/resume
  function togglePause() {
    if (gameOver) return;
    
    paused = !paused;
    
    if (paused) {
      document.getElementById('pauseBtn').textContent = 'Devam Et';
      cancelAnimationFrame(gameTimerId);
    } else {
      document.getElementById('pauseBtn').textContent = 'Duraklat';
      gameTimerId = requestAnimationFrame(update);
    }
  }
  
  // Create a random tetromino
  function createRandomPiece() {
    const type = Math.floor(Math.random() * 7) + 1;
    
    return {
      type: type,
      shape: shapes[type],
      x: Math.floor(COLS / 2) - Math.floor(shapes[type][0].length / 2),
      y: 0
    };
  }
  
  // Game loop
  function update(time) {
    if (gameOver || paused) return;
    
    const deltaTime = time - lastTime;
    lastTime = time;
    
    // Auto drop piece
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
      moveDown();
      dropCounter = 0;
    }
    
    draw();
    gameTimerId = requestAnimationFrame(update);
  }
  
  // Draw the game
  function draw() {
    // Clear board
    boardCtx.clearRect(0, 0, boardCanvas.width, boardCanvas.height);
    
    // Draw board
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x]) {
          drawBlock(boardCtx, x, y, board[y][x]);
        }
      }
    }
    
    // Draw current piece
    if (currentPiece) {
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            drawBlock(boardCtx, currentPiece.x + x, currentPiece.y + y, currentPiece.type);
          }
        }
      }
    }
    
    // Draw grid
    drawGrid();
  }
  
  // Draw grid lines
  function drawGrid() {
    boardCtx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    boardCtx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= COLS; x++) {
      boardCtx.beginPath();
      boardCtx.moveTo(x * BLOCK_SIZE, 0);
      boardCtx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
      boardCtx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y <= ROWS; y++) {
      boardCtx.beginPath();
      boardCtx.moveTo(0, y * BLOCK_SIZE);
      boardCtx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
      boardCtx.stroke();
    }
  }
  
  // Draw next piece
  function drawNextPiece() {
    // Clear canvas
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    if (!nextPiece) return;
    
    // Calculate center position
    const offsetX = (nextCanvas.width - nextPiece.shape[0].length * NEXT_BLOCK_SIZE) / 2;
    const offsetY = (nextCanvas.height - nextPiece.shape.length * NEXT_BLOCK_SIZE) / 2;
    
    // Draw next piece
    for (let y = 0; y < nextPiece.shape.length; y++) {
      for (let x = 0; x < nextPiece.shape[y].length; x++) {
        if (nextPiece.shape[y][x]) {
          // Draw block with offset
          const blockX = offsetX + x * NEXT_BLOCK_SIZE;
          const blockY = offsetY + y * NEXT_BLOCK_SIZE;
          
          // Fill
          nextCtx.fillStyle = colors[nextPiece.type];
          nextCtx.fillRect(blockX, blockY, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
          
          // Border
          nextCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
          nextCtx.lineWidth = 1;
          nextCtx.strokeRect(blockX, blockY, NEXT_BLOCK_SIZE, NEXT_BLOCK_SIZE);
          
          // Highlight
          nextCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
          nextCtx.fillRect(blockX, blockY, NEXT_BLOCK_SIZE / 3, NEXT_BLOCK_SIZE / 3);
        }
      }
    }
  }
  
  // Draw a block
  function drawBlock(ctx, x, y, type) {
    const blockX = x * BLOCK_SIZE;
    const blockY = y * BLOCK_SIZE;
    
    // Fill
    ctx.fillStyle = colors[type];
    ctx.fillRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
    
    // Border
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.lineWidth = 1;
    ctx.strokeRect(blockX, blockY, BLOCK_SIZE, BLOCK_SIZE);
    
    // Highlight
    ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
    ctx.fillRect(blockX, blockY, BLOCK_SIZE / 3, BLOCK_SIZE / 3);
  }
  
  // Check collision
  function checkCollision(piece, offsetX, offsetY) {
    for (let y = 0; y < piece.shape.length; y++) {
      for (let x = 0; x < piece.shape[y].length; x++) {
        if (!piece.shape[y][x]) continue;
        
        const newX = piece.x + x + offsetX;
        const newY = piece.y + y + offsetY;
        
        // Check boundaries
        if (newX < 0 || newX >= COLS || newY >= ROWS) {
          return true;
        }
        
        // Skip if above the top
        if (newY < 0) continue;
        
        // Check collision with other pieces
        if (board[newY][newX]) {
          return true;
        }
      }
    }
    return false;
  }
  
  // Move left
  function moveLeft() {
    if (!gameOver && !paused && !checkCollision(currentPiece, -1, 0)) {
      currentPiece.x--;
      draw();
    }
  }
  
  // Move right
  function moveRight() {
    if (!gameOver && !paused && !checkCollision(currentPiece, 1, 0)) {
      currentPiece.x++;
      draw();
    }
  }
  
  // Move down
  function moveDown() {
    if (gameOver || paused) return false;
    
    if (!checkCollision(currentPiece, 0, 1)) {
      currentPiece.y++;
      draw();
      return true;
    } else {
      lockPiece();
      return false;
    }
  }
  
  // Hard drop - move down instantly
  function hardDrop() {
    if (gameOver || paused) return;
    
    while (moveDown()) {
      // Keep moving down until collision
    }
  }
  
  // Rotate piece
  function rotate() {
    if (gameOver || paused) return;
    
    // Special case for O piece (square) - no rotation needed
    if (currentPiece.type === 2) return;
    
    // Save original shape for rollback
    const originalShape = JSON.parse(JSON.stringify(currentPiece.shape));
    
    // Special case for I piece
    if (currentPiece.type === 1) {
      // Check if horizontal or vertical
      const isHorizontal = currentPiece.shape[1][0] === 1;
      
      // Swap between horizontal and vertical
      if (isHorizontal) {
        currentPiece.shape = [
          [0, 0, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 1, 0],
          [0, 0, 1, 0]
        ];
      } else {
        currentPiece.shape = [
          [0, 0, 0, 0],
          [1, 1, 1, 1],
          [0, 0, 0, 0],
          [0, 0, 0, 0]
        ];
      }
    } else {
      // Regular rotation for other pieces
      const rotated = [];
      
      // Get size of the piece
      const n = currentPiece.shape.length;
      
      // Create n×n matrix
      for (let i = 0; i < n; i++) {
        rotated[i] = Array(n).fill(0);
      }
      
      // Rotate 90 degrees clockwise
      for (let y = 0; y < n; y++) {
        for (let x = 0; x < n; x++) {
          rotated[x][n - 1 - y] = currentPiece.shape[y][x];
        }
      }
      
      currentPiece.shape = rotated;
    }
    
    // Collision detection - try to fix with wall kicks
    if (checkCollision(currentPiece, 0, 0)) {
      // Try to move right
      if (!checkCollision(currentPiece, 1, 0)) {
        currentPiece.x++;
      }
      // Try to move left
      else if (!checkCollision(currentPiece, -1, 0)) {
        currentPiece.x--;
      }
      // Try to move up
      else if (!checkCollision(currentPiece, 0, -1)) {
        currentPiece.y--;
      }
      // Revert if still colliding
      else {
        currentPiece.shape = originalShape;
      }
    }
    
    draw();
  }
  
  // Lock piece in place and check for line clears
  function lockPiece() {
    // Add piece to board
    for (let y = 0; y < currentPiece.shape.length; y++) {
      for (let x = 0; x < currentPiece.shape[y].length; x++) {
        if (currentPiece.shape[y][x]) {
          // Check for game over if piece locks above the board
          if (currentPiece.y + y < 0) {
            gameOver = true;
            document.getElementById('pauseBtn').disabled = true;
            alert('Oyun Bitti! Skor: ' + score);
            
            // Save score
            try {
              fetch('/api/save-score', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                  game_type: 'tetris',
                  score: score,
                  difficulty: 'normal',
                  playtime: 0,
                  game_stats: { lines: lines, level: level }
                })
              });
            } catch(e) {
              console.error('Skor kaydedilemedi');
            }
            
            return;
          }
          
          // Add to board
          board[currentPiece.y + y][currentPiece.x + x] = currentPiece.type;
        }
      }
    }
    
    // Check for completed lines
    clearLines();
    
    // Get next piece
    currentPiece = nextPiece;
    nextPiece = createRandomPiece();
    drawNextPiece();
  }
  
  // Check and clear completed lines
  function clearLines() {
    let linesCleared = 0;
    
    // Check each line from bottom to top
    for (let y = ROWS - 1; y >= 0; y--) {
      let rowFull = true;
      
      // Check if row is full
      for (let x = 0; x < COLS; x++) {
        if (board[y][x] === 0) {
          rowFull = false;
          break;
        }
      }
      
      if (rowFull) {
        // Move all rows above down
        for (let y2 = y; y2 > 0; y2--) {
          for (let x = 0; x < COLS; x++) {
            board[y2][x] = board[y2-1][x];
          }
        }
        
        // Clear top row
        for (let x = 0; x < COLS; x++) {
          board[0][x] = 0;
        }
        
        // Increment count and check this row again
        linesCleared++;
        y++;
      }
    }
    
    // Update score if lines were cleared
    if (linesCleared > 0) {
      // Add to total lines cleared
      lines += linesCleared;
      
      // Calculate score
      const linePoints = [0, 40, 100, 300, 1200][linesCleared] * level;
      score += linePoints;
      
      // Update level (every 10 lines)
      level = Math.floor(lines / 10) + 1;
      
      // Increase speed with level
      dropInterval = Math.max(100, 1000 - (level - 1) * 100);
      
      // Update UI
      updateScore();
    }
  }
  
  // Update score display
  function updateScore() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
  }
  
  // Handle keyboard input
  function handleKeyPress(e) {
    if (gameOver) return;
    
    // Pause game
    if (e.key === 'p' || e.key === 'P') {
      togglePause();
      return;
    }
    
    if (paused) return;
    
    switch(e.key) {
      case 'ArrowLeft':
        moveLeft();
        break;
      case 'ArrowRight':
        moveRight();
        break;
      case 'ArrowDown':
        moveDown();
        break;
      case 'ArrowUp':
        rotate();
        break;
      case ' ': // Space
        hardDrop();
        break;
    }
  }
  
  // Initialize the game
  init();
});
</script>
{% endblock %}