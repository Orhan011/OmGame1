{% extends 'layout.html' %}

{% block title %}Tetris{% endblock %}

{% block content %}
<div class="game-container">
  <h1 class="game-title">Tetris</h1>
  
  <div class="tetris-wrapper">
    <!-- Next Piece Display -->
    <div class="next-piece-container">
      <div class="next-label">Sonraki Parça</div>
      <canvas id="nextCanvas" width="100" height="100"></canvas>
    </div>
    
    <!-- Main Game Board -->
    <div class="board-container">
      <canvas id="tetrisCanvas"></canvas>
    </div>
    
    <!-- Score Panel -->
    <div class="score-container">
      <div class="score-item">
        <span>Skor:</span>
        <span id="score">0</span>
      </div>
      <div class="score-item">
        <span>Seviye:</span>
        <span id="level">1</span>
      </div>
      <div class="score-item">
        <span>Satırlar:</span>
        <span id="lines">0</span>
      </div>
    </div>
  </div>
  
  <!-- Game Controls -->
  <div class="controls-container">
    <button id="startBtn" class="control-btn">Başlat</button>
    <button id="pauseBtn" class="control-btn" disabled>Duraklat</button>
    <button id="resetBtn" class="control-btn">Yeniden Başlat</button>
  </div>
</div>

<style>
  .game-container {
    max-width: 800px;
    margin: 0 auto;
    text-align: center;
  }
  
  .game-title {
    margin-bottom: 20px;
    color: #fff;
  }
  
  .tetris-wrapper {
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 15px;
  }
  
  .next-piece-container {
    background: rgba(0, 0, 0, 0.2);
    padding: 10px;
    border-radius: 10px;
    width: 350px;
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 20px;
  }
  
  .next-label {
    font-size: 18px;
    font-weight: bold;
    color: #fff;
  }
  
  #nextCanvas {
    background: rgba(0, 0, 0, 0.4);
    border-radius: 5px;
  }
  
  .board-container {
    margin: 0 auto;
  }
  
  #tetrisCanvas {
    background: rgba(0, 0, 0, 0.2);
    border-radius: 10px;
  }
  
  .score-container {
    background: rgba(0, 0, 0, 0.2);
    padding: 10px;
    border-radius: 10px;
    width: 350px;
    display: flex;
    justify-content: space-around;
  }
  
  .score-item {
    display: flex;
    flex-direction: column;
    align-items: center;
  }
  
  .score-item span:first-child {
    font-size: 14px;
    color: #ccc;
  }
  
  .score-item span:last-child {
    font-size: 24px;
    font-weight: bold;
    color: #fff;
    margin-top: 5px;
  }
  
  .controls-container {
    margin-top: 20px;
    display: flex;
    gap: 15px;
    justify-content: center;
  }
  
  .control-btn {
    padding: 10px 20px;
    font-size: 16px;
    border: none;
    border-radius: 5px;
    cursor: pointer;
    background: #6C5CE7;
    color: white;
    transition: all 0.2s;
  }
  
  .control-btn:hover {
    background: #5649c0;
  }
  
  .control-btn:disabled {
    background: #999;
    cursor: not-allowed;
  }
</style>

<script>
// Simple Tetris Game
document.addEventListener('DOMContentLoaded', function() {
  // Canvas Setup
  const canvas = document.getElementById('tetrisCanvas');
  const ctx = canvas.getContext('2d');
  
  const nextCanvas = document.getElementById('nextCanvas');
  const nextCtx = nextCanvas.getContext('2d');
  
  // Game Constants
  const COLS = 12;
  const ROWS = 18;
  const BLOCK_SIZE = 30;
  const NEXT_BLOCK_SIZE = 20;
  
  // Set canvas dimensions
  canvas.width = COLS * BLOCK_SIZE;
  canvas.height = ROWS * BLOCK_SIZE;
  
  // Game Variables
  let board = [];
  let currentPiece;
  let nextPiece;
  let score = 0;
  let level = 1;
  let lines = 0;
  let gameOver = false;
  let paused = false;
  let dropCounter = 0;
  let dropInterval = 1000; // ms
  let lastTime = 0;
  let gameTimer;
  
  // Tetromino Colors
  const COLORS = [
    null, // 0 - empty
    '#FF0D0D', // 1 - I - red
    '#0DFF72', // 2 - O - green
    '#0D72FF', // 3 - T - blue
    '#FFDD0D', // 4 - L - yellow
    '#DD0DFF', // 5 - J - purple
    '#FF720D', // 6 - S - orange
    '#0DFFFF'  // 7 - Z - cyan
  ];
  
  // Tetromino Shapes
  const SHAPES = [
    null,
    [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], // I
    [[2,2], [2,2]],                               // O
    [[0,3,0], [3,3,3], [0,0,0]],                  // T
    [[0,0,4], [4,4,4], [0,0,0]],                  // L
    [[5,0,0], [5,5,5], [0,0,0]],                  // J
    [[0,6,6], [6,6,0], [0,0,0]],                  // S
    [[7,7,0], [0,7,7], [0,0,0]]                   // Z
  ];
  
  // Initialize Game
  function init() {
    // Add event listeners
    document.getElementById('startBtn').addEventListener('click', startGame);
    document.getElementById('pauseBtn').addEventListener('click', togglePause);
    document.getElementById('resetBtn').addEventListener('click', resetGame);
    
    // Keyboard controls
    document.addEventListener('keydown', handleKeyPress);
    
    // Initialize board
    resetGame();
  }
  
  // Start Game
  function startGame() {
    if (gameOver || paused) {
      resetGame();
    }
    
    document.getElementById('startBtn').disabled = true;
    document.getElementById('pauseBtn').disabled = false;
    
    gameTimer = requestAnimationFrame(update);
  }
  
  // Reset Game
  function resetGame() {
    // Clear board
    board = Array.from({ length: ROWS }, () => Array(COLS).fill(0));
    
    // Reset stats
    score = 0;
    lines = 0;
    level = 1;
    gameOver = false;
    paused = false;
    dropInterval = 1000;
    
    // Create new pieces
    currentPiece = createPiece();
    nextPiece = createPiece();
    
    // Reset UI
    updateScore();
    document.getElementById('startBtn').disabled = false;
    document.getElementById('pauseBtn').disabled = true;
    document.getElementById('pauseBtn').textContent = 'Duraklat';
    
    // Draw initial state
    draw();
    drawNextPiece();
  }
  
  // Toggle Pause
  function togglePause() {
    if (gameOver) return;
    
    paused = !paused;
    
    if (paused) {
      document.getElementById('pauseBtn').textContent = 'Devam Et';
      cancelAnimationFrame(gameTimer);
    } else {
      document.getElementById('pauseBtn').textContent = 'Duraklat';
      lastTime = 0;
      gameTimer = requestAnimationFrame(update);
    }
  }
  
  // Create Piece
  function createPiece() {
    const type = Math.floor(Math.random() * 7) + 1;
    return {
      type: type,
      shape: SHAPES[type],
      x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
      y: 0
    };
  }
  
  // Game Loop
  function update(time = 0) {
    // Calculate delta time
    const deltaTime = time - lastTime;
    lastTime = time;
    
    // Auto-drop piece
    dropCounter += deltaTime;
    if (dropCounter > dropInterval) {
      moveDown();
      dropCounter = 0;
    }
    
    // Draw game state
    draw();
    
    // Continue loop if game is active
    if (!gameOver && !paused) {
      gameTimer = requestAnimationFrame(update);
    }
  }
  
  // Draw Game
  function draw() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw board
    for (let y = 0; y < ROWS; y++) {
      for (let x = 0; x < COLS; x++) {
        if (board[y][x]) {
          drawBlock(ctx, x, y, board[y][x], BLOCK_SIZE);
        }
      }
    }
    
    // Draw current piece
    if (currentPiece) {
      for (let y = 0; y < currentPiece.shape.length; y++) {
        for (let x = 0; x < currentPiece.shape[y].length; x++) {
          if (currentPiece.shape[y][x]) {
            drawBlock(
              ctx,
              currentPiece.x + x,
              currentPiece.y + y,
              currentPiece.type,
              BLOCK_SIZE
            );
          }
        }
      }
    }
    
    // Draw grid
    drawGrid();
  }
  
  // Draw Grid
  function drawGrid() {
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK_SIZE, 0);
      ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK_SIZE);
      ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.stroke();
    }
  }
  
  // Draw Next Piece
  function drawNextPiece() {
    nextCtx.clearRect(0, 0, nextCanvas.width, nextCanvas.height);
    
    if (!nextPiece) return;
    
    // Center the next piece in the canvas
    const offsetX = (nextCanvas.width - nextPiece.shape[0].length * NEXT_BLOCK_SIZE) / 2;
    const offsetY = (nextCanvas.height - nextPiece.shape.length * NEXT_BLOCK_SIZE) / 2;
    
    for (let y = 0; y < nextPiece.shape.length; y++) {
      for (let x = 0; x < nextPiece.shape[y].length; x++) {
        if (nextPiece.shape[y][x]) {
          drawBlock(
            nextCtx,
            x,
            y,
            nextPiece.type,
            NEXT_BLOCK_SIZE,
            offsetX,
            offsetY
          );
        }
      }
    }
  }
  
  // Draw Block
  function drawBlock(context, x, y, type, size, offsetX = 0, offsetY = 0) {
    const realX = x * size + offsetX;
    const realY = y * size + offsetY;
    
    // Block fill
    context.fillStyle = COLORS[type];
    context.fillRect(realX, realY, size, size);
    
    // Highlight effect
    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
    context.fillRect(realX, realY, size / 3, size / 3);
    
    // Block border
    context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
    context.lineWidth = 1;
    context.strokeRect(realX, realY, size, size);
  }
  
  // Check Collision
  function checkCollision(piece, offsetX, offsetY) {
    for (let y = 0; y < piece.shape.length; y++) {
      for (let x = 0; x < piece.shape[y].length; x++) {
        if (!piece.shape[y][x]) continue;
        
        const newX = piece.x + x + offsetX;
        const newY = piece.y + y + offsetY;
        
        // Check boundaries
        if (newX < 0 || newX >= COLS || newY >= ROWS) {
          return true;
        }
        
        // Skip above board
        if (newY < 0) continue;
        
        // Check board pieces
        if (board[newY][newX]) {
          return true;
        }
      }
    }
    return false;
  }
  
  // Move current piece left
  function moveLeft() {
    if (!checkCollision(currentPiece, -1, 0)) {
      currentPiece.x--;
    }
  }
  
  // Move current piece right
  function moveRight() {
    if (!checkCollision(currentPiece, 1, 0)) {
      currentPiece.x++;
    }
  }
  
  // Move current piece down
  function moveDown() {
    if (!checkCollision(currentPiece, 0, 1)) {
      currentPiece.y++;
      return true;
    }
    
    lockPiece();
    return false;
  }
  
  // Drop piece immediately
  function hardDrop() {
    while (moveDown()) {
      // Move down until collision
    }
  }
  
  // Rotate current piece
  function rotate() {
    const originalShape = currentPiece.shape;
    
    // Special case for I piece rotation
    if (currentPiece.type === 1) {
      const shapes = [
        [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]],
        [[0,0,1,0], [0,0,1,0], [0,0,1,0], [0,0,1,0]]
      ];
      
      // Check current shape
      const isHorizontal = JSON.stringify(currentPiece.shape) === 
                          JSON.stringify(shapes[0]);
      
      // Rotate to next shape
      currentPiece.shape = isHorizontal ? shapes[1] : shapes[0];
      
      // Check collision and revert if needed
      if (checkCollision(currentPiece, 0, 0)) {
        currentPiece.shape = originalShape;
      }
      
      return;
    }
    
    // Special case for O piece - no rotation needed
    if (currentPiece.type === 2) return;
    
    // Rotate shape
    const rotated = [];
    for (let x = 0; x < originalShape[0].length; x++) {
      const row = [];
      for (let y = originalShape.length - 1; y >= 0; y--) {
        row.push(originalShape[y][x]);
      }
      rotated.push(row);
    }
    
    currentPiece.shape = rotated;
    
    // Wall kicks - try to push away from walls if there's collision
    if (checkCollision(currentPiece, 0, 0)) {
      // Try to move right
      if (!checkCollision(currentPiece, 1, 0)) {
        currentPiece.x++;
      } 
      // Try to move left
      else if (!checkCollision(currentPiece, -1, 0)) {
        currentPiece.x--;
      } 
      // Try to move up (away from bottom)
      else if (!checkCollision(currentPiece, 0, -1)) {
        currentPiece.y--;
      } 
      // Revert to original shape if all kicks fail
      else {
        currentPiece.shape = originalShape;
      }
    }
  }
  
  // Lock piece and check for line clears
  function lockPiece() {
    for (let y = 0; y < currentPiece.shape.length; y++) {
      for (let x = 0; x < currentPiece.shape[y].length; x++) {
        if (currentPiece.shape[y][x]) {
          // Game over if piece locks above board
          if (currentPiece.y + y < 0) {
            gameOver = true;
            document.getElementById('pauseBtn').disabled = true;
            alert('Oyun Bitti! Skor: ' + score);
            saveScore();
            return;
          }
          
          // Add piece to board
          board[currentPiece.y + y][currentPiece.x + x] = currentPiece.type;
        }
      }
    }
    
    // Check for line clears
    checkLines();
    
    // Next piece becomes current
    currentPiece = nextPiece;
    nextPiece = createPiece();
    drawNextPiece();
  }
  
  // Check for completed lines
  function checkLines() {
    let linesCleared = 0;
    
    for (let y = ROWS - 1; y >= 0; y--) {
      let isRowFull = true;
      
      // Check if row is full
      for (let x = 0; x < COLS; x++) {
        if (board[y][x] === 0) {
          isRowFull = false;
          break;
        }
      }
      
      if (isRowFull) {
        // Remove the line and shift all above lines down
        for (let y2 = y; y2 > 0; y2--) {
          for (let x = 0; x < COLS; x++) {
            board[y2][x] = board[y2-1][x];
          }
        }
        
        // Clear the top row
        for (let x = 0; x < COLS; x++) {
          board[0][x] = 0;
        }
        
        // Check this row again
        y++;
        linesCleared++;
      }
    }
    
    // Update score if lines were cleared
    if (linesCleared > 0) {
      // Increase total lines cleared
      lines += linesCleared;
      
      // Calculate points based on lines cleared
      let linePoints = [0, 40, 100, 300, 1200][linesCleared] * level;
      score += linePoints;
      
      // Update level
      level = Math.floor(lines / 10) + 1;
      
      // Speed up as level increases
      dropInterval = 1000 * Math.pow(0.8, level - 1);
      
      // Update UI
      updateScore();
    }
  }
  
  // Update score display
  function updateScore() {
    document.getElementById('score').textContent = score;
    document.getElementById('level').textContent = level;
    document.getElementById('lines').textContent = lines;
  }
  
  // Handle keyboard controls
  function handleKeyPress(e) {
    if (gameOver) return;
    
    // Pause
    if (e.key === 'p' || e.key === 'P') {
      togglePause();
      return;
    }
    
    if (paused) return;
    
    switch(e.key) {
      case 'ArrowLeft':
        moveLeft();
        break;
      case 'ArrowRight':
        moveRight();
        break;
      case 'ArrowDown':
        moveDown();
        break;
      case 'ArrowUp':
        rotate();
        break;
      case ' ':
        hardDrop();
        break;
    }
  }
  
  // Save score to server
  function saveScore() {
    try {
      fetch('/api/save-score', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          game_type: 'tetris',
          score: score,
          difficulty: 'medium',
          playtime: 0,
          game_stats: {
            lines_cleared: lines,
            level: level
          }
        })
      })
      .then(res => res.json())
      .then(data => console.log('Score saved'))
      .catch(err => console.error('Error saving score'));
    } catch (error) {
      console.error('Failed to save score');
    }
  }
  
  // Initialize game
  init();
});
</script>
{% endblock %}