{% extends "layout.html" %}

{% block title %}Tetris{% endblock %}

{% block content %}
<div class="container">
  <div class="game-container">
    <h2>Tetris</h2>
    <canvas id="tetrisCanvas" width="300" height="600" style="border:1px solid #fff;"></canvas>
    <div class="game-controls">
      <button id="startGame" class="btn btn-primary">Ba≈ülat</button>
      <button id="pauseGame" class="btn btn-warning">Duraklat</button>
    </div>
    <div class="score">Skor: <span id="score">0</span></div>
  </div>
</div>
{% endblock %}

{% block styles %}
<style>
.game-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 20px;
  padding: 20px;
}

.container {
  display: flex;
  justify-content: center;
  align-items: center;
  min-height: 100vh;
}

#tetrisCanvas {
  background: rgba(0, 0, 0, 0.8);
  /*border: 2px solid var(--accent-color);*/
  border-radius: 10px;
}

.score {
  font-size: 20px;
  color: var(--accent-color);
}

.game-controls {
  display: flex;
  gap: 10px;
}
</style>
{% endblock %}

{% block scripts %}
<script>
const canvas = document.getElementById('tetrisCanvas');
const ctx = canvas.getContext('2d');
const startBtn = document.getElementById('startGame');
const pauseBtn = document.getElementById('pauseGame');
const scoreElement = document.getElementById('score');

const BLOCK_SIZE = 30;
const BOARD_WIDTH = 10;
const BOARD_HEIGHT = 20;
let board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
let score = 0;
let currentPiece = null;
let gameLoop = null;
let isPaused = false;

const PIECES = [
  [[1,1,1,1]], // I
  [[1,1],[1,1]], // O
  [[1,1,1],[0,1,0]], // T
  [[1,1,1],[1,0,0]], // L
  [[1,1,1],[0,0,1]], // J
  [[1,1,0],[0,1,1]], // S
  [[0,1,1],[1,1,0]]  // Z
];

function createPiece() {
  const piece = PIECES[Math.floor(Math.random() * PIECES.length)];
  return {
    shape: piece,
    x: Math.floor(BOARD_WIDTH/2) - Math.floor(piece[0].length/2),
    y: 0
  };
}

function draw() {
  ctx.fillStyle = '#000';
  ctx.fillRect(0, 0, canvas.width, canvas.height);

  // Draw board
  board.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        ctx.fillStyle = '#fff';
        ctx.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE-1, BLOCK_SIZE-1);
      }
    });
  });

  // Draw current piece
  if (currentPiece) {
    ctx.fillStyle = '#f00';
    currentPiece.shape.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value) {
          ctx.fillRect((currentPiece.x + x) * BLOCK_SIZE,
                      (currentPiece.y + y) * BLOCK_SIZE,
                      BLOCK_SIZE-1, BLOCK_SIZE-1);
        }
      });
    });
  }
}

function collides(piece, boardCopy = board) {
  return piece.shape.some((row, y) => {
    return row.some((value, x) => {
      let newX = piece.x + x;
      let newY = piece.y + y;
      return (
        value &&
        (newX < 0 || newX >= BOARD_WIDTH ||
         newY >= BOARD_HEIGHT ||
         boardCopy[newY]?.[newX])
      );
    });
  });
}

function merge() {
  currentPiece.shape.forEach((row, y) => {
    row.forEach((value, x) => {
      if (value) {
        board[currentPiece.y + y][currentPiece.x + x] = value;
      }
    });
  });
}

function clearLines() {
  let linesCleared = 0;

  board.forEach((row, y) => {
    if (row.every(value => value === 1)) {
      board.splice(y, 1);
      board.unshift(Array(BOARD_WIDTH).fill(0));
      linesCleared++;
    }
  });

  if (linesCleared > 0) {
    score += linesCleared * 100;
    scoreElement.textContent = score;
  }
}

function update() {
  if (isPaused) return;

  currentPiece.y++;

  if (collides(currentPiece)) {
    currentPiece.y--;
    merge();
    clearLines();
    currentPiece = createPiece();

    if (collides(currentPiece)) {
      clearInterval(gameLoop);
      gameLoop = null;
      alert('Oyun Bitti! Skor: ' + score);
    }
  }

  draw();
}

function rotate(piece) {
  let newShape = piece.shape[0].map((_, i) =>
    piece.shape.map(row => row[i]).reverse()
  );

  let newPiece = {
    ...piece,
    shape: newShape
  };

  if (!collides(newPiece)) {
    piece.shape = newShape;
  }
}

document.addEventListener('keydown', (e) => {
  if (!gameLoop || isPaused) return;

  switch(e.key) {
    case 'ArrowLeft':
      currentPiece.x--;
      if (collides(currentPiece)) currentPiece.x++;
      break;
    case 'ArrowRight':
      currentPiece.x++;
      if (collides(currentPiece)) currentPiece.x--;
      break;
    case 'ArrowDown':
      currentPiece.y++;
      if (collides(currentPiece)) currentPiece.y--;
      break;
    case 'ArrowUp':
      rotate(currentPiece);
      break;
  }
  draw();
});

startBtn.addEventListener('click', () => {
  if (!gameLoop) {
    board = Array(BOARD_HEIGHT).fill().map(() => Array(BOARD_WIDTH).fill(0));
    score = 0;
    scoreElement.textContent = score;
    currentPiece = createPiece();
    gameLoop = setInterval(update, 500);
  }
});

pauseBtn.addEventListener('click', () => {
  isPaused = !isPaused;
  pauseBtn.textContent = isPaused ? 'Devam Et' : 'Duraklat';
});

draw();
</script>
{% endblock %}