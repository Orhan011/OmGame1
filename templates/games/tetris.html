{% extends 'layout.html' %}

{% block title %}Tetris - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>Tetris <span class="badge">Klasik Blok Oyunu</span></h1>
    </div>

    <div class="tetris-container">
      <div class="tetris-layout">
        <!-- Oyun Alanı -->
        <div class="tetris-board-container">
          <canvas id="tetris-canvas" width="300" height="600"></canvas>
        </div>

        <!-- Sağ Panel -->
        <div class="tetris-info-panel">
          <!-- Skor Bilgisi -->
          <div class="tetris-score-panel">
            <div class="tetris-score-item">
              <div class="tetris-score-label">Skor</div>
              <div class="tetris-score-value" id="score">0</div>
            </div>
            <div class="tetris-score-item">
              <div class="tetris-score-label">Seviye</div>
              <div class="tetris-score-value" id="level">1</div>
            </div>
            <div class="tetris-score-item">
              <div class="tetris-score-label">Satırlar</div>
              <div class="tetris-score-value" id="lines">0</div>
            </div>
          </div>

          <!-- Sonraki Parça -->
          <div class="tetris-next-piece">
            <div class="tetris-next-label">Sonraki Parça</div>
            <canvas id="next-piece-canvas" width="100" height="100"></canvas>
          </div>

          <!-- Oyun Kontrolleri -->
          <div class="tetris-controls">
            <button id="start-button" class="btn btn-primary btn-lg">Başlat</button>
            <button id="pause-button" class="btn btn-secondary btn-lg" disabled>Duraklat</button>
            <button id="reset-button" class="btn btn-danger btn-lg">Yeniden Başlat</button>
          </div>

          <!-- Oyun Kontrolleri Bilgisi -->
          <div class="tetris-help">
            <div class="tetris-help-title">Kontroller</div>
            <div class="tetris-help-items">
              <div class="tetris-help-item">
                <div class="tetris-key">←</div>
                <span>Sol</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">→</div>
                <span>Sağ</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↓</div>
                <span>Aşağı</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↑</div>
                <span>Döndür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">Boşluk</div>
                <span>Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">P</div>
                <span>Duraklat</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<!-- CSS Stil -->
<style>
  .tetris-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 10px;
  }

  .tetris-layout {
    display: flex;
    gap: 20px;
    flex-wrap: wrap;
    justify-content: center;
  }

  .tetris-info-panel {
    width: 250px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .tetris-score-panel {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 10px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-score-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
  }

  .tetris-score-label {
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
  }

  .tetris-score-value {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  .tetris-next-piece {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-next-label {
    text-align: center;
    margin-bottom: 8px;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.8);
  }

  #next-piece-canvas {
    display: block;
    margin: 0 auto;
    background: rgba(20, 20, 40, 0.5);
  }

  .tetris-controls {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    display: flex;
    flex-direction: column;
    gap: 8px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-help {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-help-title {
    margin-bottom: 10px;
    font-size: 1rem;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
  }

  .tetris-help-items {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: 8px;
  }

  .tetris-help-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .tetris-key {
    background: rgba(106, 90, 224, 0.3);
    padding: 4px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    min-width: 25px;
    text-align: center;
    color: var(--accent-color);
  }

  .tetris-help-item span {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
  }

  .tetris-board-container {
    position: relative;
    width: 300px;
    height: 600px;
  }

  #tetris-canvas {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 100%;
    height: 100%;
  }

  @media (max-width: 768px) {
    .tetris-layout {
      flex-direction: column;
      align-items: center;
    }
    
    .tetris-board-container {
      width: 280px;
      height: 560px;
    }
    
    .tetris-info-panel {
      width: 280px;
      margin-top: 15px;
    }
  }
</style>

<!-- Javascript -->
<script>
/**
 * Sade Tetris Oyunu
 */

// Oyun değişkenleri
let canvas, ctx;
let nextCanvas, nextCtx;
let scoreElement, levelElement, linesElement;
let board = [];
let dropCounter = 0;
let dropInterval = 1000;
let lastTime = 0;
let isGameOver = false;
let isPaused = false;
let piece, nextPiece;
let score = 0;
let lines = 0;
let level = 1;

// Oyun sabitleri
const COLS = 10;
const ROWS = 20;
const BLOCK_SIZE = 30;
const PREVIEW_BLOCK_SIZE = 20;

// Tetris parça renkleri
const COLORS = [
  null,
  '#FF3F3F', // I - Kırmızı
  '#3FFF7F', // O - Yeşil
  '#3F7FFF', // T - Mavi
  '#FFDF3F', // L - Sarı
  '#3FFFFF', // J - Açık Mavi
  '#FF3FFF', // S - Mor
  '#FF7F3F'  // Z - Turuncu
];

// Tetromino şekilleri
const SHAPES = [
  null,
  [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]], // I
  [[2, 2], [2, 2]],                                         // O
  [[0, 3, 0], [3, 3, 3], [0, 0, 0]],                        // T
  [[0, 0, 4], [4, 4, 4], [0, 0, 0]],                        // L
  [[5, 0, 0], [5, 5, 5], [0, 0, 0]],                        // J
  [[0, 6, 6], [6, 6, 0], [0, 0, 0]],                        // S
  [[7, 7, 0], [0, 7, 7], [0, 0, 0]]                         // Z
];

// DOM yüklendikten sonra çalış
document.addEventListener('DOMContentLoaded', init);

function init() {
  // Canvas elementlerini al
  canvas = document.getElementById('tetris-canvas');
  ctx = canvas.getContext('2d');
  
  nextCanvas = document.getElementById('next-piece-canvas');
  nextCtx = nextCanvas.getContext('2d');
  
  // Skor elementlerini al
  scoreElement = document.getElementById('score');
  levelElement = document.getElementById('level');
  linesElement = document.getElementById('lines');
  
  // Butonlara event listener ekle
  document.getElementById('start-button').addEventListener('click', startGame);
  document.getElementById('pause-button').addEventListener('click', togglePause);
  document.getElementById('reset-button').addEventListener('click', resetGame);
  
  // Klavye kontrollerini ekle
  document.addEventListener('keydown', handleKeyPress);
  
  // Oyun tahtasını oluştur
  resetGame();
}

// Klavye tuşlarını işle
function handleKeyPress(e) {
  if (isGameOver) return;
  
  if (e.key === 'p' || e.key === 'P') {
    togglePause();
    return;
  }
  
  if (isPaused) return;
  
  switch(e.key) {
    case 'ArrowLeft':
      moveLeft();
      break;
    case 'ArrowRight':
      moveRight();
      break;
    case 'ArrowDown':
      moveDown();
      break;
    case 'ArrowUp':
      rotate();
      break;
    case ' ': // Boşluk tuşu
      hardDrop();
      break;
  }
}

// Oyunu başlat
function startGame() {
  if (isGameOver || isPaused) {
    resetGame();
  }
  
  // Duraklat düğmesini aktif et
  document.getElementById('pause-button').disabled = false;
  document.getElementById('start-button').disabled = true;
  
  // Oyun döngüsünü başlat
  requestAnimationFrame(update);
}

// Oyunu sıfırla
function resetGame() {
  // Oyun değişkenlerini sıfırla
  board = createBoard();
  isGameOver = false;
  isPaused = false;
  score = 0;
  lines = 0;
  level = 1;
  dropInterval = 1000;
  
  // Parçaları oluştur
  piece = createPiece();
  nextPiece = createPiece();
  
  // Skoru güncelle
  updateScore();
  
  // Başlat düğmesini aktif et
  document.getElementById('start-button').disabled = false;
  document.getElementById('pause-button').disabled = true;
  
  // Oyun alanını çiz
  draw();
  drawNextPiece();
}

// Oyunu duraklat
function togglePause() {
  if (isGameOver) return;
  
  isPaused = !isPaused;
  
  if (isPaused) {
    document.getElementById('pause-button').textContent = 'Devam Et';
  } else {
    document.getElementById('pause-button').textContent = 'Duraklat';
    // Oyun döngüsünü devam ettir
    requestAnimationFrame(update);
  }
}

// Oyun tahtası oluştur
function createBoard() {
  const board = [];
  for (let r = 0; r < ROWS; r++) {
    board[r] = [];
    for (let c = 0; c < COLS; c++) {
      board[r][c] = 0;
    }
  }
  return board;
}

// Rastgele parça oluştur
function createPiece() {
  const type = Math.floor(Math.random() * 7) + 1;
  const piece = {
    type: type,
    shape: SHAPES[type],
    x: Math.floor(COLS / 2) - Math.floor(SHAPES[type][0].length / 2),
    y: 0
  };
  return piece;
}

// Ana oyun döngüsü
function update(time = 0) {
  if (isGameOver || isPaused) return;
  
  const deltaTime = time - lastTime;
  lastTime = time;
  
  dropCounter += deltaTime;
  if (dropCounter > dropInterval) {
    moveDown();
    dropCounter = 0;
  }
  
  draw();
  requestAnimationFrame(update);
}

// Oyun alanını çiz
function draw() {
  clearCanvas(ctx, canvas.width, canvas.height);
  drawBoard();
  drawPiece();
}

// Oyun tahtasını çiz
function drawBoard() {
  for (let r = 0; r < ROWS; r++) {
    for (let c = 0; c < COLS; c++) {
      if (board[r][c]) {
        drawBlock(ctx, c, r, board[r][c]);
      }
    }
  }
}

// Aktif parçayı çiz
function drawPiece() {
  if (!piece) return;
  
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (piece.shape[r][c]) {
        drawBlock(ctx, piece.x + c, piece.y + r, piece.type);
      }
    }
  }
}

// Sonraki parçayı çiz
function drawNextPiece() {
  clearCanvas(nextCtx, nextCanvas.width, nextCanvas.height);
  
  if (!nextPiece) return;
  
  // Merkezi hesapla
  const centerX = (nextCanvas.width - nextPiece.shape[0].length * PREVIEW_BLOCK_SIZE) / 2;
  const centerY = (nextCanvas.height - nextPiece.shape.length * PREVIEW_BLOCK_SIZE) / 2;
  
  for (let r = 0; r < nextPiece.shape.length; r++) {
    for (let c = 0; c < nextPiece.shape[r].length; c++) {
      if (nextPiece.shape[r][c]) {
        nextCtx.fillStyle = COLORS[nextPiece.type];
        nextCtx.fillRect(
          centerX + c * PREVIEW_BLOCK_SIZE, 
          centerY + r * PREVIEW_BLOCK_SIZE, 
          PREVIEW_BLOCK_SIZE, 
          PREVIEW_BLOCK_SIZE
        );
        
        nextCtx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
        nextCtx.lineWidth = 1;
        nextCtx.strokeRect(
          centerX + c * PREVIEW_BLOCK_SIZE, 
          centerY + r * PREVIEW_BLOCK_SIZE, 
          PREVIEW_BLOCK_SIZE, 
          PREVIEW_BLOCK_SIZE
        );
      }
    }
  }
}

// Bir blok çiz
function drawBlock(context, x, y, type) {
  context.fillStyle = COLORS[type];
  context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  
  context.strokeStyle = 'rgba(255, 255, 255, 0.2)';
  context.lineWidth = 1;
  context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  
  // Parlama efekti
  context.fillStyle = 'rgba(255, 255, 255, 0.2)';
  context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE / 3, BLOCK_SIZE / 3);
}

// Canvas'ı temizle
function clearCanvas(context, width, height) {
  context.clearRect(0, 0, width, height);
}

// Çarpışma kontrolü
function checkCollision(shape, x, y) {
  for (let r = 0; r < shape.length; r++) {
    for (let c = 0; c < shape[r].length; c++) {
      // Boş hücreleri atla
      if (!shape[r][c]) continue;
      
      // Oyun alanı koordinatlarını hesapla
      const boardX = x + c;
      const boardY = y + r;
      
      // Sınır kontrolleri
      if (boardX < 0 || boardX >= COLS || boardY >= ROWS) {
        return true;
      }
      
      // Üst sınırın üzerinde olup olmadığını kontrol et
      if (boardY < 0) continue;
      
      // Diğer parçalarla çarpışma kontrolü
      if (board[boardY][boardX]) {
        return true;
      }
    }
  }
  return false;
}

// Parçayı sola hareket ettir
function moveLeft() {
  if (!piece) return;
  
  const newX = piece.x - 1;
  if (!checkCollision(piece.shape, newX, piece.y)) {
    piece.x = newX;
    draw();
  }
}

// Parçayı sağa hareket ettir
function moveRight() {
  if (!piece) return;
  
  const newX = piece.x + 1;
  if (!checkCollision(piece.shape, newX, piece.y)) {
    piece.x = newX;
    draw();
  }
}

// Parçayı aşağı hareket ettir
function moveDown() {
  if (!piece) return;
  
  const newY = piece.y + 1;
  if (!checkCollision(piece.shape, piece.x, newY)) {
    piece.y = newY;
    draw();
    return true;
  } else {
    lockPiece();
    return false;
  }
}

// Parçayı anında düşür
function hardDrop() {
  if (!piece) return;
  
  while(moveDown()) {
    // Parça yere düşene kadar aşağı taşı
  }
}

// Parçayı kilitle
function lockPiece() {
  if (!piece) return;
  
  for (let r = 0; r < piece.shape.length; r++) {
    for (let c = 0; c < piece.shape[r].length; c++) {
      if (piece.shape[r][c]) {
        // Oyun alanının üstüne çıkarsa oyun biter
        if (piece.y + r < 0) {
          gameOver();
          return;
        }
        
        // Parçayı tahta üzerine yerleştir
        board[piece.y + r][piece.x + c] = piece.type;
      }
    }
  }
  
  // Tamamlanan satırları kontrol et
  checkLines();
  
  // Yeni parça oluştur
  piece = nextPiece;
  nextPiece = createPiece();
  drawNextPiece();
}

// Tamamlanan satırları kontrol et
function checkLines() {
  let linesCleared = 0;
  
  for (let r = ROWS - 1; r >= 0; r--) {
    let rowFull = true;
    
    // Satırın dolu olup olmadığını kontrol et
    for (let c = 0; c < COLS; c++) {
      if (board[r][c] === 0) {
        rowFull = false;
        break;
      }
    }
    
    if (rowFull) {
      // Satırı temizle ve üstündekileri aşağı indir
      for (let y = r; y > 0; y--) {
        for (let c = 0; c < COLS; c++) {
          board[y][c] = board[y-1][c];
        }
      }
      
      // En üst satırı temizle
      for (let c = 0; c < COLS; c++) {
        board[0][c] = 0;
      }
      
      // Temizlenen satır sayısını artır
      linesCleared++;
      
      // Aynı satırı tekrar kontrol et
      r++;
    }
  }
  
  // Temizlenen satır varsa skoru güncelle
  if (linesCleared > 0) {
    // Toplam satır sayısını güncelle
    lines += linesCleared;
    
    // Skor hesapla
    const points = [0, 40, 100, 300, 1200][linesCleared] * level;
    score += points;
    
    // Seviye kontrolü
    const newLevel = Math.floor(lines / 10) + 1;
    if (newLevel > level) {
      level = newLevel;
      // Düşüş hızını güncelle (her seviyede %10 daha hızlı)
      dropInterval = 1000 * Math.pow(0.9, level - 1);
    }
    
    // Skoru güncelle
    updateScore();
  }
}

// Oyun sonu
function gameOver() {
  isGameOver = true;
  document.getElementById('pause-button').disabled = true;
  
  // Skoru kaydet
  saveScore();
  
  // Kullanıcıyı bilgilendir
  alert(`Oyun bitti! Skor: ${score}`);
}

// Skoru güncelle
function updateScore() {
  if (scoreElement) scoreElement.textContent = score;
  if (levelElement) levelElement.textContent = level;
  if (linesElement) linesElement.textContent = lines;
}

// Parçayı döndür
function rotate() {
  if (!piece) return;
  
  // I parçası (çubuk) özel döndürme
  if (piece.type === 1) {
    // I parçası için özel döndürme şekilleri
    const I_SHAPES = [
      [[0, 0, 0, 0], [1, 1, 1, 1], [0, 0, 0, 0], [0, 0, 0, 0]],
      [[0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0], [0, 0, 1, 0]]
    ];
    
    // Mevcut şekil ilk şekil mi kontrol et
    const currentShape = JSON.stringify(piece.shape);
    const firstShape = JSON.stringify(I_SHAPES[0]);
    
    // Şekli değiştir
    piece.shape = (currentShape === firstShape) ? I_SHAPES[1] : I_SHAPES[0];
    
    // Çarpışma kontrolü
    if (checkCollision(piece.shape, piece.x, piece.y)) {
      // Önceki şekline geri döndür
      piece.shape = (currentShape === firstShape) ? I_SHAPES[0] : I_SHAPES[1];
    }
    
    draw();
    return;
  }
  
  // O parçası (kare) dönmez
  if (piece.type === 2) {
    return;
  }
  
  // Diğer parçalar için normal döndürme
  const oldShape = piece.shape;
  
  // Yeni döndürülmüş şekli oluştur
  const rotated = [];
  for (let c = 0; c < oldShape[0].length; c++) {
    const row = [];
    for (let r = oldShape.length - 1; r >= 0; r--) {
      row.push(oldShape[r][c]);
    }
    rotated.push(row);
  }
  
  // Yeni şekli uygula
  piece.shape = rotated;
  
  // Çarpışma kontrolü
  if (checkCollision(piece.shape, piece.x, piece.y)) {
    // Duvar tepmesi - sağa doğru itelemeyi dene
    if (!checkCollision(piece.shape, piece.x + 1, piece.y)) {
      piece.x++;
    }
    // Duvar tepmesi - sola doğru itelemeyi dene
    else if (!checkCollision(piece.shape, piece.x - 1, piece.y)) {
      piece.x--;
    }
    // Yukarı doğru itelemeyi dene
    else if (!checkCollision(piece.shape, piece.x, piece.y - 1)) {
      piece.y--;
    }
    // Hiçbiri işe yaramazsa, önceki şekline geri döndür
    else {
      piece.shape = oldShape;
    }
  }
  
  draw();
}

// Skoru kaydet
function saveScore() {
  try {
    // Oyun istatistiklerini topla
    const gameStats = {
      lines_cleared: lines,
      level: level,
      duration_seconds: Math.floor(Date.now() / 1000) - Math.floor(lastTime / 1000)
    };
    
    // API'ye skoru gönder
    fetch('/api/save-score', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        game_type: 'tetris',
        score: score,
        difficulty: 'medium',
        playtime: gameStats.duration_seconds,
        game_stats: gameStats
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log("Score saved:", data);
    })
    .catch(err => console.error("Skor kaydetme hatası:", err));
  } catch (e) {
    console.error("Skor kaydetme işleminde hata:", e);
  }
}
</script>
{% endblock %}