{% extends 'layout.html' %}

{% block title %}Tetris - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>TETRIS <span class="badge">Marathon</span></h1>
      <p class="game-description">Düşen blokları doğru yerleştirerek çizgileri tamamlayın.</p>
    </div>

    <div class="tetris-container">
      <div class="tetris-layout">
        <div class="tetris-side-panel left-panel">
          <div class="tetris-hold-panel">
            <div class="tetris-panel-label">HOLD</div>
            <canvas id="hold-piece-canvas" width="100" height="100"></canvas>
          </div>
        </div>

        <div class="tetris-board-container">
          <canvas id="tetris-canvas" width="300" height="600"></canvas>
          
          <div id="tetris-overlay" class="tetris-overlay">
            <div class="tetris-overlay-content" id="pause-overlay" style="display: none;">
              <h2><i class="fas fa-pause me-2"></i>Oyun Duraklatıldı</h2>
              <p>Devam etmek için "Devam Et" düğmesine basın</p>
              <button id="resume-game" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Devam Et
              </button>
            </div>
            
            <div class="tetris-overlay-content" id="game-start-overlay">
              <h2>TETRIS</h2>
              <p>Modern Tetris oyununa hoş geldiniz!</p>
              <p>Düşen blokları yerleştirin ve çizgiler oluşturun</p>
              <button id="start-button" class="btn btn-primary btn-lg">
                <i class="fas fa-play me-2"></i>Oyuna Başla
              </button>
            </div>
            
            <div class="tetris-overlay-content" id="game-over-overlay" style="display: none;">
              <h2><i class="fas fa-trophy me-2"></i>Oyun Bitti!</h2>
              <div class="tetris-final-score">
                <div class="tetris-final-score-label">Final Skoru</div>
                <div class="tetris-final-score-value" id="final-score">0</div>
              </div>
              <button id="play-again" class="btn btn-primary btn-lg">
                <i class="fas fa-redo-alt me-2"></i>Tekrar Oyna
              </button>
              <a href="{{ url_for('all_games') }}" class="btn btn-outline-light btn-lg mt-3">
                <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
              </a>
            </div>
          </div>
        </div>

        <div class="tetris-side-panel right-panel">
          <div class="tetris-next-piece">
            <div class="tetris-panel-label">NEXT</div>
            <div class="tetris-next-pieces-container">
              <canvas id="next-piece-1-canvas" width="80" height="80"></canvas>
              <canvas id="next-piece-2-canvas" width="80" height="80"></canvas>
              <canvas id="next-piece-3-canvas" width="80" height="80"></canvas>
              <canvas id="next-piece-4-canvas" width="80" height="80"></canvas>
              <canvas id="next-piece-5-canvas" width="80" height="80"></canvas>
            </div>
          </div>
          
          <div class="tetris-stats">
            <div class="tetris-stat-item">
              <div class="tetris-stat-label">LEVEL</div>
              <div class="tetris-stat-value" id="level">1</div>
            </div>
            <div class="tetris-stat-item">
              <div class="tetris-stat-label">LINES</div>
              <div class="tetris-stat-value" id="lines">0</div>
            </div>
            <div class="tetris-stat-item">
              <div class="tetris-stat-label">SCORE</div>
              <div class="tetris-stat-value" id="score">0</div>
            </div>
            <div class="tetris-stat-item">
              <div class="tetris-stat-label">TIME</div>
              <div class="tetris-stat-value" id="time">00:00</div>
            </div>
          </div>
          
          <div class="tetris-controls">
            <button id="start-game" class="btn btn-primary btn-lg">
              <i class="fas fa-play me-2"></i>Başla
            </button>
            <button id="pause-game" class="btn btn-outline-light" disabled>
              <i class="fas fa-pause me-2"></i>Duraklat
            </button>
            <button id="reset-game" class="btn btn-outline-danger">
              <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
            </button>
          </div>

          <div class="tetris-help">
            <h4 class="tetris-help-title"><i class="fas fa-keyboard me-2"></i>Kontroller</h4>
            <div class="tetris-help-items">
              <div class="tetris-help-item">
                <div class="tetris-key">←</div>
                <span>Sola Hareket</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">→</div>
                <span>Sağa Hareket</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↓</div>
                <span>Hızlı Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">↑</div>
                <span>Döndür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">Boşluk</div>
                <span>Anında Düşür</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">C</div>
                <span>Parçayı Tut</span>
              </div>
              <div class="tetris-help-item">
                <div class="tetris-key">P</div>
                <span>Duraklat</span>
              </div>
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .tetris-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 0 10px;
  }

  .tetris-layout {
    display: flex;
    gap: 10px;
    justify-content: center;
    align-items: flex-start;
  }

  .tetris-side-panel {
    width: 130px;
    display: flex;
    flex-direction: column;
    gap: 15px;
  }

  .left-panel {
    width: 120px;
  }

  .right-panel {
    width: 150px;
  }

  .tetris-panel-label {
    text-align: center;
    margin-bottom: 10px;
    font-size: 1.1rem;
    font-weight: 600;
    color: white;
    letter-spacing: 1px;
  }

  .tetris-hold-panel, .tetris-next-piece, .tetris-stats, .tetris-controls, .tetris-help {
    background: rgba(25, 25, 45, 0.7);
    border-radius: 15px;
    padding: 15px;
    box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2);
  }

  .tetris-next-pieces-container {
    display: flex;
    flex-direction: column;
    gap: 15px;
    align-items: center;
  }

  .tetris-next-pieces-container canvas, #hold-piece-canvas {
    display: block;
    background: rgba(20, 20, 40, 0.5);
    border-radius: 8px;
  }

  .tetris-stat-item {
    margin-bottom: 15px;
    text-align: center;
  }

  .tetris-stat-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.9);
    font-weight: 600;
    letter-spacing: 1px;
    margin-bottom: 5px;
  }

  .tetris-stat-value {
    font-size: 1.3rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  .tetris-controls {
    display: flex;
    flex-direction: column;
    gap: 8px;
  }

  .tetris-help-title {
    margin-bottom: 10px;
    font-size: 0.95rem;
    color: rgba(255, 255, 255, 0.9);
    text-align: center;
  }

  .tetris-help-items {
    display: grid;
    grid-template-columns: 1fr;
    gap: 8px;
  }

  .tetris-help-item {
    display: flex;
    align-items: center;
    gap: 8px;
  }

  .tetris-key {
    background: rgba(106, 90, 224, 0.3);
    padding: 4px 8px;
    border-radius: 5px;
    font-size: 0.8rem;
    min-width: 25px;
    text-align: center;
    color: var(--accent-color);
  }

  .tetris-help-item span {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.7);
  }

  .tetris-board-container {
    position: relative;
    width: 300px;
    height: 600px;
  }

  #tetris-canvas {
    background: rgba(15, 15, 35, 0.95);
    border-radius: 15px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
    width: 100%;
    height: 100%;
  }

  .tetris-overlay {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 15, 35, 0.9);
    display: flex;
    justify-content: center;
    align-items: center;
    border-radius: 15px;
    z-index: 10;
  }

  .tetris-overlay-content {
    text-align: center;
    padding: 20px;
    max-width: 90%;
  }

  .tetris-overlay-content h2 {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 1.6rem;
  }

  .tetris-overlay-content p {
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
    font-size: 0.95rem;
  }

  .tetris-final-score {
    background: rgba(40, 40, 80, 0.5);
    border-radius: 15px;
    padding: 15px;
    margin: 15px 0 20px;
  }

  .tetris-final-score-label {
    font-size: 0.95rem;
    color: rgba(255, 255, 255, 0.8);
    margin-bottom: 8px;
  }

  .tetris-final-score-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: var(--accent-color);
  }

  /* Mobile Responsive */
  @media (max-width: 768px) {
    .tetris-layout {
      flex-direction: column;
      align-items: center;
      gap: 15px;
    }
    
    .tetris-side-panel {
      width: 100%;
      max-width: 350px;
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      gap: 10px;
    }

    .left-panel {
      display: none; /* Hide hold panel on mobile */
    }
    
    .tetris-hold-panel, .tetris-next-piece, .tetris-stats, .tetris-controls {
      width: 48%;
      min-width: 150px;
    }
    
    .tetris-help {
      width: 100%;
    }
    
    .tetris-next-pieces-container {
      flex-direction: row;
      flex-wrap: wrap;
      justify-content: center;
      gap: 5px;
    }
    
    .tetris-next-pieces-container canvas {
      width: 60px;
      height: 60px;
    }
    
    .tetris-board-container {
      width: 80vw;
      max-width: 300px;
      height: 160vw;
      max-height: 600px;
    }
    
    .tetris-help-items {
      grid-template-columns: 1fr 1fr;
    }
  }
  
  /* Handle Landscape Mobile */
  @media (max-width: 1000px) and (max-height: 600px) and (orientation: landscape) {
    .tetris-layout {
      flex-direction: row;
      align-items: flex-start;
    }
    
    .tetris-side-panel {
      width: 120px;
      flex-direction: column;
    }
    
    .tetris-board-container {
      width: 50vh;
      height: 90vh;
      max-height: 500px;
    }
    
    .tetris-next-pieces-container canvas {
      width: 50px;
      height: 50px;
    }
    
    .tetris-help-items {
      grid-template-columns: 1fr;
    }
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const canvas = document.getElementById('tetris-canvas');
  const holdPieceCanvas = document.getElementById('hold-piece-canvas');
  const nextPiece1Canvas = document.getElementById('next-piece-1-canvas');
  const nextPiece2Canvas = document.getElementById('next-piece-2-canvas');
  const nextPiece3Canvas = document.getElementById('next-piece-3-canvas');
  const nextPiece4Canvas = document.getElementById('next-piece-4-canvas');
  const nextPiece5Canvas = document.getElementById('next-piece-5-canvas');
  
  const scoreElement = document.getElementById('score');
  const levelElement = document.getElementById('level');
  const linesElement = document.getElementById('lines');
  const timeElement = document.getElementById('time');
  const finalScoreElement = document.getElementById('final-score');
  
  // Canvas boyutlarını ayarla
  if (canvas) {
    canvas.width = 300;
    canvas.height = 600;
  }
  
  const startButton = document.getElementById('start-button');
  const startGameButton = document.getElementById('start-game');
  const pauseGameButton = document.getElementById('pause-game');
  const resetGameButton = document.getElementById('reset-game');
  const resumeGameButton = document.getElementById('resume-game');
  const playAgainButton = document.getElementById('play-again');
  
  const tetrisOverlay = document.getElementById('tetris-overlay');
  const gameStartOverlay = document.getElementById('game-start-overlay');
  const pauseOverlay = document.getElementById('pause-overlay');
  const gameOverOverlay = document.getElementById('game-over-overlay');

  // Eğer gerekli DOM elementleri bulunamazsa, erken dön
  if (!canvas || !nextPiece1Canvas) {
    console.error('Gerekli canvas elementleri bulunamadı!');
    return;
  }
  
  // Game Constants
  const ROWS = 20;
  const COLS = 10;
  const BLOCK_SIZE = 30;
  const SHAPES = [
    // I Piece
    {
      matrix: [
        [0, 0, 0, 0],
        [1, 1, 1, 1],
        [0, 0, 0, 0],
        [0, 0, 0, 0]
      ],
      color: '#00f0f0' // Cyan
    },
    // J Piece
    {
      matrix: [
        [2, 0, 0],
        [2, 2, 2],
        [0, 0, 0]
      ],
      color: '#0000f0' // Blue
    },
    // L Piece
    {
      matrix: [
        [0, 0, 3],
        [3, 3, 3],
        [0, 0, 0]
      ],
      color: '#f0a000' // Orange
    },
    // O Piece
    {
      matrix: [
        [4, 4],
        [4, 4]
      ],
      color: '#f0f000' // Yellow
    },
    // S Piece
    {
      matrix: [
        [0, 5, 5],
        [5, 5, 0],
        [0, 0, 0]
      ],
      color: '#00f000' // Green
    },
    // T Piece
    {
      matrix: [
        [0, 6, 0],
        [6, 6, 6],
        [0, 0, 0]
      ],
      color: '#a000f0' // Purple
    },
    // Z Piece
    {
      matrix: [
        [7, 7, 0],
        [0, 7, 7],
        [0, 0, 0]
      ],
      color: '#f00000' // Red
    }
  ];
  
  // Resize canvas based on container size
  function resizeCanvas() {
    const container = document.querySelector('.tetris-board-container');
    if (!container) return;
    
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;
    
    // Calculate block size based on container dimensions
    const blockSizeW = containerWidth / COLS;
    const blockSizeH = containerHeight / ROWS;
    
    // Set canvas dimensions
    canvas.width = containerWidth;
    canvas.height = containerHeight;
    
    // Update drawing scale
    ctx.scale(blockSizeW / BLOCK_SIZE, blockSizeH / BLOCK_SIZE);
    
    // Redraw if game is in progress
    if (!gameOver && !paused) {
      drawBoard();
    }
  }
  
  // Game variables
  const ctx = canvas.getContext('2d');
  const holdCtx = holdPieceCanvas?.getContext('2d');
  const nextCtx1 = nextPiece1Canvas.getContext('2d');
  const nextCtx2 = nextPiece2Canvas.getContext('2d');
  const nextCtx3 = nextPiece3Canvas.getContext('2d');
  const nextCtx4 = nextPiece4Canvas.getContext('2d');
  const nextCtx5 = nextPiece5Canvas.getContext('2d');
  
  let board = createBoard();
  let animationId = null;
  let gameOver = false;
  let paused = false;
  let score = 0;
  let level = 1;
  let lines = 0;
  let dropInterval = 1000; // milliseconds
  let lastDropTime = 0;
  let gameStartTime = 0;
  let gameTotalTime = 0;
  let gameTimerInterval = null;
  
  let player = {
    matrix: null,
    pos: {x: 0, y: 0},
    color: ''
  };
  
  let holdPiece = {
    matrix: null,
    color: '',
    used: false
  };
  
  let nextPieces = Array(5).fill().map(() => ({
    matrix: null,
    color: ''
  }));
  
  // Create empty game board
  function createBoard() {
    return Array.from(
      {length: ROWS}, () => Array(COLS).fill(0)
    );
  }
  
  // Initialize the game
  function init() {
    // Reset board
    board = createBoard();
    
    // Reset game variables
    score = 0;
    level = 1;
    lines = 0;
    dropInterval = 1000;
    gameOver = false;
    paused = false;
    gameStartTime = 0;
    gameTotalTime = 0;
    
    // Reset hold piece
    holdPiece = {
      matrix: null,
      color: '',
      used: false
    };
    
    // Update UI
    scoreElement.textContent = score;
    levelElement.textContent = level;
    linesElement.textContent = lines;
    timeElement.textContent = "00:00";
    
    // Generate next pieces
    nextPieces = Array(5).fill().map(() => {
      const pieceIndex = Math.floor(Math.random() * SHAPES.length);
      return {
        matrix: SHAPES[pieceIndex].matrix,
        color: SHAPES[pieceIndex].color
      };
    });
    
    // Start with a new piece
    resetPlayer();
    
    // Hide overlays
    tetrisOverlay.style.display = 'flex';
    gameStartOverlay.style.display = 'block';
    pauseOverlay.style.display = 'none';
    gameOverOverlay.style.display = 'none';
    
    // Update button states
    pauseGameButton.disabled = true;
    
    // Draw board and pieces
    drawBoard();
    drawHoldPiece();
    drawNextPieces();
    
    // Clear any existing timer
    if (gameTimerInterval) {
      clearInterval(gameTimerInterval);
      gameTimerInterval = null;
    }
  }
  
  // Start the game
  function startGame() {
    // Hide overlays
    tetrisOverlay.style.display = 'none';
    
    // Start game timer
    gameStartTime = Date.now();
    gameTimerInterval = setInterval(updateGameTimer, 1000);
    
    // Start game loop
    lastDropTime = performance.now();
    if (animationId) {
      cancelAnimationFrame(animationId);
    }
    gameLoop();
    
    // Update button states
    pauseGameButton.disabled = false;
  }
  
  // Update game timer
  function updateGameTimer() {
    if (!gameOver && !paused) {
      const currentTime = Date.now();
      gameTotalTime = Math.floor((currentTime - gameStartTime) / 1000);
      
      // Format time as MM:SS
      const minutes = Math.floor(gameTotalTime / 60).toString().padStart(2, '0');
      const seconds = (gameTotalTime % 60).toString().padStart(2, '0');
      timeElement.textContent = `${minutes}:${seconds}`;
    }
  }
  
  // Pause the game
  function pauseGame() {
    if (gameOver) return;
    
    paused = true;
    cancelAnimationFrame(animationId);
    
    // Show pause overlay
    tetrisOverlay.style.display = 'flex';
    pauseOverlay.style.display = 'block';
  }
  
  // Resume the game
  function resumeGame() {
    paused = false;
    tetrisOverlay.style.display = 'none';
    lastDropTime = performance.now();
    gameLoop();
  }
  
  // Game loop
  function gameLoop(time = 0) {
    const deltaTime = time - lastDropTime;
    
    if (deltaTime > dropInterval) {
      drop();
      lastDropTime = time;
    }
    
    drawBoard();
    animationId = requestAnimationFrame(gameLoop);
  }
  
  // Draw the board and current piece
  function drawBoard() {
    // Clear canvas
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    // Draw board background
    ctx.fillStyle = 'rgba(10, 10, 25, 0.5)';
    ctx.fillRect(0, 0, COLS * BLOCK_SIZE, ROWS * BLOCK_SIZE);
    
    // Draw grid lines
    ctx.strokeStyle = 'rgba(40, 40, 60, 0.4)';
    ctx.lineWidth = 1;
    
    // Vertical lines
    for (let x = 0; x <= COLS; x++) {
      ctx.beginPath();
      ctx.moveTo(x * BLOCK_SIZE, 0);
      ctx.lineTo(x * BLOCK_SIZE, ROWS * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Horizontal lines
    for (let y = 0; y <= ROWS; y++) {
      ctx.beginPath();
      ctx.moveTo(0, y * BLOCK_SIZE);
      ctx.lineTo(COLS * BLOCK_SIZE, y * BLOCK_SIZE);
      ctx.stroke();
    }
    
    // Draw board pieces
    board.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Get color based on piece type
          const color = SHAPES[value - 1].color;
          drawBlock(ctx, x, y, color);
        }
      });
    });
    
    // Draw ghost piece (shadow of where piece will land)
    drawGhostPiece();
    
    // Draw current piece
    if (player.matrix) {
      player.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            drawBlock(ctx, x + player.pos.x, y + player.pos.y, player.color);
          }
        });
      });
    }
  }
  
  // Draw a single block
  function drawBlock(context, x, y, color) {
    // Main block
    context.fillStyle = color;
    context.fillRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    // Draw block border
    context.strokeStyle = 'rgba(0, 0, 0, 0.2)';
    context.lineWidth = 2;
    context.strokeRect(x * BLOCK_SIZE, y * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
    
    // Draw block highlight
    context.fillStyle = 'rgba(255, 255, 255, 0.2)';
    context.beginPath();
    context.moveTo(x * BLOCK_SIZE, y * BLOCK_SIZE);
    context.lineTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
    context.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    context.fill();
    
    // Draw block shadow
    context.fillStyle = 'rgba(0, 0, 0, 0.1)';
    context.beginPath();
    context.moveTo((x + 1) * BLOCK_SIZE, y * BLOCK_SIZE);
    context.lineTo((x + 1) * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    context.lineTo(x * BLOCK_SIZE, (y + 1) * BLOCK_SIZE);
    context.fill();
  }
  
  // Draw ghost piece (shadow of where piece will land)
  function drawGhostPiece() {
    if (!player.matrix) return;
    
    // Create a copy of player position
    const ghostPos = {
      x: player.pos.x,
      y: player.pos.y
    };
    
    // Move ghost down until collision
    while (!checkCollision(player.matrix, ghostPos)) {
      ghostPos.y++;
    }
    
    // Move back up one
    ghostPos.y--;
    
    // Draw ghost piece
    ctx.globalAlpha = 0.2;
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          drawBlock(ctx, x + ghostPos.x, y + ghostPos.y, player.color);
        }
      });
    });
    ctx.globalAlpha = 1;
  }
  
  // Draw hold piece
  function drawHoldPiece() {
    if (!holdCtx) return;
    
    // Clear hold piece canvas
    holdCtx.clearRect(0, 0, holdPieceCanvas.width, holdPieceCanvas.height);
    
    // Draw background
    holdCtx.fillStyle = 'rgba(10, 10, 25, 0.5)';
    holdCtx.fillRect(0, 0, holdPieceCanvas.width, holdPieceCanvas.height);
    
    if (holdPiece.matrix) {
      // Calculate block size for the hold piece
      const blockSize = Math.min(
        holdPieceCanvas.width / (holdPiece.matrix[0].length + 2),
        holdPieceCanvas.height / (holdPiece.matrix.length + 2)
      );
      
      // Calculate offset to center the piece
      const offset = {
        x: (holdPieceCanvas.width - holdPiece.matrix[0].length * blockSize) / 2 / blockSize,
        y: (holdPieceCanvas.height - holdPiece.matrix.length * blockSize) / 2 / blockSize
      };
      
      // Set alpha based on whether the hold piece is used
      holdCtx.globalAlpha = holdPiece.used ? 0.5 : 1;
      
      // Draw hold piece
      holdPiece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            // Scale down for the hold piece canvas
            const scaledX = (x + offset.x) * blockSize;
            const scaledY = (y + offset.y) * blockSize;
            const scaledBlockSize = blockSize;
            
            // Draw block
            holdCtx.fillStyle = holdPiece.color;
            holdCtx.fillRect(scaledX, scaledY, scaledBlockSize, scaledBlockSize);
            
            // Draw block border
            holdCtx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            holdCtx.lineWidth = 1;
            holdCtx.strokeRect(scaledX, scaledY, scaledBlockSize, scaledBlockSize);
            
            // Draw block highlight
            holdCtx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            holdCtx.beginPath();
            holdCtx.moveTo(scaledX, scaledY);
            holdCtx.lineTo(scaledX + scaledBlockSize, scaledY);
            holdCtx.lineTo(scaledX, scaledY + scaledBlockSize);
            holdCtx.fill();
            
            // Draw block shadow
            holdCtx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            holdCtx.beginPath();
            holdCtx.moveTo(scaledX + scaledBlockSize, scaledY);
            holdCtx.lineTo(scaledX + scaledBlockSize, scaledY + scaledBlockSize);
            holdCtx.lineTo(scaledX, scaledY + scaledBlockSize);
            holdCtx.fill();
          }
        });
      });
      
      holdCtx.globalAlpha = 1;
    }
  }
  
  // Draw next pieces
  function drawNextPieces() {
    const nextContexts = [nextCtx1, nextCtx2, nextCtx3, nextCtx4, nextCtx5];
    const nextCanvases = [nextPiece1Canvas, nextPiece2Canvas, nextPiece3Canvas, nextPiece4Canvas, nextPiece5Canvas];
    
    nextPieces.forEach((piece, index) => {
      if (!piece.matrix || !nextContexts[index]) return;
      
      const ctx = nextContexts[index];
      const canvas = nextCanvases[index];
      
      // Clear canvas
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      
      // Draw background
      ctx.fillStyle = 'rgba(10, 10, 25, 0.5)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      
      // Calculate block size for the next piece
      const blockSize = Math.min(
        canvas.width / (piece.matrix[0].length + 2),
        canvas.height / (piece.matrix.length + 2)
      );
      
      // Calculate offset to center the piece
      const offset = {
        x: (canvas.width - piece.matrix[0].length * blockSize) / 2 / blockSize,
        y: (canvas.height - piece.matrix.length * blockSize) / 2 / blockSize
      };
      
      // Draw next piece
      piece.matrix.forEach((row, y) => {
        row.forEach((value, x) => {
          if (value !== 0) {
            // Scale down for the next piece canvas
            const scaledX = (x + offset.x) * blockSize;
            const scaledY = (y + offset.y) * blockSize;
            const scaledBlockSize = blockSize;
            
            // Draw block
            ctx.fillStyle = piece.color;
            ctx.fillRect(scaledX, scaledY, scaledBlockSize, scaledBlockSize);
            
            // Draw block border
            ctx.strokeStyle = 'rgba(0, 0, 0, 0.2)';
            ctx.lineWidth = 1;
            ctx.strokeRect(scaledX, scaledY, scaledBlockSize, scaledBlockSize);
            
            // Draw block highlight
            ctx.fillStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.beginPath();
            ctx.moveTo(scaledX, scaledY);
            ctx.lineTo(scaledX + scaledBlockSize, scaledY);
            ctx.lineTo(scaledX, scaledY + scaledBlockSize);
            ctx.fill();
            
            // Draw block shadow
            ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
            ctx.beginPath();
            ctx.moveTo(scaledX + scaledBlockSize, scaledY);
            ctx.lineTo(scaledX + scaledBlockSize, scaledY + scaledBlockSize);
            ctx.lineTo(scaledX, scaledY + scaledBlockSize);
            ctx.fill();
          }
        });
      });
    });
  }
  
  // Reset player with next piece
  function resetPlayer() {
    // Get the first piece from next pieces
    player.matrix = nextPieces[0].matrix;
    player.color = nextPieces[0].color;
    
    // Shift next pieces array
    for (let i = 0; i < nextPieces.length - 1; i++) {
      nextPieces[i] = nextPieces[i + 1];
    }
    
    // Generate a new piece for the last position
    const pieceIndex = Math.floor(Math.random() * SHAPES.length);
    nextPieces[nextPieces.length - 1] = {
      matrix: SHAPES[pieceIndex].matrix,
      color: SHAPES[pieceIndex].color
    };
    
    // Update next pieces preview
    drawNextPieces();
    
    // Set position at top-center
    player.pos.y = 0;
    player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
    
    // Check for game over
    if (checkCollision()) {
      endGame();
    }
  }
  
  // Hold current piece
  function holdCurrentPiece() {
    if (holdPiece.used) return; // Can't use hold twice in a row
    
    // If hold is empty, store the current piece and get the next one
    if (holdPiece.matrix === null) {
      holdPiece.matrix = player.matrix;
      holdPiece.color = player.color;
      holdPiece.used = true;
      resetPlayer();
    } else {
      // Swap current piece with hold piece
      const tempMatrix = player.matrix;
      const tempColor = player.color;
      
      player.matrix = holdPiece.matrix;
      player.color = holdPiece.color;
      holdPiece.matrix = tempMatrix;
      holdPiece.color = tempColor;
      holdPiece.used = true;
      
      // Reset position
      player.pos.y = 0;
      player.pos.x = Math.floor(COLS / 2) - Math.floor(player.matrix[0].length / 2);
      
      // Check for collision after swap
      if (checkCollision()) {
        // If collision, revert the swap
        player.matrix = holdPiece.matrix;
        player.color = holdPiece.color;
        holdPiece.matrix = tempMatrix;
        holdPiece.color = tempColor;
        holdPiece.used = false;
      }
    }
    
    // Update hold piece preview
    drawHoldPiece();
  }

  function endGame() {
    gameOver = true;
    cancelAnimationFrame(animationId);
    
    // Stop the game timer
    if (gameTimerInterval) {
      clearInterval(gameTimerInterval);
      gameTimerInterval = null;
    }

    // Update final results
    finalScoreElement.textContent = score;
    
    // Save score to the server
    saveScore(score);
    
    // Show game over overlay
    tetrisOverlay.style.display = 'flex';
    gameOverOverlay.style.display = 'block';
    
    // Update button states
    pauseGameButton.disabled = true;
  }
  
  // Function to save score to the server
  function saveScore(score) {
    fetch('/api/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'tetris',
        score: score
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log('Score saved:', data);
    })
    .catch(error => {
      console.error('Error saving score:', error);
    });
  }
  
  // Move piece down
  function drop() {
    player.pos.y++;
    
    // Check for collision
    if (checkCollision()) {
      player.pos.y--;
      mergePiece();
      resetPlayer();
      
      // Reset hold piece used flag
      holdPiece.used = false;
      drawHoldPiece();
      
      // Check for line clears
      checkLines();
    }
  }
  
  // Hard drop piece
  function hardDrop() {
    while (!checkCollision()) {
      player.pos.y++;
      // Add 1 point per cell dropped (modern scoring)
      score += 1;
    }
    
    player.pos.y--;
    mergePiece();
    resetPlayer();
    
    // Reset hold piece used flag
    holdPiece.used = false;
    drawHoldPiece();
    
    // Check for line clears
    checkLines();
    
    // Update score display
    scoreElement.textContent = score;
  }
  
  // Move piece horizontally
  function move(dir) {
    player.pos.x += dir;
    
    if (checkCollision()) {
      player.pos.x -= dir;
    }
  }
  
  // Rotate piece
  function rotate() {
    const matrix = player.matrix;
    const N = matrix.length;
    
    // Create rotated matrix
    const rotated = Array.from(
      {length: N}, () => Array(N).fill(0)
    );
    
    // Perform rotation (90 degrees clockwise)
    for (let y = 0; y < N; y++) {
      for (let x = 0; x < N; x++) {
        rotated[x][N - 1 - y] = matrix[y][x];
      }
    }
    
    // Save original matrix
    const originalMatrix = player.matrix;
    const originalPos = { ...player.pos };
    
    // Try rotation
    player.matrix = rotated;
    
    // If collision, try wall kick
    if (checkCollision()) {
      // Try moving left
      player.pos.x--;
      
      // If still collision, try moving right
      if (checkCollision()) {
        player.pos.x += 2;
        
        // If still collision, try moving up one
        if (checkCollision()) {
          player.pos.y--;
          
          // If still collision, try moving up and left
          if (checkCollision()) {
            player.pos.x -= 2;
            
            // If still collision, try moving up and right
            if (checkCollision()) {
              player.pos.x += 2;
              
              // If all wall kicks fail, revert to original position and matrix
              player.pos = { ...originalPos };
              player.matrix = originalMatrix;
            }
          }
        }
      }
    }
    
    // Play rotation sound
    const audio = new Audio('/static/sounds/click.mp3');
    audio.volume = 0.3;
    audio.play().catch(err => console.log('Ses çalma hatası:', err));
  }
  
  // Check for collision
  function checkCollision(matrix = player.matrix, pos = player.pos) {
    if (!matrix) return false;
    
    for (let y = 0; y < matrix.length; y++) {
      for (let x = 0; x < matrix[y].length; x++) {
        if (matrix[y][x] !== 0 &&
            (board[y + pos.y] === undefined ||
             board[y + pos.y][x + pos.x] === undefined ||
             board[y + pos.y][x + pos.x] !== 0)) {
          return true;
        }
      }
    }
    
    return false;
  }
  
  // Merge piece with board
  function mergePiece() {
    player.matrix.forEach((row, y) => {
      row.forEach((value, x) => {
        if (value !== 0) {
          // Store the piece type (1-7) on the board
          const pieceType = SHAPES.findIndex(shape => 
            JSON.stringify(shape.matrix) === JSON.stringify(player.matrix)) + 1;
          board[y + player.pos.y][x + player.pos.x] = pieceType > 0 ? pieceType : 1;
        }
      });
    });
  }
  
  // Check for completed lines
  function checkLines() {
    let linesCleared = 0;
    
    // Check each row from bottom to top
    for (let y = ROWS - 1; y >= 0; y--) {
      // Check if row is full
      if (board[y].every(value => value !== 0)) {
        // Remove row
        board.splice(y, 1);
        
        // Add empty row at top
        board.unshift(Array(COLS).fill(0));
        
        // Increment lines cleared
        linesCleared++;
        
        // Check the same row again (since rows shifted down)
        y++;
      }
    }
    
    // Update score and level if lines were cleared
    if (linesCleared > 0) {
      // Update lines
      lines += linesCleared;
      linesElement.textContent = lines;
      
      // Modern Tetris scoring
      // 100 * level for single, 300 * level for double, 500 * level for triple, 800 * level for tetris
      const linePoints = [0, 100, 300, 500, 800];
      score += linePoints[linesCleared] * level;
      
      // Update score display
      scoreElement.textContent = score;
      
      // Check for level up (every 10 lines)
      if (Math.floor(lines / 10) + 1 > level) {
        level = Math.floor(lines / 10) + 1;
        levelElement.textContent = level;
        
        // Increase speed (modern Tetris gets faster with each level)
        dropInterval = Math.max(100, 1000 - (level - 1) * 50);
        
        // Play level up sound
        const audio = new Audio('/static/sounds/level-up.mp3');
        audio.play().catch(err => console.log('Ses çalma hatası:', err));
      } else {
        // Play line clear sound
        const audio = new Audio('/static/sounds/success.mp3');
        audio.play().catch(err => console.log('Ses çalma hatası:', err));
      }
    }
  }
  
  // Keyboard controls
  document.addEventListener('keydown', event => {
    if (gameOver || paused) return;
    
    switch(event.key) {
      case 'ArrowLeft':
        move(-1);
        event.preventDefault();
        break;
      case 'ArrowRight':
        move(1);
        event.preventDefault();
        break;
      case 'ArrowDown':
        drop();
        event.preventDefault();
        break;
      case 'ArrowUp':
        rotate();
        event.preventDefault();
        break;
      case ' ':
        hardDrop();
        event.preventDefault();
        break;
      case 'c':
      case 'C':
        holdCurrentPiece();
        event.preventDefault();
        break;
      case 'p':
      case 'P':
        pauseGame();
        event.preventDefault();
        break;
    }
  });
  
  // Touch controls for mobile
  let touchStartX = null;
  let touchStartY = null;
  let touchStartTime = 0;
  
  canvas.addEventListener('touchstart', function(e) {
    if (gameOver || paused) return;
    
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchStartTime = Date.now();
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchmove', function(e) {
    if (gameOver || paused || touchStartX === null) return;
    
    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    
    const diffX = touchX - touchStartX;
    const diffY = touchY - touchStartY;
    
    // Require minimum movement to trigger action
    const minSwipe = 20;
    
    if (Math.abs(diffX) > Math.abs(diffY) && Math.abs(diffX) > minSwipe) {
      // Horizontal swipe
      if (diffX > 0) {
        move(1); // Right
      } else {
        move(-1); // Left
      }
      touchStartX = touchX;
      touchStartY = touchY;
    } else if (Math.abs(diffY) > Math.abs(diffX) && diffY > minSwipe) {
      // Downward swipe
      drop();
      touchStartX = touchX;
      touchStartY = touchY;
    }
    
    e.preventDefault();
  }, { passive: false });
  
  canvas.addEventListener('touchend', function(e) {
    const touchEndTime = Date.now();
    const touchDuration = touchEndTime - touchStartTime;
    
    // If it was a quick tap (less than 250ms), rotate
    if (touchDuration < 250) {
      rotate();
    }
    
    touchStartX = null;
    touchStartY = null;
  });
  
  // Long press for hard drop
  let longPressTimer;
  
  canvas.addEventListener('touchstart', function(e) {
    if (gameOver || paused) return;
    
    longPressTimer = setTimeout(function() {
      hardDrop();
    }, 500); // 500ms for long press
  });
  
  canvas.addEventListener('touchend', function() {
    clearTimeout(longPressTimer);
  });
  
  canvas.addEventListener('touchmove', function() {
    clearTimeout(longPressTimer);
  });
  
  // Button event listeners
  startButton.addEventListener('click', startGame);
  startGameButton.addEventListener('click', startGame);
  pauseGameButton.addEventListener('click', pauseGame);
  resetGameButton.addEventListener('click', init);
  resumeGameButton.addEventListener('click', resumeGame);
  playAgainButton.addEventListener('click', function() {
    init();
    startGame();
  });
  
  // Window resize event
  window.addEventListener('resize', resizeCanvas);
  
  // Initialize game
  init();
  resizeCanvas();
});
</script>
{% endblock %}
{% endblock %}
