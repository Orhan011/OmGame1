{% extends 'layout.html' %}

{% block title %}Hafıza Eşleştirme - ZekaPark{% endblock %}

{% block content %}
<div class="page-container">
  <div class="game-container">
    <div class="game-header">
      <h1>Hafıza Eşleştirme <span class="badge">Görsel Hafıza</span></h1>
      <p class="game-description">Eşleşen kartları bularak görsel hafıza ve odaklanma becerilerinizi geliştirin.</p>
    </div>

    <div class="memory-match-container">
      <div class="memory-stats">
        <div class="memory-stat">
          <div class="memory-stat-label">Hamleler</div>
          <div class="memory-stat-value" id="moves-count">0</div>
        </div>
        <div class="memory-stat">
          <div class="memory-stat-label">Eşleşmeler</div>
          <div class="memory-stat-value" id="matches-count">0</div>
        </div>
        <div class="memory-stat">
          <div class="memory-stat-label">Süre</div>
          <div class="memory-stat-value" id="timer">00:00</div>
        </div>
      </div>

      <div class="difficulty-selector">
        <button class="difficulty-btn active" data-difficulty="easy">Kolay</button>
        <button class="difficulty-btn" data-difficulty="medium">Orta</button>
        <button class="difficulty-btn" data-difficulty="hard">Zor</button>
      </div>

      <div class="memory-board-container">
        <div id="memory-board" class="memory-board easy"></div>
      </div>

      <div class="game-controls">
        <button id="restart-btn" class="btn btn-primary">
          <i class="fas fa-redo-alt me-2"></i>Yeniden Başlat
        </button>
        <a href="{{ url_for('all_games') }}" class="btn btn-outline-secondary">
          <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
        </a>
      </div>
      
      <div class="game-instructions">
        <h4 class="instruction-title"><i class="fas fa-info-circle"></i>Nasıl Oynanır?</h4>
        <ul class="instruction-list">
          <li>Yüzü kapalı kartları çevirerek eşleşen çiftleri bulmaya çalışın.</li>
          <li>Her seferde sadece iki kart açabilirsiniz.</li>
          <li>Kartlar eşleştiğinde açık kalırlar, eşleşmezlerse tekrar kapanırlar.</li>
          <li>Tüm çiftleri en az hamle ile bulmaya çalışın.</li>
          <li>Farklı zorluk seviyeleri için daha fazla kart çifti ile oynayabilirsiniz.</li>
        </ul>
      </div>
    </div>

    <div id="success-modal" class="memory-success-modal">
      <div class="success-content">
        <h2><i class="fas fa-trophy me-2"></i>Tebrikler!</h2>
        <p>Tüm kartları başarıyla eşleştirdiniz!</p>
        
        <div class="success-stats">
          <div class="success-stat">
            <div class="success-stat-value" id="final-moves">0</div>
            <div class="success-stat-label">Toplam Hamle</div>
          </div>
          <div class="success-stat">
            <div class="success-stat-value" id="final-time">00:00</div>
            <div class="success-stat-label">Geçen Süre</div>
          </div>
        </div>
        
        <div class="success-actions">
          <button id="play-again-btn" class="btn btn-primary btn-lg">
            <i class="fas fa-redo-alt me-2"></i>Tekrar Oyna
          </button>
          <a href="{{ url_for('all_games') }}" class="btn btn-outline-light btn-lg">
            <i class="fas fa-th-large me-2"></i>Tüm Oyunlar
          </a>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .memory-match-container {
    max-width: 100%;
    margin: 0 auto;
    padding: 25px;
    background: rgba(20, 20, 35, 0.4);
    border-radius: 20px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.25);
    backdrop-filter: blur(10px);
    border: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    overflow: hidden;
  }
  
  .memory-match-container::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 5px;
    background: linear-gradient(to right, #7a6aff, #a890ff, #7a6aff);
    z-index: 1;
  }

  .memory-stats {
    display: flex;
    justify-content: space-between;
    background: rgba(35, 35, 70, 0.6);
    border-radius: 15px;
    margin-bottom: 20px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(106, 90, 224, 0.2);
    transition: all 0.3s ease;
  }
  
  .memory-stats:hover {
    box-shadow: 0 8px 20px rgba(106, 90, 224, 0.3);
    transform: translateY(-2px);
  }

  .memory-stat {
    flex: 1;
    text-align: center;
    padding: 15px;
    border-right: 1px solid rgba(255, 255, 255, 0.1);
    position: relative;
    transition: all 0.3s ease;
  }
  
  .memory-stat::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2px;
    background: linear-gradient(to right, transparent, rgba(106, 90, 224, 0.5), transparent);
    transform: scaleX(0);
    transition: transform 0.3s ease;
  }
  
  .memory-stat:hover::after {
    transform: scaleX(1);
  }

  .memory-stat:last-child {
    border-right: none;
  }

  .memory-stat-label {
    font-size: 0.9rem;
    color: rgba(255, 255, 255, 0.7);
    margin-bottom: 5px;
    font-weight: 500;
    letter-spacing: 0.5px;
    text-transform: uppercase;
  }

  .memory-stat-value {
    font-size: 1.8rem;
    font-weight: 700;
    color: var(--accent-color);
    text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    transition: all 0.3s ease;
  }
  
  .memory-stat:hover .memory-stat-value {
    transform: scale(1.1);
  }

  .difficulty-selector {
    display: flex;
    margin-bottom: 20px;
    border-radius: 15px;
    overflow: hidden;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
  }

  .difficulty-btn {
    flex: 1;
    padding: 12px;
    border: none;
    background: rgba(35, 35, 70, 0.6);
    color: white;
    cursor: pointer;
    transition: all 0.3s ease;
    font-weight: 600;
    position: relative;
    overflow: hidden;
    letter-spacing: 0.5px;
  }
  
  .difficulty-btn::before {
    content: '';
    position: absolute;
    top: -50%;
    left: -50%;
    width: 200%;
    height: 200%;
    background: radial-gradient(circle, rgba(255, 255, 255, 0.2), transparent);
    opacity: 0;
    transform: scale(0.5);
    transition: all 0.4s ease;
  }
  
  .difficulty-btn:hover::before {
    opacity: 1;
    transform: scale(1);
  }

  .difficulty-btn.active {
    background: linear-gradient(135deg, #6a5ae0, #a890ff);
    box-shadow: inset 0 2px 5px rgba(0, 0, 0, 0.2);
  }
  
  .difficulty-btn:not(.active):hover {
    background: rgba(50, 50, 90, 0.8);
  }

  .memory-board-container {
    display: flex;
    justify-content: center;
    margin-bottom: 25px;
    perspective: 1000px;
    position: relative;
  }
  
  .memory-board-container::after {
    content: '';
    position: absolute;
    width: 100%;
    height: 100%;
    top: 0;
    left: 0;
    background: radial-gradient(circle at center, transparent 60%, rgba(20, 20, 35, 0.4) 100%);
    pointer-events: none;
    z-index: -1;
  }

  .memory-board {
    display: grid;
    gap: 12px;
    background: rgba(30, 30, 55, 0.8);
    padding: 20px;
    border-radius: 15px;
    box-shadow: 0 15px 35px rgba(0, 0, 0, 0.3);
    border: 1px solid rgba(106, 90, 224, 0.2);
    transition: all 0.3s ease;
  }

  .memory-board.easy {
    grid-template-columns: repeat(4, 1fr);
    grid-template-rows: repeat(3, 1fr);
  }

  .memory-board.medium {
    grid-template-columns: repeat(5, 1fr);
    grid-template-rows: repeat(4, 1fr);
  }

  .memory-board.hard {
    grid-template-columns: repeat(6, 1fr);
    grid-template-rows: repeat(5, 1fr);
  }

  .memory-card {
    width: 80px;
    height: 80px;
    position: relative;
    transform-style: preserve-3d;
    transform: scale(1);
    transition: transform 0.6s cubic-bezier(0.175, 0.885, 0.32, 1.275);
    cursor: pointer;
  }

  .memory-card:active {
    transform: scale(0.95);
  }

  .memory-card.flip {
    transform: rotateY(180deg);
  }

  .memory-card-front, .memory-card-back {
    width: 100%;
    height: 100%;
    position: absolute;
    border-radius: 12px;
    backface-visibility: hidden;
    display: flex;
    justify-content: center;
    align-items: center;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    transform-style: preserve-3d;
  }

  .memory-card-front {
    background: linear-gradient(135deg, #6a5ae0, #a890ff);
    transform: rotateY(180deg);
    border: 2px solid rgba(255, 255, 255, 0.2);
    position: relative;
    overflow: hidden;
  }
  
  .memory-card-front::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: linear-gradient(135deg, rgba(255, 255, 255, 0.3), transparent);
    opacity: 0.5;
  }

  .memory-card-back {
    background: url('/static/images/card-pattern.svg'), linear-gradient(135deg, #2c3e50, #1a1a2e);
    background-size: cover;
    border: 2px solid rgba(255, 255, 255, 0.1);
    transform: rotateY(0deg);
    position: relative;
    overflow: hidden;
  }
  
  .memory-card-back::after {
    content: '?';
    position: absolute;
    font-size: 2rem;
    font-weight: 700;
    color: rgba(255, 255, 255, 0.3);
    opacity: 0.5;
  }
  
  .memory-card:hover .memory-card-back {
    box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
    transform: rotateY(0deg) translateY(-5px);
  }

  .memory-card-front i {
    font-size: 2.2rem;
    color: white;
    text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    z-index: 1;
    opacity: 0;
    animation: iconAppear 0.3s forwards;
    animation-delay: 0.2s;
  }
  
  @keyframes iconAppear {
    from { opacity: 0; transform: scale(0.5) rotate(-15deg); }
    to { opacity: 1; transform: scale(1) rotate(0deg); }
  }

  .game-controls {
    display: flex;
    justify-content: center;
    gap: 15px;
    margin-bottom: 25px;
  }
  
  .game-controls .btn {
    padding: 12px 25px;
    font-weight: 600;
    border-radius: 50px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
    letter-spacing: 0.5px;
  }
  
  .game-controls .btn:hover {
    transform: translateY(-3px);
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
  }
  
  .game-controls .btn:active {
    transform: translateY(1px);
  }
  
  .game-controls .btn::after {
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 5px;
    height: 5px;
    background: rgba(255, 255, 255, 0.3);
    opacity: 0;
    border-radius: 100%;
    transform: scale(1) translate(-50%, -50%);
    transform-origin: 50% 50%;
  }
  
  .game-controls .btn:active::after {
    opacity: 1;
    animation: ripple 0.6s linear;
  }
  
  @keyframes ripple {
    0% {
      opacity: 1;
      transform: scale(0) translate(-50%, -50%);
    }
    100% {
      opacity: 0;
      transform: scale(20) translate(-50%, -50%);
    }
  }
  
  .game-instructions {
    background: rgba(35, 35, 70, 0.6);
    border-radius: 15px;
    padding: 25px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(106, 90, 224, 0.2);
    transition: all 0.3s ease;
    position: relative;
    overflow: hidden;
  }
  
  .game-instructions:hover {
    box-shadow: 0 12px 30px rgba(106, 90, 224, 0.3);
    transform: translateY(-3px);
  }
  
  .game-instructions::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 3px;
    height: 100%;
    background: linear-gradient(to bottom, #6a5ae0, transparent);
  }

  .instruction-title {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 1.3rem;
    display: flex;
    align-items: center;
    font-weight: 700;
    letter-spacing: 0.5px;
  }
  
  .instruction-title i {
    margin-right: 10px;
    background: rgba(106, 90, 224, 0.2);
    width: 30px;
    height: 30px;
    display: flex;
    align-items: center;
    justify-content: center;
    border-radius: 50%;
  }

  .instruction-list {
    list-style-type: none;
    padding-left: 15px;
    margin: 0;
  }

  .instruction-list li {
    color: rgba(255, 255, 255, 0.9);
    margin-bottom: 12px;
    font-size: 1rem;
    position: relative;
    padding-left: 25px;
    transition: all 0.3s ease;
  }
  
  .instruction-list li:hover {
    color: white;
    transform: translateX(5px);
  }
  
  .instruction-list li::before {
    content: '→';
    position: absolute;
    left: 0;
    color: var(--accent-color);
    transition: all 0.3s ease;
  }
  
  .instruction-list li:hover::before {
    transform: translateX(3px);
  }

  .instruction-list li:last-child {
    margin-bottom: 0;
  }

  /* Success Modal */
  .memory-success-modal {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(15, 15, 25, 0.95);
    display: none;
    justify-content: center;
    align-items: center;
    z-index: 1000;
    backdrop-filter: blur(8px);
  }

  .success-content {
    background: rgba(30, 30, 55, 0.95);
    border-radius: 20px;
    padding: 40px;
    text-align: center;
    max-width: 90%;
    width: 450px;
    box-shadow: 0 20px 50px rgba(0, 0, 0, 0.5);
    border: 1px solid rgba(106, 90, 224, 0.3);
    animation: modalFadeIn 0.6s cubic-bezier(0.2, 0.8, 0.2, 1);
    position: relative;
    overflow: hidden;
  }
  
  .success-content::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: radial-gradient(circle at top right, rgba(106, 90, 224, 0.3), transparent 70%);
    pointer-events: none;
  }

  .success-content h2 {
    color: var(--accent-color);
    margin-bottom: 15px;
    font-size: 2.2rem;
    font-weight: 800;
    text-shadow: 0 2px 10px rgba(106, 90, 224, 0.5);
    letter-spacing: 1px;
  }
  
  .success-content h2 i {
    display: inline-block;
    animation: trophyBounce 1s infinite alternate;
    transform-origin: bottom center;
  }
  
  @keyframes trophyBounce {
    from { transform: scale(1) rotate(-5deg); }
    to { transform: scale(1.2) rotate(5deg); }
  }

  .success-content p {
    color: white;
    margin-bottom: 30px;
    font-size: 1.2rem;
    font-weight: 500;
  }

  .success-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 40px;
  }

  .success-stat {
    text-align: center;
    background: rgba(40, 40, 80, 0.6);
    padding: 15px 25px;
    border-radius: 15px;
    min-width: 120px;
    box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
    border: 1px solid rgba(106, 90, 224, 0.2);
    transition: all 0.3s ease;
  }
  
  .success-stat:hover {
    transform: translateY(-5px);
    box-shadow: 0 10px 25px rgba(106, 90, 224, 0.3);
  }

  .success-stat-value {
    font-size: 2.8rem;
    font-weight: 800;
    color: var(--accent-color);
    margin-bottom: 5px;
    text-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
    background: linear-gradient(to right, #6a5ae0, #a890ff);
    -webkit-background-clip: text;
    -webkit-text-fill-color: transparent;
  }

  .success-stat-label {
    color: rgba(255, 255, 255, 0.7);
    font-size: 0.9rem;
    font-weight: 600;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .success-actions {
    display: flex;
    flex-direction: column;
    gap: 15px;
  }
  
  .success-actions .btn {
    padding: 15px 30px;
    font-weight: 600;
    font-size: 1.1rem;
    border-radius: 50px;
    letter-spacing: 0.5px;
    box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
    transition: all 0.3s cubic-bezier(0.2, 0.8, 0.2, 1);
    position: relative;
    overflow: hidden;
  }
  
  .success-actions .btn-primary {
    background: linear-gradient(to right, #6a5ae0, #a890ff);
    border: none;
  }
  
  .success-actions .btn-primary:hover {
    transform: translateY(-3px) scale(1.02);
    box-shadow: 0 12px 30px rgba(106, 90, 224, 0.5);
  }
  
  .success-actions .btn-outline-light {
    border: 2px solid rgba(255, 255, 255, 0.2);
    background: transparent;
  }
  
  .success-actions .btn-outline-light:hover {
    background: rgba(255, 255, 255, 0.1);
    border-color: rgba(255, 255, 255, 0.3);
    transform: translateY(-3px);
  }
  
  .success-actions .btn::before {
    content: '';
    position: absolute;
    top: 0;
    left: -100%;
    width: 100%;
    height: 100%;
    background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
    transition: all 0.6s ease;
  }
  
  .success-actions .btn:hover::before {
    left: 100%;
  }

  @keyframes modalFadeIn {
    from {
      opacity: 0;
      transform: translateY(-30px) scale(0.9);
    }
    to {
      opacity: 1;
      transform: translateY(0) scale(1);
    }
  }

  /* Confetti effect for matched cards */
  .confetti {
    position: absolute;
    width: 5px;
    height: 10px;
    background-color: #f00;
    opacity: 0;
    animation: confetti-fall 2s ease forwards;
    z-index: -1;
  }
  
  @keyframes confetti-fall {
    0% {
      transform: translateY(-10px) rotate(0deg);
      opacity: 1;
    }
    100% {
      transform: translateY(100px) rotate(360deg);
      opacity: 0;
    }
  }

  /* Responsive Design */
  @media (max-width: 768px) {
    .memory-card {
      width: 70px;
      height: 70px;
    }

    .memory-board.medium .memory-card,
    .memory-board.hard .memory-card {
      width: 60px;
      height: 60px;
    }

    .memory-card-front i {
      font-size: 1.7rem;
    }
    
    .game-controls {
      flex-wrap: wrap;
    }
    
    .memory-stat-value {
      font-size: 1.5rem;
    }
    
    .success-content {
      padding: 25px;
    }
    
    .success-stat-value {
      font-size: 2.2rem;
    }
  }

  @media (max-width: 576px) {
    .memory-card {
      width: 60px;
      height: 60px;
    }

    .memory-board.medium .memory-card {
      width: 50px;
      height: 50px;
    }

    .memory-board.hard .memory-card {
      width: 40px;
      height: 40px;
    }

    .memory-card-front i {
      font-size: 1.5rem;
    }

    .memory-board.hard .memory-card-front i {
      font-size: 1.2rem;
    }
    
    .game-controls {
      flex-direction: column;
    }
    
    .game-controls .btn {
      width: 100%;
    }
    
    .success-stats {
      flex-direction: column;
      gap: 15px;
      align-items: center;
    }
    
    .success-stat {
      width: 80%;
    }
  }
</style>

<script>
document.addEventListener('DOMContentLoaded', function() {
  // DOM Elements
  const memoryBoard = document.getElementById('memory-board');
  const movesDisplay = document.getElementById('moves-count');
  const matchesDisplay = document.getElementById('matches-count');
  const timerDisplay = document.getElementById('timer');
  const restartBtn = document.getElementById('restart-btn');
  const difficultyBtns = document.querySelectorAll('.difficulty-btn');
  const successModal = document.getElementById('success-modal');
  const finalMovesDisplay = document.getElementById('final-moves');
  const finalTimeDisplay = document.getElementById('final-time');
  const playAgainBtn = document.getElementById('play-again-btn');

  // Game State
  let cards = [];
  let hasFlippedCard = false;
  let lockBoard = false;
  let firstCard, secondCard;
  let moves = 0;
  let matches = 0;
  let timer = null;
  let seconds = 0;
  let gameStarted = false;
  let difficulty = 'easy';
  let totalPairs = 6; // For easy difficulty

  // Icons for cards with categories
  const cardIcons = {
    nature: ['fas fa-leaf', 'fas fa-tree', 'fas fa-cloud', 'fas fa-sun', 'fas fa-moon', 'fas fa-snowflake', 'fas fa-mountain', 'fas fa-fire'],
    animals: ['fas fa-dog', 'fas fa-cat', 'fas fa-horse', 'fas fa-fish', 'fas fa-dragon', 'fas fa-spider', 'fas fa-hippo', 'fas fa-crow'],
    objects: ['fas fa-key', 'fas fa-car', 'fas fa-gift', 'fas fa-bell', 'fas fa-book', 'fas fa-coffee', 'fas fa-camera', 'fas fa-pen'],
    symbols: ['fas fa-heart', 'fas fa-star', 'fas fa-crown', 'fas fa-gem', 'fas fa-bolt', 'fas fa-music', 'fas fa-rocket', 'fas fa-anchor']
  };

  // Colors for card categories
  const categoryColors = {
    nature: ['#4CAF50', '#8BC34A'],
    animals: ['#FF9800', '#FFC107'],
    objects: ['#2196F3', '#03A9F4'],
    symbols: ['#9C27B0', '#E040FB']
  };

  // Audio
  const flipSound = new Audio('/static/sounds/card-flip.mp3');
  const matchSound = new Audio('/static/sounds/match.mp3');
  const noMatchSound = new Audio('/static/sounds/no-match.mp3');
  const gameCompleteSound = new Audio('/static/sounds/game-complete.mp3');

  // Initialize game
  initializeGame();

  // Event Listeners
  restartBtn.addEventListener('click', restartGame);
  playAgainBtn.addEventListener('click', function() {
    successModal.style.display = 'none';
    restartGame();
  });

  difficultyBtns.forEach(btn => {
    btn.addEventListener('click', function() {
      const newDifficulty = this.getAttribute('data-difficulty');
      if (newDifficulty !== difficulty) {
        difficulty = newDifficulty;
        
        // Update total pairs based on difficulty
        if (difficulty === 'easy') totalPairs = 6;
        else if (difficulty === 'medium') totalPairs = 10;
        else if (difficulty === 'hard') totalPairs = 15;
        
        // Update board class
        memoryBoard.className = `memory-board ${difficulty}`;
        
        // Update active button
        difficultyBtns.forEach(b => b.classList.remove('active'));
        this.classList.add('active');
        
        // Restart game with new difficulty
        restartGame();
      }
    });
  });

  // Functions
  function initializeGame() {
    // Create cards
    createCards();
    
    // Reset game state
    resetGameState();
    
    // Shuffle cards
    shuffleCards();
    
    // Add intro animation
    animateCards();
  }

  function createCards() {
    // Clear the board
    memoryBoard.innerHTML = '';
    cards = [];
    
    // Get all categories for the icons
    const categories = Object.keys(cardIcons);
    
    // Create pairs of cards
    let pairsCreated = 0;
    let categoryIndex = 0;
    
    while (pairsCreated < totalPairs) {
      const category = categories[categoryIndex % categories.length];
      const availableIcons = [...cardIcons[category]]; // Create a copy
      
      // Determine how many pairs to create from this category
      const pairsFromCategory = Math.min(availableIcons.length, totalPairs - pairsCreated);
      
      // Shuffle the icons within this category
      shuffleArray(availableIcons);
      
      // Create pairs from this category
      for (let i = 0; i < pairsFromCategory; i++) {
        if (pairsCreated >= totalPairs) break;
        
        const icon = availableIcons[i];
        const categoryColor = categoryColors[category];
        
        // Create two cards with the same icon
        for (let j = 0; j < 2; j++) {
          const card = createCard(icon, category, categoryColor);
          memoryBoard.appendChild(card);
          cards.push(card);
        }
        
        pairsCreated++;
      }
      
      categoryIndex++;
    }
    
    // Final shuffle of all cards in the DOM
    cards.forEach(card => {
      const randomPos = Math.floor(Math.random() * cards.length);
      card.style.order = randomPos;
    });
  }

  function createCard(icon, category, categoryColor) {
    const card = document.createElement('div');
    card.className = 'memory-card';
    card.dataset.icon = icon;
    card.dataset.category = category;
    
    // Create front of card (icon)
    const front = document.createElement('div');
    front.className = 'memory-card-front';
    front.innerHTML = `<i class="${icon}"></i>`;
    front.style.background = `linear-gradient(135deg, ${categoryColor[0]}, ${categoryColor[1]})`;
    
    // Create back of card (pattern)
    const back = document.createElement('div');
    back.className = 'memory-card-back';
    
    // Add to card
    card.appendChild(front);
    card.appendChild(back);
    
    // Add click event
    card.addEventListener('click', flipCard);
    
    return card;
  }

  function resetGameState() {
    [hasFlippedCard, lockBoard] = [false, false];
    [firstCard, secondCard] = [null, null];
    moves = 0;
    matches = 0;
    seconds = 0;
    gameStarted = false;
    
    // Reset displays
    movesDisplay.textContent = moves;
    matchesDisplay.textContent = matches;
    timerDisplay.textContent = '00:00';
    
    // Clear timer
    if (timer) clearInterval(timer);
  }

  function shuffleCards() {
    cards.forEach(card => {
      const randomPos = Math.floor(Math.random() * cards.length);
      card.style.order = randomPos;
    });
  }
  
  function animateCards() {
    // Add staggered intro animation to each card
    cards.forEach((card, index) => {
      setTimeout(() => {
        card.style.animation = 'cardIntro 0.6s cubic-bezier(0.2, 0.8, 0.2, 1) forwards';
      }, index * 50);
    });
  }

  function startTimer() {
    if (timer) clearInterval(timer);
    
    timer = setInterval(() => {
      seconds++;
      const minutes = Math.floor(seconds / 60);
      const secs = seconds % 60;
      timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
    }, 1000);
  }

  function flipCard() {
    // Start the game on the first card flip
    if (!gameStarted) {
      gameStarted = true;
      startTimer();
    }
    
    // If board is locked or this card is already flipped, exit
    if (lockBoard) return;
    if (this === firstCard) return;
    if (this.classList.contains('matched')) return;
    
    // Flip the card with a slight delay for animation
    this.classList.add('flip');
    
    // Play flip sound
    flipSound.currentTime = 0;
    flipSound.play();
    
    if (!hasFlippedCard) {
      // First card flipped
      hasFlippedCard = true;
      firstCard = this;
      return;
    }
    
    // Second card flipped
    secondCard = this;
    
    // Increment moves
    moves++;
    movesDisplay.textContent = moves;
    
    // Check for match
    checkForMatch();
  }

  function checkForMatch() {
    // Lock the board while checking
    lockBoard = true;
    
    // Check if the cards match
    const isMatch = firstCard.dataset.icon === secondCard.dataset.icon;
    
    if (isMatch) {
      // Cards match
      disableCards();
      matches++;
      matchesDisplay.textContent = matches;
      
      // Add matched class for styling
      firstCard.classList.add('matched');
      secondCard.classList.add('matched');
      
      // Add pulsing animation to matched cards
      firstCard.style.animation = 'cardMatch 0.5s ease forwards';
      secondCard.style.animation = 'cardMatch 0.5s ease forwards';
      
      // Create confetti effect around matched cards
      createConfetti(firstCard);
      createConfetti(secondCard);
      
      // Play match sound
      matchSound.currentTime = 0;
      matchSound.play();
      
      // Check if all pairs are found
      if (matches === totalPairs) {
        gameComplete();
      } else {
        // Unlock board
        lockBoard = false;
      }
    } else {
      // Cards don't match
      // Play no match sound
      noMatchSound.currentTime = 0;
      noMatchSound.play();
      
      // Add slight shake animation
      firstCard.style.animation = 'cardNoMatch 0.5s ease';
      secondCard.style.animation = 'cardNoMatch 0.5s ease';
      
      // Flip cards back after a delay
      setTimeout(() => {
        firstCard.classList.remove('flip');
        secondCard.classList.remove('flip');
        
        // Reset animations
        firstCard.style.animation = '';
        secondCard.style.animation = '';
        
        lockBoard = false;
        
        // Reset board state
        resetBoard();
      }, 1000);
    }
  }
  
  function createConfetti(card) {
    // Get card position
    const rect = card.getBoundingClientRect();
    const boardRect = memoryBoard.getBoundingClientRect();
    
    // Create confetti pieces
    const colors = ['#6a5ae0', '#a890ff', '#ff4081', '#ffc107', '#4caf50', '#2196f3'];
    
    for (let i = 0; i < 20; i++) {
      const confetti = document.createElement('div');
      confetti.className = 'confetti';
      confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
      confetti.style.left = rect.left - boardRect.left + Math.random() * rect.width + 'px';
      confetti.style.top = rect.top - boardRect.top + Math.random() * rect.height + 'px';
      confetti.style.width = Math.random() * 7 + 3 + 'px';
      confetti.style.height = Math.random() * 10 + 5 + 'px';
      confetti.style.animationDuration = Math.random() * 2 + 1 + 's';
      
      memoryBoard.appendChild(confetti);
      
      // Remove confetti after animation
      setTimeout(() => {
        confetti.remove();
      }, 2000);
    }
  }

  function disableCards() {
    // Remove event listeners to prevent further flipping
    firstCard.removeEventListener('click', flipCard);
    secondCard.removeEventListener('click', flipCard);
    
    // Reset board state
    resetBoard();
  }

  function resetBoard() {
    // Reset variables for next pair
    [hasFlippedCard, lockBoard] = [false, false];
    [firstCard, secondCard] = [null, null];
  }

  function restartGame() {
    // Lock board to prevent clicks during restart
    lockBoard = true;
    
    // Add card exit animation
    cards.forEach((card, index) => {
      setTimeout(() => {
        card.style.animation = 'cardExit 0.4s cubic-bezier(0.2, 0.8, 0.2, 1) forwards';
      }, index * 30);
    });
    
    // Wait for animation to complete
    setTimeout(() => {
      // Reset game state
      resetGameState();
      
      // Create new cards
      createCards();
      
      // Shuffle cards
      shuffleCards();
      
      // Add new intro animation
      animateCards();
      
      // Unlock board
      lockBoard = false;
    }, cards.length * 30 + 500);
  }

  function gameComplete() {
    // Stop the timer
    clearInterval(timer);
    
    // Play complete sound
    gameCompleteSound.currentTime = 0;
    gameCompleteSound.play();
    
    // Add celebration animation to all cards
    cards.forEach((card, index) => {
      setTimeout(() => {
        card.style.animation = "cardCelebration 0.8s ease infinite alternate";
      }, index * 50);
    });
    
    // Calculate score based on moves, time and difficulty
    const timeInSeconds = seconds;
    let difficultyMultiplier = 1;
    if (difficulty === "medium") difficultyMultiplier = 2;
    if (difficulty === "hard") difficultyMultiplier = 3;
    
    // Base score is higher for more difficult modes
    let calculatedScore = 1000 * difficultyMultiplier;
    
    // Subtract points for each move (less impact on higher difficulties)
    calculatedScore -= moves * (10 / difficultyMultiplier);
    
    // Subtract points for time (less impact on higher difficulties)
    calculatedScore -= timeInSeconds * (5 / difficultyMultiplier);
    
    // Ensure minimum score of 100
    calculatedScore = Math.max(100, Math.round(calculatedScore));
    
    // Show success message
    finalMovesDisplay.textContent = moves;
    finalTimeDisplay.textContent = timerDisplay.textContent;
    
    // Save score
    saveScore(calculatedScore);
    
    // Update success modal to show points earned
    const pointsEarned = document.createElement("div");
    pointsEarned.className = "points-earned";
    pointsEarned.innerHTML = `
      <div class="points-label">Kazanılan Puan</div>
      <div class="points-value">${calculatedScore}</div>
    `;
    pointsEarned.style.marginBottom = "20px";
    pointsEarned.style.textAlign = "center";
    pointsEarned.style.animation = "fadeInUp 0.5s 0.5s forwards";
    pointsEarned.style.opacity = "0";
    
    // Style for points display
    const pointsValue = pointsEarned.querySelector(".points-value");
    pointsValue.style.fontSize = "3rem";
    pointsValue.style.fontWeight = "800";
    pointsValue.style.background = "linear-gradient(to right, #6a5ae0, #a890ff)";
    pointsValue.style.WebkitBackgroundClip = "text";
    pointsValue.style.WebkitTextFillColor = "transparent";
    pointsValue.style.textShadow = "0 2px 10px rgba(106, 90, 224, 0.3)";
    pointsValue.style.marginTop = "5px";
    
    const pointsLabel = pointsEarned.querySelector(".points-label");
    pointsLabel.style.fontSize = "1rem";
    pointsLabel.style.color = "rgba(255, 255, 255, 0.7)";
    pointsLabel.style.textTransform = "uppercase";
    pointsLabel.style.letterSpacing = "1px";
    
    // Get existing content and insert points earned before success-actions
    const successContent = document.querySelector(".success-content");
    const successActions = document.querySelector(".success-actions");
    successContent.insertBefore(pointsEarned, successActions);
    
    // Show leaderboard button
    const leaderboardBtn = document.createElement("a");
    leaderboardBtn.href = "/leaderboard";
    leaderboardBtn.className = "btn btn-outline-secondary btn-lg";
    leaderboardBtn.innerHTML = "<i class="fas fa-trophy me-2"></i>Puan Tablosu";
    leaderboardBtn.style.marginTop = "10px";
    
    // Add to success actions
    successActions.appendChild(leaderboardBtn);
    
    // Create fireworks effect
    createFireworks();
    
    // Show success modal after a delay
    setTimeout(() => {
      successModal.style.display = "flex";
    }, 1500);
  }
  
  // Function to create fireworks effect
  function createFireworks() {
    const fireworksContainer = document.createElement("div");
    fireworksContainer.className = "fireworks-container";
    fireworksContainer.style.position = "fixed";
    fireworksContainer.style.top = "0";
    fireworksContainer.style.left = "0";
    fireworksContainer.style.width = "100%";
    fireworksContainer.style.height = "100%";
    fireworksContainer.style.pointerEvents = "none";
    fireworksContainer.style.zIndex = "999";
    document.body.appendChild(fireworksContainer);
    
    // Create 10 fireworks with random positions and colors
    const colors = ["#6a5ae0", "#4CAF50", "#FF9800", "#F44336", "#a890ff", "#2196F3"];
    
    for (let i = 0; i < 10; i++) {
      setTimeout(() => {
        const firework = document.createElement("div");
        firework.className = "firework";
        
        // Random position
        const x = Math.random() * 100;
        const y = Math.random() * 60 + 20;
        firework.style.left = `${x}%`;
        firework.style.top = `${y}%`;
        
        // Random color
        const color = colors[Math.floor(Math.random() * colors.length)];
        firework.style.position = "absolute";
        firework.style.width = "5px";
        firework.style.height = "5px";
        firework.style.borderRadius = "50%";
        firework.style.background = color;
        firework.style.boxShadow = `0 0 10px ${color}, 0 0 20px ${color}`;
        firework.style.animation = "fireworkExplode 0.8s forwards";
        
        fireworksContainer.appendChild(firework);
        
        // Create particles for this firework
        for (let j = 0; j < 30; j++) {
          const particle = document.createElement("div");
          particle.className = "firework-particle";
          particle.style.position = "absolute";
          particle.style.left = "50%";
          particle.style.top = "50%";
          particle.style.width = "3px";
          particle.style.height = "3px";
          particle.style.borderRadius = "50%";
          particle.style.background = color;
          particle.style.boxShadow = `0 0 6px ${color}`;
          
          // Random angle and speed
          const angle = Math.random() * Math.PI * 2;
          const speed = Math.random() * 50 + 30;
          particle.style.transform = `translate(-50%, -50%)`;
          particle.style.animation = "fireworkParticle 1s forwards";
          
          // Set animation delay for staggered effect
          particle.style.animationDelay = "0.1s";
          
          // Apply custom transform to each particle
          const moveX = Math.cos(angle) * speed;
          const moveY = Math.sin(angle) * speed;
          particle.style.setProperty("--moveX", `${moveX}px`);
          particle.style.setProperty("--moveY", `${moveY}px`);
          
          firework.appendChild(particle);
        }
        
        // Remove firework after animation completes
        setTimeout(() => {
          firework.remove();
        }, 2000);
      }, i * 300);
    }
    
    // Remove container after all animations complete
    setTimeout(() => {
      fireworksContainer.remove();
    }, 5000);
    
    // Add keyframes for fireworks
    const fireworkStyles = document.createElement("style");
    fireworkStyles.textContent = `
      @keyframes fireworkExplode {
        0% { transform: scale(1); opacity: 1; }
        20% { transform: scale(1.5); opacity: 1; }
        100% { transform: scale(0.1); opacity: 0; }
      }
      
      @keyframes fireworkParticle {
        0% { transform: translate(-50%, -50%) scale(1); opacity: 1; }
        100% { transform: translate(calc(-50% + var(--moveX)), calc(-50% + var(--moveY))) scale(0); opacity: 0; }
      }
      
      @keyframes fadeInUp {
        from { opacity: 0; transform: translateY(20px); }
        to { opacity: 1; transform: translateY(0); }
      }
    `;
    document.head.appendChild(fireworkStyles);
  }
  
  // Function to save score to the server
  function saveScore(score) {
    fetch("/api/save-score", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({
        game_type: "memory_match",
        score: score
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log("Score saved:", data);
      
      if (data.success) {
        // Show notification of score saved
        showScoreNotification(score);
      }
    })
    .catch(error => {
      console.error("Error saving score:", error);
    });
  }
  
  // Function to show a floating notification when score is saved
  function showScoreNotification(score) {
    const notification = document.createElement("div");
    notification.className = "score-notification";
    notification.innerHTML = `
      <i class="fas fa-check-circle"></i>
      <span>${score} puan kaydedildi!</span>
    `;
    
    // Style the notification
    notification.style.position = "fixed";
    notification.style.bottom = "20px";
    notification.style.right = "20px";
    notification.style.backgroundColor = "rgba(106, 90, 224, 0.9)";
    notification.style.color = "white";
    notification.style.padding = "12px 20px";
    notification.style.borderRadius = "8px";
    notification.style.boxShadow = "0 5px 15px rgba(0,0,0,0.3)";
    notification.style.display = "flex";
    notification.style.alignItems = "center";
    notification.style.gap = "10px";
    notification.style.zIndex = "9999";
    notification.style.opacity = "0";
    notification.style.transform = "translateY(20px)";
    notification.style.transition = "all 0.3s ease";
    notification.style.fontWeight = "600";
    
    // Add to document
    document.body.appendChild(notification);
    
    // Show with animation
    setTimeout(() => {
      notification.style.opacity = "1";
      notification.style.transform = "translateY(0)";
    }, 100);
    
    // Remove after a few seconds
    setTimeout(() => {
      notification.style.opacity = "0";
      notification.style.transform = "translateY(20px)";
      
      setTimeout(() => {
        notification.remove();
      }, 300);
    }, 5000);
  }
    fetch('/api/save-score', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        game_type: 'memory_match',
        score: score
      })
    })
    .then(response => response.json())
    .then(data => {
      console.log('Score saved:', data);
    })
    .catch(error => {
      console.error('Error saving score:', error);
    });
  }

  // Add animation keyframes dynamically
  const styleSheet = document.createElement('style');
  styleSheet.type = 'text/css';
  styleSheet.innerText = `
    @keyframes cardIntro {
      0% { opacity: 0; transform: scale(0.8) translateY(20px); }
      100% { opacity: 1; transform: scale(1) translateY(0); }
    }
    
    @keyframes cardExit {
      0% { opacity: 1; transform: scale(1) rotateY(0deg); }
      100% { opacity: 0; transform: scale(0.8) rotateY(90deg); }
    }
    
    @keyframes cardMatch {
      0% { transform: rotateY(180deg) scale(1); }
      50% { transform: rotateY(180deg) scale(1.1); box-shadow: 0 0 20px rgba(106, 90, 224, 0.8); }
      100% { transform: rotateY(180deg) scale(1); box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2); }
    }
    
    @keyframes cardNoMatch {
      0%, 100% { transform: rotateY(180deg) translateX(0); }
      20%, 60% { transform: rotateY(180deg) translateX(-5px); }
      40%, 80% { transform: rotateY(180deg) translateX(5px); }
    }
    
    @keyframes cardCelebration {
      0% { transform: rotateY(180deg) scale(1) translateY(0); }
      100% { transform: rotateY(180deg) scale(1.05) translateY(-5px); }
    }
  `;
  document.head.appendChild(styleSheet);
});
</script>
{% endblock %}
